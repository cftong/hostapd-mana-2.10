diff '--color=auto' -rN hostapd-2.6/hostapd/.config hostapd-mana/hostapd/.config
16c16
< #CONFIG_DRIVER_WIRED=y
---
> CONFIG_DRIVER_WIRED=y
34c34
< #CONFIG_LIBNL32=y
---
> CONFIG_LIBNL32=y
45c45
< #CONFIG_DRIVER_NONE=y
---
> CONFIG_DRIVER_NONE=y
84c84
< #CONFIG_EAP_SIM=y
---
> CONFIG_EAP_SIM=y
87c87
< #CONFIG_EAP_AKA=y
---
> CONFIG_EAP_AKA=y
91c91
< #CONFIG_EAP_AKA_PRIME=y
---
> CONFIG_EAP_AKA_PRIME=y
94c94
< #CONFIG_EAP_PAX=y
---
> CONFIG_EAP_PAX=y
97c97
< #CONFIG_EAP_PSK=y
---
> CONFIG_EAP_PSK=y
100c100
< #CONFIG_EAP_PWD=y
---
> CONFIG_EAP_PWD=y
103c103
< #CONFIG_EAP_SAKE=y
---
> CONFIG_EAP_SAKE=y
106c106
< #CONFIG_EAP_GPSK=y
---
> CONFIG_EAP_GPSK=y
108c108
< #CONFIG_EAP_GPSK_SHA256=y
---
> CONFIG_EAP_GPSK_SHA256=y
114c114
< #CONFIG_EAP_FAST=y
---
> CONFIG_EAP_FAST=y
117c117
< CONFIG_WPS=y
---
> #CONFIG_WPS=y
119c119
< CONFIG_WPS_UPNP=y
---
> #CONFIG_WPS_UPNP=y
121c121
< CONFIG_WPS_NFC=y
---
> #CONFIG_WPS_NFC=y
124c124
< #CONFIG_EAP_IKEV2=y
---
> CONFIG_EAP_IKEV2=y
127c127
< #CONFIG_EAP_TNC=y
---
> CONFIG_EAP_TNC=y
130c130
< #CONFIG_EAP_EKE=y
---
> CONFIG_EAP_EKE=y
138c138
< #CONFIG_RADIUS_SERVER=y
---
> CONFIG_RADIUS_SERVER=y
144c144
< #CONFIG_IEEE80211R=y
---
> CONFIG_IEEE80211R=y
158c158
< #CONFIG_IEEE80211AC=y
---
> CONFIG_IEEE80211AC=y
334c334
< CONFIG_ACS=y
---
> #CONFIG_ACS=y
345c345
< #CONFIG_TAXONOMY=y
---
> CONFIG_TAXONOMY=y
diff '--color=auto' -rN hostapd-2.6/hostapd/config_file.c hostapd-mana/hostapd/config_file.c
23a24,25
> #include <stdlib.h>
> 
120a123,182
> // MANA Start - SSID Filter
> static int hostapd_config_read_ssidlist(const char *fname,
> 		struct ssid_filter_entry **ssid_filter, int *num)
> {
> 	FILE *f;
> 	char buf[128], *pos;
> 	int line = 0;
> 
> 	struct ssid_filter_entry *new_ssid_filter;
> 
> 	if (!fname)
> 		return 0;
> 
> 	f = fopen(fname, "r");
> 	if (!f) {
> 		wpa_printf(MSG_ERROR, "SSID list file '%s' not found.", fname);
> 		return -1;
> 	}
> 
> 	while (fgets(buf, sizeof(buf), f)) {
> 		line++;
> 
> 		if (buf[0] == '#')
> 			continue;
> 
> 		while (*pos != '\0') {
> 			if (*pos == '\n') {
> 				*pos = '\0';
> 				break;
> 			}
> 			pos++;
> 		}
> 
> 		if (buf[0] == '\0')
> 			continue;
> 
> 		pos = buf;
> 		if(strlen(pos) > SSID_MAX_LEN){
> 			wpa_printf(MSG_ERROR, "SSID %s is too long (more than %d characters.)",pos,SSID_MAX_LEN);
> 			return -1;
> 		}
> 
> 		new_ssid_filter = os_realloc_array(*ssid_filter, *num + 1, sizeof(**ssid_filter));
> 		if (new_ssid_filter == NULL) {
> 			wpa_printf(MSG_ERROR, "SSID list reallocation failed");
> 			fclose(f);
> 			return -1;
> 		}
> 
> 		*ssid_filter = new_ssid_filter;
> 		os_memcpy((*ssid_filter)[*num].ssid, pos, strnlen(pos, SSID_MAX_LEN));
> 
> 		(*num)++;
> 		wpa_printf(MSG_INFO, "SSID: '%s' added.", pos);
> 	}
> 
> 	fclose(f);
> 	return 0;
> }
> //MANA End
126a189
> 	char *lastpos; //MANA
128a192
> 	u8 mask[ETH_ALEN], transform[ETH_ALEN]; //MANA
130a195
> 	int vlanflag = 0; //MANA
157a223
> 		lastpos = pos; //MANA
190,191c256,295
< 		if (*pos != '\0')
< 			vlan_id = atoi(pos);
---
> 		if (*pos != '\0') {
> 			if (*(pos+2) != ':') { //MANA
> 				vlan_id = atoi(pos);
> 				vlanflag = 1;
> 			}
> 		}
> 
> 		//MANA Start - parse MAC mask
> 		lastpos = pos;
> 		while (*pos != '\0') {
> 			if (*pos == '\n') {
> 				*pos = '\0';
> 				break;
> 			}
> 			pos++;
> 		}
> 		pos = lastpos;
> 
> 		if (vlanflag) {
> 			while (*pos != '\0' && *pos != ' ' && *pos != '\t')
> 				pos++;
> 			while (*pos == ' ' || *pos == '\t')
> 				pos++;
> 		}
> 
> 		if (*pos != '\0') {
> 			if (hwaddr_aton(pos, mask)) {
> 				wpa_printf(MSG_ERROR, "Invalid MAC mask '%s' at "
> 					   "line %d in '%s'", pos, line, fname);
> 				fclose(f);
> 				return -1;
> 			}
> 		} else 
> 			hwaddr_aton("ff:ff:ff:ff:ff:ff", mask); //No mask specified to add a "no change" mask
> 
> 		i = 0;
> 		for (i=0; i<ETH_ALEN; i++) {
> 			transform[i] = addr[i] & mask[i]; //We need to store it transformed for the binary search used in hostapd_maclist_found to get a properly sorted list
> 		}
> 		//MANA End
201c305,307
< 		os_memcpy((*acl)[*num].addr, addr, ETH_ALEN);
---
> 		//os_memcpy((*acl)[*num].addr, addr, ETH_ALEN);
> 		os_memcpy((*acl)[*num].addr, transform, ETH_ALEN); //MANA
> 		os_memcpy((*acl)[*num].mask, mask, ETH_ALEN); //MANA
2031a2138,2238
> 	// MANA START
> 	} else if (os_strcmp(buf, "enable_mana") == 0) {
> 		int val = atoi(pos);
> 		conf->enable_mana = (val != 0);
> 		if (os_strcmp(conf->mana_wpaout,"NOT_SET") != 0) {
> 			wpa_printf(MSG_ERROR, "MANA: For now, you can't use mana mode with WPA/2 handshake capture. See the Wiki.");
> 			return 1;
> 		}
> 		if (conf->enable_mana) {
> 			wpa_printf(MSG_DEBUG, "MANA: Enabled");
> 		}
> 	} else if (os_strcmp(buf, "mana_loud") == 0) {
> 		int val = atoi(pos);
> 		conf->mana_loud = (val != 0);
> 		if (conf->mana_loud) {
> 			wpa_printf(MSG_DEBUG, "MANA: Loud mode enabled");
> 		}
> 	} else if (os_strcmp(buf, "mana_macacl") == 0) {
> 		int val = atoi(pos);
> 		conf->mana_macacl = (val != 0);
> 		if (conf->mana_macacl) {
> 			wpa_printf(MSG_DEBUG, "MANA: MAC ACLs extended to management frames");
> 		}
> 	} else if (os_strcmp(buf, "mana_outfile") == 0) {
> 		char *tmp = malloc(strlen(pos));
> 		strcpy(tmp,pos);
> 		FILE *f = fopen(pos, "a");
> 		if (!f) {
> 			wpa_printf(MSG_ERROR, "MANA: Line %d: Failed to open activity file '%s'", line, pos);
> 			return 1;
> 		}
> 		fclose(f);
> 		conf->mana_outfile = tmp;
> 		wpa_printf(MSG_INFO, "MANA: Observed activity will be written to. File %s set.",tmp);
> 	} else if (os_strcmp(buf, "mana_ssid_filter_file") == 0) {
> 		char *tmp1 = malloc(strlen(pos));
> 		strcpy(tmp1,pos);
> 		if (hostapd_config_read_ssidlist(pos, &bss->ssid_filter,
> 					&bss->num_ssid_filter)) {
> 			wpa_printf(MSG_ERROR, "Line %d: Failed to read SSID filter list '%s'",
> 				line, pos);
> 			return 1;
> 		}
> 		conf->mana_ssid_filter_file = tmp1;
> 		wpa_printf(MSG_INFO, "MANA: SSID Filter enabled. File %s set.",tmp1);
> 	} else if (os_strcmp(buf, "mana_wpe") == 0) {
> 		int val = atoi(pos);
> 		conf->mana_wpe = (val != 0);
> 		if (conf->mana_wpe) {
> 			wpa_printf(MSG_DEBUG, "MANA: WPE EAP mode enabled");
> 		}
> 	} else if (os_strcmp(buf, "mana_credout") == 0) {
> 		char *tmp2 = malloc(strlen(pos));
> 		strcpy(tmp2,pos);
> 		FILE *f = fopen(pos, "a");
> 		if (!f) {
> 			wpa_printf(MSG_ERROR, "MANA: Line %d: Failed to open credential out file '%s'", line, pos);
> 			return 1;
> 		}
> 		fclose(f);
> 		conf->mana_credout = tmp2;
> 		wpa_printf(MSG_INFO, "MANA: Captured credentials will be written to file '%s'.",conf->mana_credout);
> 	} else if (os_strcmp(buf, "mana_wpaout") == 0) {
> 		char *tmp2 = malloc(strlen(pos));
> 		strcpy(tmp2,pos);
> 		FILE *f = fopen(pos, "a");
> 		if (!f) {
> 			wpa_printf(MSG_ERROR, "MANA: Line %d: Failed to open WPA/2 handshake out file '%s'", line, pos);
> 			return 1;
> 		}
> 		fclose(f);
> 		conf->mana_wpaout = tmp2;
> 		wpa_printf(MSG_INFO, "MANA: Captured WPA/2 handshakes will be written to file '%s'.",conf->mana_wpaout);
> 	} else if (os_strcmp(buf, "mana_eapsuccess") == 0) {
> 		int val = atoi(pos);
> 		conf->mana_eapsuccess = (val != 0);
> 		if (conf->mana_eapsuccess) {
> 			wpa_printf(MSG_DEBUG, "MANA: EAP success mode enabled");
> 		}
> 	} else if (os_strcmp(buf, "mana_eaptls") == 0) {
> 		int val = atoi(pos);
> 		conf->mana_eaptls = (val != 0);
> 		if (conf->mana_eaptls) {
> 			wpa_printf(MSG_DEBUG, "MANA: EAP TLS modes will accept any client certificate.");
> 		}
> 	} else if (os_strcmp(buf, "enable_sycophant") == 0) {
> 		int val = atoi(pos);
> 		conf->enable_sycophant = (val != 0);
> 		if (conf->enable_sycophant) {
> 			wpa_printf(MSG_DEBUG, "SYCOPHANT: Enabled");
> 		}
> 	} else if (os_strcmp(buf, "sycophant_dir") == 0) {
> 		char *tmp = malloc(strlen(pos));
> 		strcpy(tmp,pos);
> 		if (access(pos, W_OK) != 0) {
> 			wpa_printf(MSG_ERROR, "SYCOPHANT: Line %d: Failed to access sycophant directory '%s'", line, pos);
> 			return 1;
> 		}
> 		conf->sycophant_dir = tmp;
> 		wpa_printf(MSG_INFO, "MANA: Sycohpant state directory set to %s.",tmp);
> 	// MANA END
3541a3749,3763
> 
> 	// MANA START
> 	conf->enable_mana = 0; //default off;
> 	conf->mana_loud = 0; //default off; 1 - advertise all networks across all devices, 0 - advertise specific networks to the device it was discovered from
> 	conf->mana_macacl = 0; //default off; 0 - off, 1 - extend MAC ACL to management frames
> 	conf->mana_outfile = "NOT_SET"; //default none
> 	conf->mana_ssid_filter_file = "NOT_SET"; //default none
> 	conf->mana_wpe = 0; //default off; 1 - dump credentials captured during EAP exchanges 0 - function as normal
> 	conf->mana_credout = "NOT_SET"; //default none
> 	conf->mana_wpaout = "NOT_SET"; //default none
> 	conf->mana_eapsuccess = 0; //default off; 1 - allow clients to connect even with incorrect creds 0 - function as normal
> 	conf->mana_eaptls = 0; //default off; 1 - accept any client certificate presented in EAP-TLS modes. 0 - validate certificates as normal.
> 	conf->enable_sycophant = 0; //default off; 1 - relay inner MSCHAPv2 authentication with wpa_sycophant. 0 - No relaying
> 	conf->sycophant_dir = "NOT_SET"; //default none
> 	// MANA END
diff '--color=auto' -rN hostapd-2.6/hostapd/ctrl_iface.c hostapd-mana/hostapd/ctrl_iface.c
59d58
< 
126a126,268
> // MANA START
> static int hostapd_ctrl_iface_mana_change_ssid (struct hostapd_data *hapd,
> 					     const char *ssid) {
> 	wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE CHANGE SSID %s", ssid);
> 
> 	if (strlen(ssid) > SSID_MAX_LEN || strlen(ssid) == 0) {
> 		return -1;
> 	}
> 
> 	hapd->conf->ssid.ssid_len = strlen(ssid);
> 	// Not sure if the +1 is needed here or not
> 	os_memcpy(hapd->conf->ssid.ssid, ssid, strlen(ssid) + 1);
> 	ieee802_11_set_beacon(hapd);
> 	wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE DEFAULT SSID CHANGED");
> 	return 0;
> }
> 
> static int hostapd_ctrl_iface_mana_enable_disable (struct hostapd_data *hapd, int status)
> {
> 	if (status) {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE ENABLED");
> 	} else {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE DISABLED");
> 	}
> 	hapd->iconf->enable_mana = status;
> 
> 	return 0;
> }
> 
> static int hostapd_ctrl_iface_mana_get_state (struct hostapd_data *hapd)
> {
> 	wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE STATUS QUERY");
> 	return hapd->iconf->enable_mana;
> }
> 
> static int hostapd_ctrl_iface_mana_loud_enable_disable (struct hostapd_data *hapd, int status)
> {
> 	if (status) {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE LOUD MODE ENABLED");
> 	} else {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE LOUD MODE DISABLED");
> 	}
> 	hapd->iconf->mana_loud = status;
> 
> 	return 0;
> }
> 
> static int hostapd_ctrl_iface_mana_get_mode (struct hostapd_data *hapd)
> {
> 	wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE LOUD MODE STATUS QUERY");
> 	return hapd->iconf->mana_loud;
> }
> 
> static int hostapd_ctrl_iface_mana_macacl_enable_disable (struct hostapd_data *hapd, int status)
> {
> 	if (status) {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE MACACL MODE ENABLED");
> 	} else {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE MACACL MODE DISABLED");
> 	}
> 	hapd->iconf->mana_macacl = status;
> 
> 	return 0;
> }
> 
> static int hostapd_ctrl_iface_mana_get_aclmode (struct hostapd_data *hapd)
> {
> 	wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE MAC ACL STATUS QUERY");
> 	return hapd->iconf->mana_macacl;
> }
> 
> static int hostapd_ctrl_iface_mana_wpe_enable_disable (struct hostapd_data *hapd, int status)
> {
> 	if (status) {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE WPE MODE ENABLED");
> 	} else {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE WPE MODE DISABLED");
> 	}
> 	hapd->iconf->mana_wpe = status;
> 
> 	return 0;
> }
> 
> static int hostapd_ctrl_iface_mana_get_wpemode (struct hostapd_data *hapd)
> {
> 	wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE WPE MODE STATUS QUERY");
> 	return hapd->iconf->mana_wpe;
> }
> 
> static int hostapd_ctrl_iface_mana_eapsuccess_enable_disable (struct hostapd_data *hapd, int status)
> {
> 	if (status) {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE EAPSUCCESS MODE ENABLED");
> 	} else {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE EAPSUCCESS MODE DISABLED");
> 	}
> 	hapd->iconf->mana_eapsuccess = status;
> 
> 	return 0;
> }
> 
> static int hostapd_ctrl_iface_mana_get_eapsuccessmode (struct hostapd_data *hapd)
> {
> 	wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE EAPSUCCESS MODE STATUS QUERY");
> 	return hapd->iconf->mana_eapsuccess;
> }
> 
> static int hostapd_ctrl_iface_mana_eaptls_enable_disable (struct hostapd_data *hapd, int status)
> {
> 	if (status) {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE EAPTLS MODE ENABLED");
> 	} else {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE EAPTLS MODE DISABLED");
> 	}
> 	hapd->iconf->mana_eaptls = status;
> 
> 	return 0;
> }
> 
> static int hostapd_ctrl_iface_mana_get_eaptlsmode (struct hostapd_data *hapd)
> {
> 	wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE EAPTLS MODE STATUS QUERY");
> 	return hapd->iconf->mana_eaptls;
> }
> 
> static int hostapd_ctrl_iface_sycophant_enable_disable (struct hostapd_data *hapd, int status)
> {
> 	if (status) {
> 		wpa_printf(MSG_DEBUG, "SYCOPHANT CTRL_IFACE ENABLED");
> 	} else {
> 		wpa_printf(MSG_DEBUG, "SYCOPHANT CTRL_IFACE DISABLED");
> 	}
> 	hapd->iconf->enable_sycophant = status;
> 
> 	return 0;
> }
> 
> static int hostapd_ctrl_iface_sycophant_get_state (struct hostapd_data *hapd)
> {
> 	wpa_printf(MSG_DEBUG, "SYCOPHANT CTRL_IFACE STATUS QUERY");
> 	return hapd->iconf->enable_sycophant;
> }
> // MANA END
224d365
< 
2551a2693,2808
>  	// MANA
> 	} else if (os_strcmp(buf, "MANA_GET_SSID") == 0) {
> 		wpa_printf(MSG_DEBUG, "MANA CTRL_IFACE GET SSID");
> 		size_t len;
> 
> 		// +2 for the new line and the null byte terminator
> 		len = hapd->conf->ssid.ssid_len + 2;
> 		os_snprintf(reply, len, "%s\n", hapd->conf->ssid.ssid);
> 		reply_len = len;
> 
> 	} else if (os_strncmp(buf, "MANA_CHANGE_SSID ", 18) == 0) {
> 		if (hostapd_ctrl_iface_mana_change_ssid (hapd, buf + 18)) {
> 			reply_len = -1;
> 		} else {
> 			os_memcpy(reply, "CHANGED\n", 8);
> 			reply_len = 8;
> 		}
> 	} else if (os_strcmp(buf, "MANA_DISABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_enable_disable(hapd, 0))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "MANA_ENABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_enable_disable(hapd, 1))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "MANA_STATE") == 0) {
> 		if (hostapd_ctrl_iface_mana_get_state(hapd)) {
> 			os_memcpy(reply, "MANA ENABLED\n", 14);
> 			reply_len = 14;
> 		} else {
> 			os_memcpy(reply, "MANA DISABLED\n", 15);
> 			reply_len = 15;
> 		}
> 	} else if (os_strcmp(buf, "LOUD_ENABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_loud_enable_disable(hapd, 1))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "LOUD_DISABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_loud_enable_disable(hapd, 0))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "MANA_MODE") == 0) {
> 		if (hostapd_ctrl_iface_mana_get_mode(hapd)) {
> 			os_memcpy(reply, "MANA LOUD MODE ENABLED\n", 23);
> 			reply_len = 23;
> 		} else {
> 			os_memcpy(reply, "MANA LOUD MODE DISABLED\n", 24);
> 			reply_len = 24;
> 		}
> 	} else if (os_strcmp(buf, "MANAACL_ENABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_macacl_enable_disable(hapd, 1))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "MANAACL_DISABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_macacl_enable_disable(hapd, 0))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "MANA_ACLMODE") == 0) {
> 		if (hostapd_ctrl_iface_mana_get_aclmode(hapd)) {
> 			os_memcpy(reply, "MANA ACL MODE ENABLED\n", 22);
> 			reply_len = 22;
> 		} else {
> 			os_memcpy(reply, "MANA ACL MODE DISABLED\n", 23);
> 			reply_len = 23;
> 		}
> 	} else if (os_strcmp(buf, "WPE_ENABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_wpe_enable_disable(hapd, 1))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "WPE_DISABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_wpe_enable_disable(hapd, 0))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "WPE_MODE") == 0) {
> 		if (hostapd_ctrl_iface_mana_get_wpemode(hapd)) {
> 			os_memcpy(reply, "MANA WPE MODE ENABLED\n", 22);
> 			reply_len = 22;
> 		} else {
> 			os_memcpy(reply, "MANA WPE MODE DISABLED\n", 23);
> 			reply_len = 23;
> 		}
> 	} else if (os_strcmp(buf, "EAPSUCCESS_ENABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_eapsuccess_enable_disable(hapd, 1))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "EAPSUCCESS_DISABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_eapsuccess_enable_disable(hapd, 0))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "EAPSUCCESS_MODE") == 0) {
> 		if (hostapd_ctrl_iface_mana_get_eapsuccessmode(hapd)) {
> 			os_memcpy(reply, "MANA EAPSUCCESS MODE ENABLED\n", 29);
> 			reply_len = 29;
> 		} else {
> 			os_memcpy(reply, "MANA EAPSUCCESS MODE DISABLED\n", 30);
> 			reply_len = 30;
> 		}
> 	} else if (os_strcmp(buf, "MANA_EAPTLS_ENABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_eaptls_enable_disable(hapd, 1))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "MANA_EAPTLS_DISABLE") == 0) {
> 		if (hostapd_ctrl_iface_mana_eaptls_enable_disable(hapd, 0))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "MANA_EAPTLS_MODE") == 0) {
> 		if (hostapd_ctrl_iface_mana_get_eaptlsmode(hapd)) {
> 			os_memcpy(reply, "MANA EAPTLS MODE ENABLED\n", 25);
> 			reply_len = 25;
> 		} else {
> 			os_memcpy(reply, "MANA EAPTLS MODE DISABLED\n", 26);
> 			reply_len = 26;
> 		}
> 	} else if (os_strcmp(buf, "SYCOPHANT_DISABLE") == 0) {
> 		if (hostapd_ctrl_iface_sycophant_enable_disable(hapd, 0))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "SYCOPHANT_ENABLE") == 0) {
> 		if (hostapd_ctrl_iface_sycophant_enable_disable(hapd, 1))
> 			reply_len = -1;
> 	} else if (os_strcmp(buf, "SYCOPHANT_STATE") == 0) {
> 		if (hostapd_ctrl_iface_sycophant_get_state(hapd)) {
> 			os_memcpy(reply, "SYCOPHANT ENABLED\n", 18);
> 			reply_len = 18;
> 		} else {
> 			os_memcpy(reply, "SYCOPHANT DISABLED\n", 19);
> 			reply_len = 19;
> 		}
>  	// END MANA
diff '--color=auto' -rN hostapd-2.6/hostapd/defconfig hostapd-mana/hostapd/defconfig
114c114
< #CONFIG_EAP_FAST=y
---
> CONFIG_EAP_FAST=y
diff '--color=auto' -rN hostapd-2.6/hostapd/hostapd.accept hostapd-mana/hostapd/hostapd.accept
3a4,14
> # A MAC mask can be used to specify a range of MAC addresses. However
> # this is only useful with mana_macacl and ignored by normal macaddr_acl
> # behaviour.
> # For example:
> # 00:11:22:33:44:55		00:ff:00:ff:00:ff
> # will be similar to saying allow all MAC addresses that match: *:11:*:33:*:55
> # Locally administered MACs (i.e. the random MACs) used by some device to probe
> # for networks are handled by the below MAC and mask. It's essentially checking
> # for the second bit having been set in the MAC i.e. ??????1?:*:*:*:*:*
> 02:00:00:00:00:00 	02:00:00:00:00:00
> 
6a18,19
> 00:44:33:dd:aa:33	00:00:00:00:00:00
> 00:aa:bb:ee:00:00	100 ff:00:00:00:ff:ff
diff '--color=auto' -rN hostapd-2.6/hostapd/hostapd_cli.c hostapd-mana/hostapd/hostapd_cli.c
18a19
> #include "ap/ap_config.h" //MANA
334a336,447
> // MANA START
> static int hostapd_cli_cmd_mana_change_ssid(struct wpa_ctrl *ctrl, int argc,
> 					char *argv[])
> {
> 	// Max length of SSID is 32 chars + the command and the null byte
> 	char buf[50];
> 	if (argc < 1) {
> 		printf("Invalid 'change Mana SSID' command - exactly one "
> 		       "argument, SSID, is required.\n");
> 		return -1;
> 	}
> 	if (strlen(argv[0]) > SSID_MAX_LEN) {
> 		printf("The max length of an SSID is %i\n", SSID_MAX_LEN);
> 		return -1;
> 	}
> 	os_snprintf(buf, sizeof(buf), "MANA_CHANGE_SSID %s", argv[0]);
> 	return wpa_ctrl_command(ctrl, buf);
> }
> 
> static int hostapd_cli_cmd_mana_get_ssid(struct wpa_ctrl *ctrl, int argc,
> 					char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANA_GET_SSID");
> }
> 
> // These should be one function with a parameter
> static int hostapd_cli_cmd_mana_disable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANA_DISABLE");
> }
> static int hostapd_cli_cmd_mana_enable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANA_ENABLE");
> }
> static int hostapd_cli_cmd_mana_get_state(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANA_STATE");
> }
> static int hostapd_cli_cmd_mana_loud_disable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "LOUD_DISABLE");
> }
> static int hostapd_cli_cmd_mana_loud_enable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "LOUD_ENABLE");
> }
> static int hostapd_cli_cmd_mana_get_mode(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANA_MODE"); //GET_LOUD_MODE mana_loud
> }
> static int hostapd_cli_cmd_mana_macacl_disable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANAACL_DISABLE");
> }
> static int hostapd_cli_cmd_mana_macacl_enable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANAACL_ENABLE");
> }
> static int hostapd_cli_cmd_mana_get_aclmode(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANAACL_MODE");
> }
> static int hostapd_cli_cmd_mana_wpe_disable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "WPE_DISABLE");
> }
> static int hostapd_cli_cmd_mana_wpe_enable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "WPE_ENABLE");
> }
> static int hostapd_cli_cmd_mana_get_wpemode(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "WPE_MODE"); 
> }
> static int hostapd_cli_cmd_mana_eapsuccess_disable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "EAPSUCCESS_DISABLE");
> }
> static int hostapd_cli_cmd_mana_eapsuccess_enable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "EAPSUCCESS_ENABLE");
> }
> static int hostapd_cli_cmd_mana_get_eapsuccess(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "EAPSUCCESS_STATE");
> }
> static int hostapd_cli_cmd_mana_eaptls_disable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANA_EAPTLS_DISABLE");
> }
> static int hostapd_cli_cmd_mana_eaptls_enable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANA_EAPTLS_ENABLE");
> }
> static int hostapd_cli_cmd_mana_get_eaptls(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "MANA_EAPTLS_STATE");
> }
> static int hostapd_cli_cmd_sycophant_disable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "SYCOPHANT_DISABLE");
> }
> static int hostapd_cli_cmd_sycophant_enable(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "SYCOPHANT_ENABLE");
> }
> static int hostapd_cli_cmd_sycophant_get_state(struct wpa_ctrl *ctrl, int argc, char *argv[])
> {
> 	return wpa_ctrl_command(ctrl, "SYCOPHANT_STATE");
> }
> // END MANA
> 
1362a1476,1502
>  // MANA START
> 	{ "?", hostapd_cli_cmd_help, NULL, NULL }, //One of digininja's original changes :)
> 	{ "mana_change_ssid", hostapd_cli_cmd_mana_change_ssid, NULL, "= change the default SSID for when mana is off" },
> 	{ "mana_get_ssid", hostapd_cli_cmd_mana_get_ssid, NULL, "= get the default SSID for when mana is off" },
> 	{ "mana_get_state", hostapd_cli_cmd_mana_get_state, NULL, "= get whether mana is enabled or not" },
> 	{ "mana_disable", hostapd_cli_cmd_mana_disable, NULL, "= disable mana" },
> 	{ "mana_enable", hostapd_cli_cmd_mana_enable, NULL, "= enable mana" },
> 	{ "mana_loud_off", hostapd_cli_cmd_mana_loud_disable, NULL, "= disable mana's loud mode" },
> 	{ "mana_loud_on", hostapd_cli_cmd_mana_loud_enable, NULL, "= enable mana's loud mode" },
> 	{ "mana_loud_state",  hostapd_cli_cmd_mana_get_mode, NULL, "= check mana's loud mode" },
> 	{ "mana_macacl_off", hostapd_cli_cmd_mana_macacl_disable, NULL, "= disable MAC ACLs at management frame level" },
> 	{ "mana_macacl_on", hostapd_cli_cmd_mana_macacl_enable, NULL, "= enable MAC ACLs at management frame level" },
> 	{ "mana_macacl_state", hostapd_cli_cmd_mana_get_aclmode, NULL, "= check mana's MAC ACL mode" },
> 	{ "mana_wpe_off", hostapd_cli_cmd_mana_wpe_disable, NULL, "= disable mana's wpe mode" },
> 	{ "mana_wpe_on", hostapd_cli_cmd_mana_wpe_enable, NULL, "= enable mana's wpe mode" },
> 	{ "mana_wpe_state", hostapd_cli_cmd_mana_get_wpemode, NULL, "= check mana's wpe mode" },
> 	{ "mana_eapsuccess_off", hostapd_cli_cmd_mana_eapsuccess_disable, NULL, "= disable mana's eapsuccess mode" },
> 	{ "mana_eapsuccess_on", hostapd_cli_cmd_mana_eapsuccess_enable, NULL, "= enable mana's eapsuccess mode" },
> 	{ "mana_eapsuccess_state", hostapd_cli_cmd_mana_get_eapsuccess, NULL, "= check mana's eapsuccess mode" },
> 	{ "mana_eaptls_off", hostapd_cli_cmd_mana_eaptls_disable, NULL, "= disable mana's eaptls mode" },
> 	{ "mana_eaptls_on", hostapd_cli_cmd_mana_eaptls_enable, NULL, "= enable mana's eaptls mode" },
> 	{ "mana_eaptls_state", hostapd_cli_cmd_mana_get_eaptls, NULL, "= check mana's eaptls mode" },
> 	{ "sycophant_get_state", hostapd_cli_cmd_sycophant_get_state, NULL, "= get whether sycophant is enabled or not" },
> 	{ "sycophant_disable", hostapd_cli_cmd_sycophant_disable, NULL, "= disable sycophant" },
> 	{ "sycophant_enable", hostapd_cli_cmd_sycophant_enable, NULL, "= enable sycophant" },
>  // END MANA
> 
diff '--color=auto' -rN hostapd-2.6/hostapd/hostapd.conf hostapd-mana/hostapd/hostapd.conf
0a1,74
> ##### MANA specific configurations ############################################
> # MANA attacks include KARMA attacks as well as responding to broadcast probes.
> # Enabling this will attempt to attract devices probing for "other" networks.
> # If you want a "standard AP" that only looks like one network, don't enable this.
> # 0 = disabled - don't perform MANA attacks
> # 1 = enabled - perform MANA attacks 
> enable_mana=1
> 
> # By default, MANA will be a little stealthy and only advertise probed for networks
> # directly to the device that probed for it.
> # However, not all devices probe as much as they used to, and some devices will
> # probe with "random" locally administered MAC addresses.
> # Loud mode will re-broadcast all networks to all devices.
> # 0 = disabled - networks are broadcast at the specific devices looking for them
> # 1 = enabled - networks are advertised to all devices
> mana_loud=0
> 
> # By default, MANA will behave the same for all SSIDs, enabling this filter will
> # create a white-list of allowed SSIDs and any others will be ignored
> #mana_ssid_filter_file=hostapd.ssid_filter
> 
> # Normal access points MAC ACLs will only work at association level. This option
> # will expand MAC ACLs to probe responses. 
> # It requires macaddr_acl to be set later in the config file to work. This controls
> # whether we're operating in black or white list mode. The MACs are defined in the
> # files listed in accept_mac_file and deny_mac_file.
> # Setting ignore_broadcast_ssid below will also hide the base network from
> # non-authorised devices.
> # 0 = disabled - MAC ACLs are not applied to probe response frames (default)
> # 1 = enabled - MAC ACLs will be extended to probe response frames
> mana_macacl=0
> 
> # Dump seen device activity to a file
> # Will include MAC (randomised or not) and SSIDs probed for in the format
> # <MAC>, <SSID>, <Random 1, or not 0>, <TAXONOMY>
> #mana_outfile=hostapd.manaout
> # You'll need hostapd compiled with CONFIG_TAXONOMY to get the last field
> # You'll also need to enable the following in your config file (described below):
> #track_sta_max_num=100
> #track_sta_max_age=180
> 
> # Enable EAP credential capture mode (aka WPE)
> # Make sure you configure a file to write these too with mana_credout below
> # otherwise you'll have to catch them as they scroll past on the screen.
> # Off by default
> #mana_wpe=1
> 
> # Write captured credentials (aka WPE) (ex. ennode)
> # This is typically PEAP MSCHAPv2 challenge response hashes that can be cracked
> # by hashcat/jtr/asleap or similar. TTLS/MSCHAP TTLS/CHAP TTLS/PAP will also be
> # captured. The mode will be designated at the start of the line, separated
> # from the cracking string by a tab if you'd like to grep & cut.
> #mana_credout=hostapd.credout
> 
> # Write captured WPA/2 handshakes to a hashcat hccapx format file
> # Can be cracked with hashcat -m2500
> #mana_wpaout=hostapd.hccapx
> 
> # Enable EAP Success mode (from WPE)
> # Allow clients to connect with incorrect credentials
> # Most often, when rogue AP'ing you won't have the clients creds
> # But still want a shot at collecting them via MitM
> #mana_eapsuccess=1
> 
> # Enabled Sycophant
> # Allows relaying of inner EAP authentication methods with a modified wpa_supplicant
> # wpa_sycophant is available at https://github.com/sensepost/wpa_sycophant
> #enable_sycophant=1
> 
> # Sycophant state file directory
> # Sycophant communicates with wpa_sycophant through several files
> # This specifies the location of those files
> #sycophant_dir=/tmp/
> 
271a346,349
> # NB If enable_mana is set above, this option will not prevent hostapd from
> # responding to broadcast probe requests, but will remove the ESSID from the
> # beacons. If set in conjunction with mana_macacl (see above) it will effectively
> # hide the network from "denied" MAC addresses.
439c517
< #ap_max_inactivity=300
---
> ap_max_inactivity=3000
445c523
< #skip_inactivity_poll=0
---
> skip_inactivity_poll=0
450c528
< #disassoc_low_ack=1
---
> disassoc_low_ack=0
1989c2067
< #bss=wlan0_0
---
> #bss=wlan1
1990a2069
> #bssid=02:21:91:01:11:31
diff '--color=auto' -rN hostapd-2.6/hostapd/main.c hostapd-mana/hostapd/main.c
451c451
< 		"hostapd v" VERSION_STR "\n"
---
> 		"hostapd-mana v" VERSION_STR "\n"
455c455,463
< 		"and contributors\n");
---
> 		//"and contributors\n");
>  		"and contributors\n"
>  		"--------------------------------------------------\n"
>  		"MANA https://github.com/sensepost/hostapd-mana\n"
>  		"By @singe (dominic@sensepost.com)\n"
> 		"Original MANA EAP by Ian (ian@sensepost.com)\n"
>  		"Original karma patches by Robin Wood - robin@digininja.org\n"
>  		"Original EAP patches by Brad Antoniewicz @brad_anton\n"
> 		"Sycophant by Michael Kruger @_cablethief");
diff '--color=auto' -rN hostapd-2.6/hostapd/Makefile hostapd-mana/hostapd/Makefile
88a89
> OBJS += ../src/common/mana.o
